문 -> 공, 식, 제
식(값) -> 변수, 식별자 

우리의 생각을 어떻게 컴퓨터로 표현하는가?

함수 ( 행위, 동사 ) => 내가 하고자하는 것을 표현한다. 우리가 함수들을 동사로 만듦
객체

이름은 인간들을 위해서 짓는다.
명사를 다른 동사가 건드리면 원래 동사의 동작을 보장할수 없으니 스코프 분리를 한다.

우리가 먹는다는 것을 제대로 쓸려면 컨텍스트를 고정시켜야 한다.
컨텍스트를 바인딩 했을때 컨텍스트를 아무나 수정하지 못하도록 하는게 은닉이다.
먹는다만 노출한다면 그것이 캡슐화이다.
그것을 단단하게 감싼다. 그게 객체이다.

일단 작문을 해봐야 한다. 올바른 작문을 해야한다.
바른 표현을 배우는 방법을 배워야 한다.

권한-은닉, 추상화-캡슐화??못적음, 
추상화
    - 분류
    - 모델링 : 원래는 복잡한데... 필요한 것만 옮긴다.( 행동에 대한 모델링 은 ??? 놓침)
    - 

객체는 더욱더 발전된 추상화..
은닉과 캡슐화는 모든 프로그래밍에서 사용되어야 하는 것이다.

# 다형성 : 다양한 역할을 가질수 있다.
객체에서 추가되는 기법 : 다형성. ( 형? 역할에 가깝다.  )
단일 책임 원칙이랑 다형성과 부딫히는데 어떻게 하는가?

다형성의 특징
1. 대체가능성( 일반적으로 상속과정에서 볼수 있다.) 부분 집합 관계일때. 큰 그룹과 작은 그룹으로 대체. 작은 -> 큰 o ..  큰 -> 작은 x
    - 더 큰 그룹으로 바꾸는 것을 upcasting
    - 더 작은 그룹으로 바꾸는 것을 downcasting ( 실패 가능성 있다. )
    - 포함관계가 있는 경우 이것을 상속관계라고 한다. 병렬적 수직적 다 가능하다.
2. 내적 동질성, 내적 일관성
    - 사장, 남자, 선생으로 역할 하든 본연의 본질은 다르지 않다. 무언가 수행할때, 어떠한 역할로서 하든 그 것을 행하는 것, 주체는 자신이다.
    - 제일 자식 위치에 있는 것이 발동이 된다. 

객체지향은 다형성이라는 특징을 가진다. 이것은 굉장히 구체적인 대체가능성과 내적 일관성이 있어야 한다.

오늘 배울 것은 다형성 - 대체가능성이면서 단일 책임 원칙을 지키는 것인지..
긴 코드를 쪼개는 것은 역할, 책임으로 나누는 것이다.

값에는 기본형, 참조형이 있다.
기본형에서는 값을 비교시에 값을 비교한다.
참조형은 값을 비교할때 값의 참조 주소위치를 비교한다.

우리는 특정한 객체의 주소값을 식별이라고 한다.
유일한 식별자만 가지고 있는 객체를 바꾼다.

객체간의 의존성의 맵 => 객체망.. : 역할을 수행하는 객들간의 망을 구성해서 문제를 해결한다.

함수로 호출한다는 것은 행위를 하는 것이다. 행위를 하면 좋은 점은 그 행위를 하겠다는 요청할뿐이지 뭐가 일어날지 알수 없다.
함수를 하면 그 이후 함수안에 다른 여러가지 코드를 넣음으로서 유연성을 가질수 있다. 따라서 최대한 함수로 만들어주는 것이다.
함수에 갇혀 잇으면 호출지연이 일어난다. 따라서 함수에서 어떠한 값을 리턴할때 그리턴하기전까지 여러가지로 할수 잇는 게 생긴다.
따라서 최대한 함수로 노출해야지 값으로 노출하지 않는다.

사본에 의한 식별 비교. 그러면 원본은 건드리지 못하게 된다.
세상의 모든 함수는 캡슐화되어 있다.
renderer에서 init, render가 필요하다는 지식을 todo 도 알고 있고 html도 알고 있어야지만 한다. 콘솔도 봐야 하고..
즉 다같이 알아야 한다. 그래서 바깥에 다른 무엇이 알고있어야 한다.
setRenderer가 알고있으면 안된다. 

init 또는 reder는 프로토콜, 약속인 인터페이스, 클래스이다.
따라서 이것은 분리시켜줘야 한다.
자바스크립트에서는 이러한 약속은 함수로 만든다.
인터페이스, 프로토콜, 클래스의 첫 이름은 함수와 다르게 대문자이다. 

```javascript

// 우리가 정의하고픈 약속.
var Renderer = function() {}
Renderer.prototype.init = function(todo) {};
Renderer.prototype.render = function(tasks) {};

```

형식 정의 언어 -> 타입 베이스 언어
형식적인 언어를 쓰면 추상화ㅗ디게 사용할수 있다.
역할이 형에게 넘어간다. 디테일은 형만 발라본다.

Renderer는 약속일 뿐이다.
실질적인 행위는 html, con이 해주는 것이다.

html, con이 Renderer을 상속받았음을 증명해줘야 한다. 코드에.
상속을 받을려면 반드시 형이 필요하다.
html은 형이 없기 때문에 형을 정의하지 않으면 Renderer을 받을수 없다.

다형성에서의 대체가능성
htmlㅇ기도 ㅎ지만 renderer를 대체할수 있다.
renderer 의 형이 init가ㅘ... 

부모의 메소드를 자식이 덮어쓴다고 해서 오버라이드라고 한다.
# 자바스크립트에서의 this를 이용한 오버라이딩 

# 객체 스코프 -> this..

?? 지금 말하는 형 전체가 타입인가? 클래스인가? 역할인가?


init, renderer

이것은 todo, <= Con에서 con 자식, Html 에서 html 자식

