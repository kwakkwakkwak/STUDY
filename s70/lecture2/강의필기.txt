 진짜 핵심기능은 함수속 함수에 있다.
    껍데기 기능은 바깥쪽에 있다.

    상태 => 진행 / 완료
    data => 할일 

    dataview
    우리는 데이터를 예쁜 데이터뷰를 통해서 보여준다.

    데이터란 무엇인가? 기억해야만 하는 것이다.
    기능에 없는 데이터는 버그를 유발할 수 있다.

    app의 핵심은 데이터이다. 
    todoList에서의 흐름은 눈에 보이는 목록에 하나를 더 추가한다는 것이 아니라
    todoList의 data에 추가, 삭제 등을 통해서 data를 수정하고
    그 data를 다시 전체를 그려서 보여주는 것이다.

    모델링 : 수많은 정보중에서 나에게 필요한 정보를 추려내는 것.
    함수가 필요한 이유 : 모델링한 것을 표현할수 있는 어휘가 필요하다.

    모델링에 성공하지 않으면 데이터의 실체를 알수없고 그것은 데이터를 어떻게 해독할지 알수 없다.
    모델링을 했으니 어휘를 정리할 수 잇다.
    모델링을 했으니 그에 필요한 행위를 정할수 있다.

    모든 함수는 행위를 하며 그 행위에 대한 역할이 있다.

    데이터에 필요한 행위는? 
    할일을 추가한다. ( 모델에 title + 진행으로 추가한다.)
    할일을 제거한다. ( 인자를 무엇으로 받아야 할까? )
        title을 받으면 될까? No 왜냐면 유니크 하지 않다.
        모델에 대해서 값 뿐만 아니라 속성도 가지고 있다.
        title 속성 => 유니크하지 않다.
        완료/진행 속성 => 완료와 진행만 가진다.
        식별자가 필요하겠구나!
    
    이러한 고유번호는 인프라성이라서 그 고유번호 관리를 하면서 수익을 창출하고
    그것은 주로 대기업, 정부 등이 하고 그 수익성이 크다. 예 공인 인증서

    데이터의 값들이 식별할수 없는 값만 있으면 그것을 컨트롤 하기에 어렵다.
    따라서 고유한 식별자가 필요하다.

    함수는 행위를 할뿐이다. 그 행위의 근본은 전부다 모델에 있다.
    모델에 대한 이해도는 행위를 설계할수 있는 능력으로 직결된다.
    함수는 그저 데이터를 조작하는 것이기 때문이다.

    함수도 함부로 만드는게 아니라 반드시 필요한 것만 만든다.
    필통에 권총이 달리면 안된다. (비유) 권총은 멀쩡하지만 그것을 원하지 않는다.

    상태를 변경한다.  changeState( id, condition )
        status 는 확정된 상태, state는 변화하는 상태
        그러므로 우ㄹ는 state를 쓰는게 맞다.

    중요한건 이름 즉 어휘. 어휘만 알고 있으면 다알게 된다.
    우리가 필요한 행위는 어휘로 정리한다.
    함수를 만드는 이유는 우리가 필요한 행위를 어휘로 정리하기 위해서
    행위를 정리할 어휘가 필요할때에는 함수로 만든다.
    데이터를 정리할 어휘는 변수..

    [{id:아이디, title:타이틀, state:상태},
     {id:아이디, title:타이틀, state:상태},
     {id:아이디, title:타이틀, state:상태}]
    
    모델링을 하고 모델에 적합한 행위를 설계한다.
    
    var tasks = [];

    var STATE_P = '진행';
    var STATE_C = '완료';

    var addTask = (function() {
        var id = 0;

        return function(title) {
                    tasks.push({
                        title: title,
                        id: id++,
                        state: STATE_P
                    });
                    render();
                };
    })();

    var removeTask = function(id) {
        var isRemoved = false;

        for (var i = 0; i < tasks.length; i++) {
            if (tasks[i].id === id) {
                tasks.splice(i, 1);
                isRemoved = true;
                break;
            }
        }

        if (!isRemoved) {
            warning('removeTask: invalid id');
        }
        render();
    };

    var changeState = function(id, state) {
        var ID = false, STATE;
        for (var i = 0; i < tasks.length; i++) {
            if (tasks[i].id === id) {
                ID = id;
                break;
            }
        }
        if (ID === false) {
            warning('changeState: invalid id - ' + id);
            return;
        }

        if (state !== STATE_P && state !== STATE_C) {
            warning('changeState: invalid state - ' + state);
            return;
        } else {
            STATE = state;
        }

        for (var i = 0; i < tasks.length; i++) {
            if (tasks[i].id === ID) {
                tasks[i].state = STATE;
                break;
            }
        }

        render();
    };

    var warning = console.log;

    var render = function() {
        console.log('진행');

        var task;

        for (var i = 0; i < tasks.length; i++) {
            task = tasks[i];

            if (task.state === '진행') {
                console.log(task.id + '. ' + task.title + '(' + task.state + ')' );
            }
        }

        console.log('완료');

        for (var i = 0; i < tasks.length; i++) {
            task = tasks[i];

            if (task.state === '완료') {
                console.log(task.id + '. ' + task.title + '(' + task.state + ')' );
            }
        }

        console.log('추가     : addTask(할일 내용)');
        console.log('삭제     : removeTask(아이디)');
        console.log('상태 변경 : changeState(아이디, 상태 - 완료 또는 진행)');
    }

    render();

    개발자는 기획서를 받은 이후부터 개발한다.
    기획서를 보고 모델을 만들고 행위를 추가하는 일, 코드로 만드는일

    첫번째 tasks
    두번째는 id 식별자

    처음에 전역 변수  id 로 생성되어있다.
    id는 실제로 알아야 할 부분은 addTask만 알면된다.
    다른 애들은 id에 접근할 필요가 없다. 접근된다면 버그의 가능성, 
    깨질수 있다.
    
    안전하게 짜려면 접근권한을 철저히 관리해야 한다.
    스코프를 분리하고, 즉시실행함수를 실행해서 바깥족에 값을 ]
    리턴하는 센스가 필요하다.
    값을 리턴하는데 그것이 함수가 될수 있다.

    즉시 실행 함수, id를 스코프 격리 ( 클로져 사용 )
 
    var addTask = (function() {
        var id = 0;

        return function(title) {
                    tasks.push({
                        title: title,
                        id: id++,
                        state: STATE_P
                    });
                    render();
                };
    })();

    한번만 실행되면 함수를 리턴함으로서 그 리턴된 함수가 들어온다.
    왜 즉시실행함수로 감싸서 했는가? 스코프 분리 때문이다.
    리턴하는 함수만 id에 접근할수 있다.

    좋은 개발자인지 아닌지는 귀찮아서 대충 때우느냐 끝까지 집착하느냐에 따라서 달려있다.
    이러이러하니까 그럴수 밖에 없어라는 것을 귀찮아 하지 않고 언제나 구현한다면 
    향후 수정에도 프로그램 변화에도 깨지지 않는 안전한 프로그램을
    만들수 있다.

    왜냐면 그 식별자를 건드릴수 없기 때문이다.

    어휘환경의 분리야 말로 좋은 개발을 하느냐 아니냐를 보여주는 것이다.

    프로그램은 무조건 변한다는 변한다는 법칙이 있다.
    하지만 위와 같이 스코프 분리 및 접근 권한을 관리하면 식별자는 안전하게 된다.

    아이디가 전역으로 되어 다른 함수들이 다 건드릴수 있게 되면
    추후 다른 팀원이 건드리게 되어 엉망이 될수 있는 것이다.

    따라서 이것은 필수적이다.

    이 아이디를 addTask만이 발급해야 한다는 것은 모델에 대한 인지이다.
    자바스크립트 함수를 쓸수 있느냐는 모델에 대한 이해이지 언어에 대한 이해아니다.

    스코프를 컨트롤하는것은 언어마다 다르다. 

    무엇이 기본 값인가? 진행이 기본값이다.

    title: title,
    id: id++,
    state: "진행"

    만약 state에서 진행1이라고 넣게 되면 프로그램이 깨지게된다.

    STATE_P, STATE_C 라는 상수를 만들어준다. 전부대문자(변수 구분 위해)
    전역 변수에 있는 이유는 changeState도, render에도 참고해야 하므로 전역에 위치하게 된다.

    프로그램이란 어휘로 하는 것이다.
    우리가 정의한 어휘만 들어가게 된다.
    우리가 정의한 어휘들간의 행위로 볼수 있다.
    개발이란 우리가 어휘를 정의하고 어휘에 대한 행위로 이루어져 있는 
    지를 정확하게 코드로 나타낼수 있는가에 문제이다.
    우리가 진짜로 의도했던 것은 이러한 어휘들이다.
    우리가 원했던 것은 진행 상태가 되길 바란다. 그것을 의미하는 어휘를 만든 것

    어휘기반으로 개발할수 있는 센스를 갖고 바로 쓸수 잇으려면 훈련이 많이 필요하다.
    코드 전체에 대해서 왜 그렇게 만들었는지를 다 설명할수 잇어야 한다.    
    바르게 짰다면 다 설명할수 있다.

    좋은 개발, 나쁜 개발은 주관적이지 않다.
    좋은 개발은 정의될수 있다.

    small foot steps
    함수를 잘 짜면 일반적으로 7줄 정도로 짜진다.
    7줄 정도 짜면 테스트를 한다. 조금씩 전진한다.

    회귀테스트
    부분 테스트 말고 만든 것을 포함해서 전체적인 테스트를 실행하는 것
    나비효과처럼 부분의 변경이 전체 시스템에서의 영향을 테스트

    removeTask(1);  undefined
    removeTask(17); undefined

    결정의 순간이 있다.
    위와 같은 것은 좋은 것일까 아닐까?

    좋은 프레임은 최소한 알림이라도 온다.
    
    정상인지 아닌지를 알려면, 라이프 사이클이 있는 변수를 만들어 준다. (지역변수)
    처음에 함수 시작 부분에서 변수를 만들고, 초기화를 잡아준다.

    프로그램에서 새로운 상태가 나타내면 변수를 잡는 거 외에 답이 없다.
    해당 알고리즘이 도는 동안 라이프 사이클이 유지되는 변수를 만들어주는 것밖에 답이 없다.
    
    var removeTask = function(id) {
        var isRemoved = false;  <== 상태변화 저장해줄 변수

        for (var i = 0; i < tasks.length; i++) {
            if (tasks[i].id === id) {
                tasks.splice(i, 1);
                isRemoved = true;
                break;
            }
        }

        if (!isRemoved) {
            warning('removeTask: invalid id');
        }
        render();
    };

    사람을 위한 장치 때문에 변수, 알고리즘, 추가적인 로직이 들어가는 것은 극히 정상이다.
    프로그램의 본질은 사람을 가르치기 위해서, 사람 때문에 더 많은 변수와 상태와 로직이 들어간다.
    친절할수록 복잡도가 더 증가하는 것이다.
    복잡도가 증가하는 것은 휴먼 인터페이스 때문이다.

    개발하기 전에 철학적으로휴먼 인터페이스 레벨을 맞추고 시작하는 것이다.
    휴먼인터페이스가 코드에 영향을 준다. 얼마나 친절하게 할 것인지.

    이전에는 순수한 모델의 대한 데이터와 렌더 함수 호출로 로직이 정해져 있었다.
    순수한 데이터는 오직 메모리 상에서 존재하는 데이터이다.
    addTask는 데이터 추가하는데에만 신경 쓰기 때문에 온갖 곳에 사용할수 있는데
    아래 코드 때문에 콘솔용 앱에만 사용할수 있게 되는 것이다.
    if (!isRemoved) {
        console.log('removeTask: invalid id');
    }

    native logic
    순수한 데이터를 방해하고 특정한 시스템에 바인딩되게 만드는 로직을 
    네이티브 로직이라고 한다.

    console.log 한줄 때문에 콘솔 전용 함수가 되어 버리는 것이다.
    기능을 추가할때 이런 일이 엄청 발생한다.

    우리가 할일은 콘솔 로그를 제거하고 warning 함수를 가지고 오는 것이다.
    이렇게 함으로서 특정 환경에 바인딩 되는 것이 아니라 온갖 플랫폼에서 
    쓸수 있는 순수한 behavior로 돌아왔다.
    우리가 모델을 처리하는 behavior을 작성할때 중요한 것은 
    native binding을 제거하는 것이다.
    모델을 갱신하는 건데 네이티브 바인딩 되면서 종속되어 버린다.
    모델용 behavior의 핵심은 네이티브와 바인딩 되면 안된다.
    네이티브로 할 것을 행위로 바꿔주면 된다. 그럼 이 행위자가 알아서 할 것이다.
    이렇게 복잡한 네이티브 행위를 떠넘기는 것을 위임이라고 한다. delegation

    changeState(id, state)
    state에 안녕 이라고 써버리면 오염되어 버린다.
    따라서 이러한 인자 값을 검사하기 위해서 validation을 써준다.

    
    if (state !== STATE_P && state !== STATE_C) {
        warning('changeState: invalid state - ' + state);
        return;
    }
    이렇게 하면 state를 체크하면서 
    이 밑에서는 state를 걱정할 필요 없이 알고리즘 로직만 아름답게 짤수 있다.
    
    쉴드 패턴
    이렇게 위에서 방어를 해서 방어가 끝나고 무사한 값만 쓰는 패턴
    잘못된 인자 값을 막아주는 패턴. 밸리데이션을 할때 쓰인다.


    var changeState = function(id, state) {
        var ID = false,  // ID는 false가 될수 없는데 false가 되면 잘못된 것이다.
            STATE;
        for (var i = 0; i < tasks.length; i++) {
            if (tasks[i].id === id) {
                ID = id;
                break;
            }
        }

        if (ID === false) {
            warning('changeState: invalid id - ' + id);
            return;
        }
        .....

    }

    우리는 외부에서 가져온 값을 믿을수 없으니 검증을 해야 한다.
    검증된 값을 ID에 넣어준다.
    이렇게 해서 validation전의 값을 validation 후의 값으로 바꿔 주는 것을 
    화이트 리스트 라고 한다. 믿을수 있는 값이다.
    처음에 화이트 리스트를 정해 주면 된다. var ID, STATE

    그러면 아래에는 화이트 리스트로만 이용해서 코드를 짜면된다.

    밸리데이션, 쉴드 패턴, 화이트 리스트
    
    밸리데이션의 부산물은 화이트 리스트이다.

    벨리데이션과 알고리즘을 같이 결합되어 있다.
    이렇게 되면 이해하기 어렵다.
    일부는 밸리데이션을, 일부는 알고리즘을 담당하기 때문에 그렇다.
    
    하지만  벨리데이션과 알고리즘이 분리되어 있으니
    밸리데이션이 변하면, 알고리즘이 변하면 각각에 대해서만 변경을 해주면된다.
    이해하기도 쉽고 추후 유지보수에도 좋은 코드이다.

    밸리데이션, 쉴드, 알고리즘의 변화에 대해서 각각 대응할수 있는 
    코드가 된다.
    알고리즘은 안전할수 밖에 없는데 화이트 리스트만 쓰기 때문이며
    쉴드패턴으로 다 안좋은 값은 다 날아갔기 때문이다.

    개발은 굉장히 철학적이다.

    쉴드 패턴을 써서 밸리데이션을 처리한 다음에 화이트리스트만 
    가지고 알고리즘을 짜면 된다.
    (굉장히 명확하다!)

    개발이 쉽게 보이는거는 개발이 쉽다라고 잘못 배우는 것이다.
    
    task를 탐색한다는 for 반복문이 거슬린다! 반복된다!
    (다음시간에)

    var warning = console.log;
    어휘를 만들어 주었다. 우리가 원하는 어휘는 네이티브가 아니니까.
    어휘를 활용해서 짜주는 것이니까.

    각 행위에 대해서 마지막에 render만 호출하면 된다.

    우리가 신경써야 할 것은 데이터
    우리가 얼마나 잘 데이터를 모델링 할수 있는가?
    데이터에 대한 행위를 얼만큼 네이티브와 잘 분리해서 작성할수 있는가?

    이렇게 하면 HTML버전이나 콘솔 버전이나 모바일 버전에서 활용할수 있게 만들수 있다.
    