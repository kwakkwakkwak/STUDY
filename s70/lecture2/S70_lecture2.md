# S70 2번째 시간 정리



### 데이터

데이터란 기억해야만 하는 것이다. 
기능에 없는 데이터는 버그를 유발할수 있다.
app의 핵심은 데이터이다.

### 

### 데이터뷰

우리는 데이터를 데이터뷰를 통해서 보여준다.



### 함수

함수는 데이터, 즉 모델을 조작하는 것이다.
함수는 행위를 하며 그 근본은 전부 모델에 있다.
함수는 반드시 필요한 것만 만들어야 한다.
함수를 만드는 이유는 우리가 필요한 행위를 어휘로 정리하기 위해서이다.
불필요한 함수는 버그를 낳을수 있다.
모델을 조작하는 것이기 때문에 모델 이해도가 행위 설계 능력으로 이어진다.



### 어휘

프로그래밍은 어휘로 하는 것 이다. 따라서 어휘만 알고 있으면 다 알수 있다.
필요한 행위가 있으면 함수를 만들고 어휘로 정의 및 정리 한다.
우리가 정의한 어휘로 프로그래밍을 하며 그 어휘간의 행위, 상호작용, 의사소통으로 볼 수 있다.
우리가 원하는 어휘는 네이티브가 아니다.
어휘 기반 개발 센스는 훈련이 많이 필요하다.
​	
( 각 어휘마다 메소드, 함수, 상태 등을 가지고 있그 그 어휘간의 상호작용으로 이루어지는 그물같은 연결 망을 생각하면 좀더 쉽게 다가오지 않을까? 
각각의 프리미티브 값이 아닌 각각의 어휘, 즉 이름을 부여해 줌으로서 그들끼리의 관계들을 형성해 주는 것이다.
그의 이름을 불러 주었을때 비로소 꽃이 되었다는 시인 김춘수의 꽃이 생각났다. )	



### 개발

개발이란 우리가 어휘를 정의하고 어휘에 대한 행위로 이루어져 있는 지를 정확하게 나타낼 수 있는가에 대한 문제이다.
코드 전체에 대해서 왜 그렇게 만들었는지를 다 설명할 수 있어야 한다.	바르게 짰다면 다 설명할 수 있다.
좋은 개발은 정의할 수 있으며 주관적이지 않다.
​	
개발은 굉장히 철학적이다.
개발이 쉽게 보이는 거는 개발이 쉽다고 잘못 배우는 것이다.
​	
우리가 신경써야 하는 것은 데이터이다.
우리가 얼마나 데이터를 잘 모델링 할 수 있는가?
데이터에 대한 행위를 얼마나 네이티브와 분리해서 작성할 수 있는가?
이렇게 하면 특정 환경에 종속되지 않고 여러 환경에서 활용할 수 있게 된다.

​	

### test

#### small steps 

함수를 잘 짜면 일반적으로 7줄 정도로 짜진다.
따라서 7줄 정도 짜면 테스트를 하며 조금씩 전진한다.
​	

#### 회귀테스트

부분 테스트 말고 만든 것을 포함해서 전체 테스트를 실행하는 것이다.
나비효과처럼 부분의 변경이 전체 시스템에서의 어떤 영향을 주는지 테스트 한다.



### 알림

좋은 프레임은 최소한 알림이라도 온다.
알림을 위해서 해당 함수의 라이프 사이클에 살아있는 변수를 만들어 준다.
처음 함수 시작 부분에서 변수를 만들고 초기화를 잡아준다.
프로그램에서 새로운 상태가 나타나면 변수를 잡아주는 거 외에는 답이 없다.
해당 알고리즘이 도는 동안 라이프 사이클이 유지되는 변수를 만들어주는 것밖에 답이 없다.



### 휴면 인터페이스

사람을 위한 장치 때문에 변수, 알고리즘, 로직이 추가적으로 들어가는 것은 극히 정상이다.
프로그램의 본질은 사람을 가르치기 위해서이며 사람 때문에 더 많은 변수와 상태와 로직이 들어간다.
친절할수록 복잡도가 더 증가하는 것이다.
복잡도가 증가하는 것은 휴먼 인터페이스 때문이다.
개발하기 전에 철학적으로 휴먼 인터페이스 레벨을 맞추고 시작하는 것이다.
휴먼인터페이스가 코드에 영향을 준다. 얼마나 친절하게 할 것인지.



### 순수

순수한 데이터는 오직 메모리 상에서 존재하는 데이터이다.
순수한 데이터는 여러 플랫폼, 환경에서 사용할 수 있다.



### 네이티브 로직

console.log 와 같은 코드는 콘솔 환경에서만 쓸수 있다.
순수한 데이터를 방해하고 특정한 시스템에 바인딩되게 만드는 로직을 네이티브 로직이라고 한다.
기능을 추가할때 이런 일이 자주 발생한다.



### 순수한 behavior

네이티브 로직을 제거하고 네이티브 로직을 담은 함수를 만들어서 그 함수를 호출하도록 한다.
이렇게 하면 특정 환경에 바인딩 되지 않고 다양한 환경에서 사용할수 있다.
모델을 처리하는 behavior를 작성할 때 중요한 것은 native binding을 제거하는 것이다.
native binding이 있으면 종속되어 버린다.
모델용 behavior의 핵심은 네이티브 바인딩이 되어서는 안된다는 것이다.
네이티브로 할 것을 behavior 로 바꿔주면 그 행위자가 알아서 할 것이다.
이렇게복잡한 네이티브 행위를 떠넘기는 것을 delegation 위임이라고 한다.



### 모델링

수많은 정보중에서 나에게 필요한 정보를 추려내는 것이다.
모델링에 성공하지 않으면 데이터의 실체를 알 수 없다.
데이터의 실체를 알아야지 데이터를 어떻게 해독할지 알 수 있다.
모델링을 했다면 어휘를 정리할 수 있으며 필요한 행위를 정할 수 있다.
모델링을 하고 모델에 적합한 행위를 설계한다.



### 행위

모든 함수는 행위를 하며 그 행위에 대한 역할이 있다.



### 안전한 코딩

스코프를 분리하고 접근권한을 철저히 관리해야 한다.
JS에서는 즉시실행함수와 클로져를 활용해서 바깥쪽에 값를 리턴하는 센스가 필요하다.
JS는 함수가 1급 객체 이므로 함수를 리턴할 수 있다.
리턴된 함수만이 클로져를 통해 내부 변수에 접근할 수 있게 만든다.
어휘환경의 분리는 좋은 개발을 하느냐 아니냐를 보여주는 것이다.
프로그램의 절대진리는 언제나 변한다는 것이다.
그 변화 속에서도 스코프 분리 및 접근 권한 관리를 통해 식별자는 안전하게 되고 안전한 프로그램을 만든다.
스코프 분리 및 접근 권한 컨트롤은 필수 적이다.



### 좋은 개발자

좋은 개발자인지 아닌지는 귀찮아서 대충 때우느냐 끝까지 집착하느냐에 있다.
이러이러한 이유로 그렇게 코딩해야 하는 것을 언제나 구현할수 있는 개발자이다.
좋은 개발자의 코드는 향후 수정에도, 프로그램 변화에도 깨지지 않는 안전한 프로그램을 만든다.



### 함수

JS 함수를 쓸수 있느냐는 모델에 대한 이해이지 언어에 대한 이해가 아니다.



### todoList

todoList의 흐름은 눈에 보이는 목록에 하나의 목록을 더 추가하는 것이 아니라
데이터에 추가, 삭제 등을 통해서 조작하고 그 데이터를 다시 전체 그려서 보여주는것

```
상태 : 진행 / 완료
데이터 : 할일
행위

addTask( title ) : 모델에 title, 진행 을 추가한다.
클로져, IIFE를 응용한 스코프 격리

removeTask( id )
인자로 무엇을 받아야 할 것인가?
title은 유니크 하지 않고 중복 가능한 것이 속성이다. 따라서 인자x
상태 : 완료/진행 만 가지는 것이 속성이다.
모델은 값 뿐만 아니라 속성도 가지고 있다.
삭제, 데이터 조작을 하려면 각자를 식별할수 있는 고유한 식별자가 필요하다!
	
changeState( id, condition )
status는 확정된 상태라서 적절하지 않고 state를 쓴다.
```



### todoList의 데이터

    [{id:아이디, title:타이틀, state:상태},
     {id:아이디, title:타이틀, state:상태},
     {id:아이디, title:타이틀, state:상태}]



### id

id를 실제로 알아야 하는 함수는 addTask이다.
다른 함수들은 id에 접근할 필요가 없다. 만약 접근이 된다면 버그의가능성, 깨질수 있다.
id가 전역변수가 되어 다른 함수에서 다 건드릴수 있게 되면	추후 다른 팀원이 건드리게 되어 엉망이 될수 있다.
id는 addTask만이 발급해야 한다는 것은 모델에 대한 인지이다.

### state

state에 진행1 이라고 넣게 되면 프로그램은 깨지게 된다.
STATE_P, STATE_C 상수를 만들어 준다.
전역 변수에 있는 이유는 changeState, render에서도 참고해야 하기 때문이다.
우리가 원한 것은 진행 상태가 되기를 원했고 그것을 의미하는 어휘를 만든 것이다.	

### 상수

변수 구분을 위해서 전부 대문자로 한다.

### validation

외부에서 입력된 값을 믿을수 없으니 검증을 해야 한다. 
validation 코드를 통해 그 코드 밑으로는 인자값의 유효성을 걱정할 필요 없이	알고리즘 로직만 아름답게 코딩할 수 있다.
validation의 부산물이 화이트 리스트이다.

### 쉴드패턴

방어를 하고 방어에서 통과한 안전한 값만 쓰는 패턴이다.
잘못된 값을 막아주며 validation을 할때 쓰인다.

### 화이트리스트

함수 처음에 화이트 리스트를 정해준다. 그 화이트 리스트는 대문자로 한다.
화이트 리스트에 validation 전의 값을 validation 이후 값으로 변경해 준다.
화이트 리스트는 검증이 끝난 믿을수 있는 값만 사용하는 것이다. 
그러면 아래에는 화이트 리스트, 즉 검증된 값들만 이용해서 코드를 짜면 된다.

### 밸리데이션과 알고리즘

validation과 알고리즘이 같이 결합되어 있다면 이해하기 어렵다.
서로 연결되어 있는 하나의 코드 중 일부가 validation, 다른 일부가 알고리즘 이라서
그 연결된 흐름속에서 개발자가 분리를 하며 해석해야 하기 때문이다.
validation과 알고리즘이 분리되어 있다면 각각이 변화할 때마다 각각의 코드에 대해서만 변경을 해주면 된다.
즉 이해하기도 쉽고 유지보수 및 변경에도 잘 대처할 수 있는 좋은 코드이다.
알고리즘은 화이트 리스트만 쓰기 때문에 안전하다.
쉴드 패턴을 써서 밸리데이션을 처리한 다음에 화이트 리스트로 알고리즘을 짠다.(명확!)

### 중복 제거

for 반복문이 반복된다. 다음시간에 다룰 것이다.



## todoList Code

```javascript
var tasks = [];

var STATE_P = '진행';
var STATE_C = '완료';

var addTask = (function() {
	var id = 0;

	return function(title) {
				tasks.push({
					title: title,
					id: id++,
					state: STATE_P
				});
				render();
			};
})();

var removeTask = function(id) {
	var isRemoved = false;

	for (var i = 0; i < tasks.length; i++) {
		if (tasks[i].id === id) {
			tasks.splice(i, 1);
			isRemoved = true;
			break;
		}
	}

	if (!isRemoved) {
		warning('removeTask: invalid id');
	}
	render();
};

var changeState = function(id, state) {
	var ID = false, STATE;
	for (var i = 0; i < tasks.length; i++) {
		if (tasks[i].id === id) {
			ID = id;
			break;
		}
	}
	if (ID === false) {
		warning('changeState: invalid id - ' + id);
		return;
	}

	if (state !== STATE_P && state !== STATE_C) {
		warning('changeState: invalid state - ' + state);
		return;
	} else {
		STATE = state;
	}

	for (var i = 0; i < tasks.length; i++) {
		if (tasks[i].id === ID) {
			tasks[i].state = STATE;
			break;
		}
	}

	render();
};

var warning = console.log;

var render = function() {
	console.log('진행');

	var task;

	for (var i = 0; i < tasks.length; i++) {
		task = tasks[i];

		if (task.state === '진행') {
			console.log(task.id + '. ' + task.title + '(' + task.state + ')' );
		}
	}

	console.log('완료');

	for (var i = 0; i < tasks.length; i++) {
		task = tasks[i];

		if (task.state === '완료') {
			console.log(task.id + '. ' + task.title + '(' + task.state + ')' );
		}
	}

	console.log('추가     : addTask(할일 내용)');
	console.log('삭제     : removeTask(아이디)');
	console.log('상태 변경 : changeState(아이디, 상태 - 완료 또는 진행)');
}

render();
```

