은닉의 다른 말은 자격, 권한 이다.

데이터 은닉의 가장 큰 것은 권한을 판별하는 것이다.
은닉을 할때 스코핑을 한다.

어떠한 행위는 특정 데이터에 기반하여 하는 구나.
renderHTML는 Li 변수의 데이터를 기반으로 해서 행위를 한다.

특정 데이터에 기반한 함수이다.
따라서 어떠한 행위는 특정 데이터 한정에서만 가능

함수의 종류
- 범용적인것. => 호출할때 마다 동일한 결과
- 특정 데이터, 또는 특정 상태에 바인딩 되어 있는 함수
어떤 상태가 준비되어야 의도한 결과가 나올수 있다.
상태에 따라서 다른 결과를 나올수 있는 함수가 있다.
컴퓨터는 항상 상태를 가진다. 
명령을 실행할 때마다 시간이 흐른다.
컴퓨터에서의 시간
- 컴퓨터의 시간은 변수 상태에 흐름에 따라서 흐르는 것이다.
- 변수 상태 변화의 변화가 컴퓨터에게는 시간인 것이다.

어떤 함수에는 인자, 지역 변수에만 의존하기때문에 컴퓨터 상태과 별개로 동일 결과가 나타낸다.
다른 함수에는 그 컴퓨터의 상태에 따라서 다른 결과를 보여주는 함수가 있다.

```javascript

// 상태와 별개로 동일한 작동
var a = function(v) {return v;}

// 바깥 k의 값을 참조해서 작동하는 함수.
var k = 3;
var b = function() {return k;}

```

순수함수 , 순수 수학적 함수
수학에서 함수의 정의 : 외부의 변수라는 것은 없다.

외부상태의 영향을 받아서 값이 달라진다.
이것은 b의 함수 결과를 예측하기 어렵다.

시간이 지나서 k의 값 변화애 따라서 b함수의 값이.. 달라진다. 과연 이 b함수를 신뢰할수 있을 것인가?
시간이 지나는 동안 k 의 값이 어떻게 변화하는지 추척할수 있어야 한다.
외부 상태에 의존하는 함수는 관리에 어렵다.
순수함수를 지향해야 한다.

외부 상태 의존 함수를 예측하기가 어렵다.

그래서 객체지향은 이런 것을 컨트롤하기 위해서 나왔다.

예측하기 어려우니까, 격리되어 있는 함수만 만드는 방법이 생겼다.
오직 함수에 인접해 있는 것에만 의존하게 만드는 것이다.

```javascript

var b = (function(){
    var k = 10;
    return function(){return k;};
})()

```

```javascript

var b = (function(){
    var k;
    return {
        print : function(){return k;},
        setV : function(v) {k = v;}
    }
})()

```
이렇게 하면 k는 바깥에서 건드릴수가 없으므로 이 함수의 작동을 예측할 수가 있다.
인자 받는게 없이 함수를 사용할수 있으며 반환값을 변경할수 있다.
상태를 가두고, 권한을 setV에게만 준 것이다.

객체는 바로 상태와 그 상태와 결합되어 있는 함수의 합니다.
객체만이 가지고 있는 고유한 상태와 그것에 의존성을 가지고 있는 함수의 결합이다.
객체 : 상태, 그 상태를 이용하는 메소드

객체가 객체 상태를 의존하는 메소드.
b 객체 : k 상태, b메소드인 setV, print

객체의 본질은 외부에 은닉되어 있는 상태와 캡슐화된 메소드를 노출하는 것.


자기가 알아야 할 것만 알고 그외에는 모르게 만들었다.

객체지향적 사고 : 상태를 은닉하고 그것을 쓰는 함수를 캡슐화하여 노출한다.

컴퓨터를 공부한다는 것은 모두 외운다는 것이다.
앞에있는 것을 다 외운 사람은 지금 공부하는 것을 그냥 익히면 된다.
하지만 그게 아닐 경우 이해도 안될 뿐더러 이전것 까지 전부 외워야 한다.

개발자는 함수를 구현하고 상태를 만드는 것이다.

객체는 정체성이 메소드로 나타난다. 
함수의 정체성은 시그니처( 함수의 이름, 인자 )로 나타낸다.
즉..  con과 html은 유사한 정체성을 가지는 것이다.
init과 render를 호출하는 정체성으로 보았을때 con과 html이 유사한 것이다.

객체가 일치할때 그것을 클래스라고 부른다.
클래스는 좁은 의미이며 객체간의 정체성의 일치도를 보면.. 분해해서 생각해볼수 있다.

이렇게 일부하는 부분이 존재할때 인터페이스를 말할수 있다.

즉 init와 render 라는 인터페이스가 존재하게 되면 다른 플랫폼에 나타나는 것들에 대해서도
그 인터페이스를 지켜야 만들수 있을 것이다.

인터페이스가 왜 존재하야 할까? 바로 init와 render 함수에 있다.
init와 render는 각각 어떻게 init메소드와 render 메소드가 있을것으로 알았을까?
자신들에게 오는 각 객체들은 그 인터페이스를 동일하게 지키고 있을 것이야.
인터페이스 : 객체를 사용하는 사람들과의 약속

인터페이스 : 이 객체를 사용하려는 사람들이 이 객체와의 약속을 하는 것이다.
나사 홈에 맞는 드라이버, 즉 나사홈이 인터페이스인 것이다.
사용하는 쪽의 사정으로 인터페이스가 만들어지는 것이다.

객체의 정체성은 사용자측에 의해서 정의가 되며 인터페이스가 정해지는 것이다.

인터페이스 : 사용자와 객체간의 약속.
두 대상간의 약속 : 프로토콜 (컴퓨터 사이언스)
브라우저와 웹서버간의 약속 : http 프로토콜

사용자측에서 요구하는 명세 : 인터페이스
html, con과 같은 객체를 만들때에 init와 render을 만드는 명세를 만들어야 해.
호스트 코드 : 자신을 가져다 쓰는 것들의 코드. (상대적이다.) 
todoList에서는 서비스코드이다.

tasks는 init이나 render에 들어가서는 안된다.
이 아이는 원래 

통제할수 잇는 상황. 지역 변수..

그런데 tasks는 외부 변수인데, 그것이 여기에 들어와서는 안된다.
객체 이름을 가진 todo 함수중의 하나일뿐이다. 왜냐하면 독립적이지 않기 때문이다.
외부에서 받아온 지역변수 로 바꿔주면 도니다.

tasks를 인자로 받아야 하는 것이지 tasks에 대해서 관여하거나 ㅏㅇㄶ도록 해야한다.

Object.assign() => 복사본을 만들어준다.

객체는 자기 자신으로만 가지고는 일을 다 하지 못할수 있다. 따라서 인자를 통해 값을 받아들이는 것이다.

이걸 봤더니 호스트 코드의 사정만 가지고 인터페이스가 만들어지는게 아니라,
사용되어지는 코드측의 사정에도 영향을 받는다.

즉 각 코드간의상호작용에 따라 인터페이스 약속이 만들어지는 것이다.

todoApp 으로부터 html과 con을 완전히 분리할수 있게 되었다.
스코프에 영향을 받지 않으므로 속할필요가 없다.
이 html, con객체는 내부 상태와 인자 만 받으면 작동할수 있게 되었다.
todoApp - tasks의 기능을 처리하는 모델을 처리한다.
표현을 외부 객체를 통해서 한다.
표현을 해야하는 객체가 달라진다고 todoApp의 코드가 사라지도록 하는 것은 아니다.

그자리에는 setRenderer가 자리한다.


==============> 인터페이스, 그리고 각 렌더를 todoApp에서 의존성을 없앰으로서 분리를 시켜준다.
==============> 상태를 만들어주고, 메소드를 만들고 외부 의존성을 없애면서 객체를 온전히 생성한다.
==============> 객체에 대한 이해
==============> 프로토콜.... 약타입 체크.
==============> 리팩토링의 과정 : 내부의 것들을 수정. 외부의 모습, 구조는 같다.

객체는 완전히 독립적, 독립적 역할을 수행한다. 객체는 외부 변수에 독립적이다.
객체는 내부 변수인 상태, 메소드에 의존적이다.






렌더러를 세팅해주는 순간, init를 시켜주는 것이다.

절대 mdn 뿐만 아니라 대부분의 문서는 최신판을 보고 싶다면 영문 문서를 보아라!!!

data - ... 라는 html5의 그것.
크롤져 중첩?

뷰코드는 왜 중복이 허용, 허용 안되는지를 뷰의 관점에서 봐야 한다.
뷰의 대한 처리일 뿐이지, 변할 가능성이 높기 때문이다.
로직에 대해서는 중복 제거가 될수 있어도, 뷰는
나중에 변경에 대한 염두를 위해서 중복이라고 볼수 없다.
뷰는 가장 많이 바뀌기 때문에 중복제거라고 할수느 없다.

