<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <section id="todo">

    </section>
</body>
<script>
    // 할일 을 task
    const Task = class {
        constructor() {
            this._list = [];
        }
        add(task) { this._list.push(task);}
        remove(task) {
            const l = this._list;
            if(l.includes(task)) l.splice(l.indexOf(task), 1);  
        }
        getResult(sort, state) {
            const l = this._list;
            const s = TaskSort[sort]; 
            let result = [];

            result = state
                    ? [l.filter(v => !v.isComplete()), l.filter(v => v.isComplete())].reduce( (p, c) => p.concat(c.sort(s)), [])
                    : [...l].sort(s);
               
            return {
                item: this._getResult(), 
                children: result
            }

        }
        _getResult() {throw "must be overrided";}
    }
    // task class
    const TaskItem = class extends Task {
        static title(a, b) {
            return a.sortTitle(b);
        }
        static date(a,b) {
            return a.sortDate(b);
        }
        static register(a, b) {
            return null;
        }

        constructor(title) {
            super();
            this._title = title;
            this._date = Date.now();
            this._isComplete = false;    
        }
        isComplete() {
            return this._isComplete;
        }
        toggle() {
            this._isComplete = !this._isComplete;
        }
        sortTitle(task) {
            return this._title > task.title;
        }
        sortDate(task) {
            return this._date > task._date;
        }
        _getResult(sort, state) {
            return this;
        }
        // sortRegister(task) {    // 얘는 원래는 taskList, task는 권한이 없다. 몰라야 하므로.
        //     return true;
        // }

    };

    const TaskSort = {  // 이행위를 할 것만 중계하고 있다.
        title: (taskA, taskB) => taskA.sortTitle(taskB),    // 어떻게 일어나는지 몰라도 되. 내부코드는 task에게 묻자.
        date: (taskA, taskB) => taskA.sortDate(taskB),
        register: null,
    }

    // 사용하는 쪽부터 만들어야 하므로 TaskList부터 구현
    const TaskList = class extends Task {
        constructor(title) {
            super();
            this._title = title;
        }
        add(title) {
            super.add(new TaskItem(title));
        }
        remove(task) {
            super.remove(task);
        }

        byRegister(state = false) {
            // sorting field
            return this.getResult(TaskItem.register, state);
        }
        byTitle(state = false) {

            return this.getResult(TaskItem.title, state);
        }
        byDate(state = false) {
            return this.getResult(TaskItem.date, state);
        }
        _getResult() {
            return this._title;
        }
    }

    const Dr = class {
        static el(type, ...attr) {
            const el = document.createElement(type);
            for(let i = 0; i < attr.length;) {
                const k = attr[i++], v = attr[i++];

                if(typeof el[k] === 'function') el[k].apply(el, Array.isArray(v) ? v : [v])
                else if(k[0] === '@') el.style[k.substr(1)] = v;
                else el[k] = v;
                
            }
            return el;
        }

        constructor(taskList, parent) {
            this._list = taskList;
            this._parent = parent;
            this._sort = 'register';
        }
        sort(s) {
            this._sort = s;
            this.render();
        }
        render() {
            const parent = document.querySelector(this._parent);
            const data = this._list.getResult(this._sort, true);

            parent.innerHTML = '';  // 뭘 만들든 쓰기부터~!
            [
                Dr.el('h2', 'innerHTML', data.item),
                'register,title,date'.split(',').reduce((p,c) => {
                    p.appendChild(Dr.el(
                        'button','innerHTML', c,
                        'addEventListener', ['click', e => this.sort(c)]
                    ));
                    return p;
                }, Dr.el('nav')),
                Dr.el('section', 
                    'appendChild', Dr.el('input', 'type', 'text'),
                    'appendChild', Dr.el('button', 'innerHTML', 'add task'),
                    'addEventListener', ['click', e => this.add(e.target.previousSibling.value)]
                ),
                [].reduce((p,c) => (p.appendChild(c), p), Dr.el('section'))
            ].reduce((p,c) => (p.appendChild(c), p), parent);

        }
    }

    const todo = new Dr(new TaskList('list1'), "#todo");
    todo.render();


    // const list = new TaskList();
    // list.add("task1");
    // list.add("task3");
    // list.add("task2");

    // const list1 = list.byRegister();
    // list1.children[0].add(new TaskItem('sub1') );

    // console.log(list.byRegister());
    // console.log(list.byTitle());

</script>

</html>