# 3장 사상 - 프로그래밍의 이데올로기

## 3.1 프로그래밍 이론

### what : 프로그래밍을 이끄는 가치관  

프로그래밍의 최대의 관심사는 **확장 방법이 다양하고 필요한 요소만 있으며 읽고 이해하기 쉬운 코드**를 만드는 것이다. 이러한 코드를 실현하기 위한 프로그래밍 이론에는 3가지 가치인 **의사소통, 단순함, 유연성** 이 있다.

### why : 가치관을 기술의 선택 기준으로  

프로그래밍에서 문제 해결방법은 상황에 따라 달라진다. 프로그래밍 이론에서 제시되는 가치는 상황에 따라 어떠한 개별 기술을 선택할지에 대한 적절한 이유를 제공해 준다.

### how : 가치관을 원칙을 통해 코드에 적용  

프로그래밍 이론에서 제시되는 가치를 판단 기준으로 이용하자. 하지만 가치는 추상적이기 때문에 가치와 프로그래밍 사이의 중간 역할인 6가지 원칙이 존재한다. **결과의 국소화, 반복의 최소화, 로직과 데이터의 일체화, 대칭성, 선언형의 표현, 변경 빈도**

### 관련1 : 포스 (forth)  

어떤 기술을 적용할 때 고려해야 할 관점을 포스라고 한다. 해결책이 충족해야할 요구사항, 과제에 포함된 제약, 해결책에 요구되는 특성 등이 존재한다. 프로그래밍 이론은 코드 구현 방법을 선택할 때 포스로 사용된다. 

### 관련2 : 지금 쓰는 도구는 왜 이런 형태가 되었을까?  

목적을 모르면 지식이 머리를 지나치기만 할뿐 진정으로 기술을 습득할 수 없다. 기술을 배울 때는 동작 원리나 발전 과정, 설계 배경 등도 동시에 알아야 나중에 기술을 사용할 때 목적을 달성하기 쉬워진다. 제대로 이유를 설명할 수 있을 때까지 끈길기게 이해하고 나서 코드를 확정하도록 하자.

<br/>

## 3.2 의사소통 - 3가지 가치 1

### what : 코드는 의사소통의 장이다.  

코드는 문서이며 문서는 의사소통 수단이다. 프로그래밍에서 원활한 의사소통은 코드를 읽은 사람이 코드를 이해하고 수정하며 사용할 수 있다는 의미이다.

### why : 원활한 개발은 원활한 의사소통으로부터  

소프트웨어 개발 비용의 대부분은 최초 개발된 이후에 발생된다. 즉 유지보수에 드는 비용이며 이것을 절약하려면 코드는 읽기 쉽게 만들어져야 한다. 코드를 통해 개발자끼리 의사소통을 원활히 하기 위함이다. 코드는 작성시간보다 읽는 시간이 압도적으로 많다. 

### how : 코드를 읽는 쪽의 관점을 전환하라  

코드를 통해 원활한 의사소통을 하려면 다른 사람의 입장에서 생각하며 프로그래밍을 해야한다. 프로그래밍을 할 때 컴퓨터가 아닌 읽는 사람을 생각한다는 발상의 전환을 하고 남에게 보여주는 문장이라는 의사소통으로서의 가치를 두자.

<br/>

## 3.3 단순함 - 3가지 가치 2

### what : 코드의 복잡성은 제거한다.  

코드가 단순하다는 것은 코드에 불필요한 복잡성이 제거된 상태를 가리킨다. 이 복잡성은 어떻게든 동작하게 만들려고 격투를 벌인 흔적에 의한 복잡성이다.

### why : 코드의 복잡성은 화근이 된다.  

불필요한 복잡성에 가치는 전혀 없고 장래의 변경을 어렵게 만들고 소프트웨어의 가치를 손상시킨다. 그러니 제거하여 코드를 단순하게 하자.

### how : 코드의 옥석을 구분한다.  

단순한 상태를 유지하려면 옥( 본질적인 부분 )을 잘 띄게 만들고 석( 불필요한 부분 )이 섞이지 않도록 설계한다. 단순함은 의사소통과 서로 좋은 영향을 주고 받는다. 타인의 관점을 살펴보면 단순화 작업이 순조롭게 진행된다. 다만 너무 단순하게 만들어서 정보가 적어져 이해하기 어려운 경우에는 코드가 장황해지더라도 의사소통을 우선시한다.

<br/>

## 3.4 유연성 - 3가지 가치 3

### what : 코드의 변경이 용이하다.  

1 ) 기존 코드에 새로 추가를 해도 거부반응이 없다. 2) 자신이 망가지지 않도록 완충을 해서 받아들인다. 

### why : 코드는 반드시 변경된다.  

코드는 반드시 변경되기 때문에 변경이 쉬운 유연한 코드는 필수사항이다. 그러면 차후 개선 작업이 원활하다.

### how : 코드의 확장성을 높인다.  

코드가 유연성을 갖게 하려면 확장하기 쉬우면서도 확장이 다른 부분에 파급되지 않도록 설계해야한다. 하지만 유연성을 이유로 복잡성은 허용될 수 없다. 복잡성을 갖지 않고 유연성을 갖게 하려면 즉시 효과가 나타나는 코드만 작성하자. 경직된 설계의 하향식보다 단순함에서 시작해 단위 테스트를 통해 상향식이 효과적으로 유연성을 얻는다. 

<br/>

## 3.5 결과의 국소화 - 6원칙 1

### what : 변경의 영향을 억제하다.  

결과란 '변경이 미치는 영향'을 뜻한다. 즉 결과의 국소화는 **변경이 미치는 영향이 국소에 머무르도록 코드를 구성한다**는 의미이다. 모듈화 등 여러 기술이 생겨날 정도로 중요도가 높은 원칙이다.

### why : 수정과 확인이 쉽도록  

결과가 국소화되어 있지 않으면 영향이 미치는 범위를 찾는 작업부터 해야하지만, 결과가 국소화되어 있으면 코드를 읽는 범위와 수정에 따른 영향 범위가 모두 한정된다. 의사소통이 원활해지는 효과도 있으며 코드 전체가 아닌 단계적으로 필요한 부분만을 이해할 수 있다.

### how : 관계가 밀접한 코드를 한데 모은다.  

관계성이 높은 코드는 모아서 모듈화하고, 낮은 코드는 서로 종속되지 않도록 코드를 작성한다. 서로 자주 호출되는 모듈은 함께있어야 할 요소가 분산되어 있을 가능성이 크기 때문에 적절한 모듈쪽으로 기능을 모으든지, 통합하든지, 다른 관점의 모듈을 별도 작성하여 기능을 추출해서 동일 기능의 밀집성을 높인다.

<br/>

## 3.6 반복의 최소화 - 6원칙 2

### what : 중복을 제거한다.  

반복이란 **중복**을 뜻한다. 즉 **반복의 최소화**란 **중복을 최대한 제거한다**는 것이다. 

### why : 수정의 영향을 국소화한다.  

반복 코드는 '결과의 국소화' 원칙을 침해하고 변경 비용을 증대시킨다. 복사된 반복 코드를 수정하는 것은 주변 부분을 완전히 이해한 다음에 판단하지 않으면 안되기 때문에 비용이 많이 드는 작업이 된다. 

### how : 코드를 분할해서 관리  

코드를 다수의 작은 부분으로 분할하자. 큰 코드 덩어리를 잘개 쪼개면 공통 분모를 쉽게 도출할 수 있다. 그리고 코드 안에서 같은곳, 비슷한 곳, 다른 곳인지를 알려주면 가독성이 높아지고 수정비용이 절약된다. 

<br/>

## 3.7 로직과 데이터의 일체화 - 6원칙 3

### what : 데이터와 조작은 가까이에  

로직과 데이터의 일체화란 **로직**과 **해당 로직이 조작하는 데이터**를 같은 함수나 같은 모듈등과 같이 가까이에 배치시키는 것을 의미한다.

### why : 데이터와 조작은 수정 시점이 같다.  

코드를 수정할 때 로직과 로직의 조작 데이터는 보통 같은 시점에 변경된다. 따라서 로직과 데이ㅓ가 코드상 같은 곳에 있다면 코드를 읽는 양이 줄고 변경도 영향을 미치지 않아서 결과적으로 변경 비용이 절약된다.

### how : 데이터와 조작을 같은 장소에  

어떤 로직과 데이커를 가까이 두는 것이 좋을까? 최상의 답은 없다. 임시로 배치했다가 나중에 타당한 곳으로 옮기는 것이 효율적이다. 관계성은 코드를 작성하고 작동해봐야 알 수 있기 때문이다. 

<br/>

## 3.8 대칭성 - 6원칙 4

### what : 코드에 일관성을 갖게 한다.  

프로그래밍에서의 대칭성이란 똑같은 생각으로 작성한 코드라면 어느 부분에서든 똑같이 표현된다는 점을 의미한다. 즉 그룹 안에서의 수준 맞추기로 동질의 것은 같은 수준으로 표현한다는 것이다.

### why : 다른 부분도 유추할 수 있다.  

코드에서 대칭성을 특정하고 명확하게 표현할 수 있다면 코드는 매우 읽기 쉬워진다. 코드를 일부만 읽어도 그 외의 부분을 쉽게 유추할 수 있기 때문이다. 대칭성의 추구는 본질상 중복을 제거하기 위한 준비작업이기도 하다. 비슷한 부분을 쉽게 파악하며 완전히 똑같아진 부분을 묶어서 중복을 제거할 수 잇다.

### how : 같은 것은 같은 표현으로  

코드를 작성할 때 같은 종류는 똑같이 표현하자.  

- 추가 메서드가 있다면 대응하는 삭제 메서드를 작성한다.
- 특정 그룹에 있는 함수는 같은 파라미터를 갖도록 한다.
- 특정 모듈 안의 데이터는 전부 생존 기간이 같게끔한다.
- 특정 함수 안에서 호출하는 함수의 추상도는 같은 수준으로 한다.

<br/>

## 3.9 선언형의 표현 - 6원칙 5

### what : 선언형으로 프로그래밍   

코드의 의도를 전하고자 할 때 가능한 명령형보다는 선언형으로 표현한다. 선언형 프로그래밍은 문제의 성질이나 충족해야 할 제약을 기술한다.

### why : 흐름이 없어야 읽기 쉽다.  

선언형 코드는 순서나 조건 분기가 없다. 순수한 사실만이 선언적으로 작성되어 있어 가독성이 좋다. 반면에 명령형 코드는 머릿속에 상태, 제약, 데이터 흐름을 그려야 이해할수 있기에 흐름을 쫓아가야 한다.

### how : 선언형을 도입한다.

선언형 코드를 도입해 단순하게 의도를 표현한다. 선언형 프로그래밍 언어에는 함수형 언어, HTML, CSS, SQL이 있다. 명령형인 언어를 사용하더라도 선언형 표현을 부분적으로 도입한다. 대표적으로 어노테이션, DSL이 있다.

<br/>

## 3.10 변경 빈도 - 6원칙 6

### what : 변경 이유로 그룹핑  

변경 빈도란 코드를 수정하는 시점이 같다는 의미이다. 즉 변경 이유가 같다는 것이다. 같은 시점에 변경되는 요소는 같은 곳에 두고 다른 시점인 요소는 분리한다. 

### why : 변경 범위가 좁아진다.  

모듈처럼 어떤 형태의 단위로 그룹핑된 코드에서 변경 이유를 여러 개 가진 코드는 깨지기 쉬운 코드다. 모듈 안에 변경과 관련없는 부분도 같이 영향을 받기 때문이다. 변경이 찾아지고 역할이 커지면 코드도 방해대져서 더욱 약하고 위험한 코드가 된다.  
반대로 변경 이유가 하나라는 것은 관련성이 높은 코드가 집합해 있다는 의미이다. 높은 응집성을 충족하고 있는 견고한 코드이다. 변경 대상 범위가 좁고 영향 범위가 한정되므로 수정하기 쉬운 코드라고 할 수 잇다.

### how : 변경 이유로 소속을 정한다.  

변경하는 시점이 같은 요소는 같은 곳에, 다른 요소는 다른 곳에 두도록 한다. 이는 로직과 데이터에도 적용된다.

### 관련 : 단일 책임 원칙  

단일 책임 원칙 (SRP) 은 모듈을 변경하는 이유가 여러 개 존재해서는 안된다는 원칙이다. 변경 이유가 여러 개 있다는 말은 역할도 여러 개 있다는 것이며 깨지기 쉬운 모듈이다. 한개 모듈은 하나의 책임, 어떤 역할에 대해 순수한 것이 바람직한 상태인 것이다. 그런 상태로 만들려면 변경 이유나 빈도가 같은 코드를 한데 모으면 자연스럽게 단일 책임 원칙을 충족하는 모듈이 완성된다. 

<br/>

## 3.11 아키텍처 기본 기법

### what : 좋은 코드의 기초 원리   

아키텍처 기본 기법이란 소프트웨어 아키텍처를 적절하게 구축하는데 필요한 기초 원리이다. 기본 기법은 모듈의 설계방침으로 제시되며 10가지 기법인 [추상], [캡슐화], [정보 은닉], [패키지화], [관심의 분리], [충족성, 완전성, 프리미티브성(원시성, 순수성)], [정책과 구현의 분리], [인터페이스와 구현의 분리], [참조의 단일성], [분할 정복] 이 있다. 

### why : 좋은 코드에는 품새가 있다.   

어떤 문제에 대해 뛰어난 해결책이 있으면 여러 차례 재사용했는데 그것이 기본 기법이다. 

### how :  품새(패턴)을 익힌다.   

기본 기법을 코드에 적용하자. 기본 기법은 본질적인 해법이라 개발 방법론이나 프로그래밍 언어와 관계없이 적용할 수 있다.

<br/>

## 3.12 추상(abstraction) - 아키텍처 기본 기법 1

### what : 개념적인 선 긋기   

추상이란 개념적으로 명확한 선 긋기를 수행하는 것이다. 선긋기에 따라 모듈이 명확히 구별된다. 추상은 **사상**과 **일반화** 라는 2가지 관점에서 정리된다.

- 사상 : 복잡한 대상의 몇 가지 성질을 버리고 특정한 성질에 주목하는 것이다.
- 일반화 : 구체적인 대상으로부터 공통 성질을 추출해서 더욱 범용적인 개념으로 정식화한다.

### why : 복잡함에 대한 대항 수단   

추상은 인간이 복잡한 문제에 집중할 때 사용하는 기초적인 원리다.

- 사상 : 부차적인 부분을 제거해 본질을 드러낸다. 복잡도가 줄어들며 사용하기 쉽고 응용가능하다.
- 일반화 : 공통된 성질에 따라 그룹핑해서 같다고 간주한다. 그렇게 하면 한 현상에서 학습한 것을 다른 곳에 적용가능하다.

### how : 사상과 일반화를 구사   

추상화는 뛰어난 아키텍처를 구축하기 위해 필요한 프로그래머의 기초 기술이다. 추상을 통해 많은 대상에 일룔적인 공식을 적용할 수 있고 압도적으로 효율적인 생각을 할 수 있다.

- 사상 : 복잡한 대상에 집중할 때 사용한다. 본질을 파악하되, 지금의 문제에 관해 현재의 측면에서 본질을 파악한다.
- 일반화 : 여러 개의 대상에 집중할 때 사용한다. 공통된 성질들을 찾고 조합하여 범용적인 개념을 구성한다. 

<br/>

## 3.13 캡슐화 - 아키텍처 기본 기법 2

### what : 데이터와 로직을 그룹핑   

관계성이 강한 데이터와 로직을 모듈이라는 껍질로 감싸는 것을 캡슐화라고 한다.

### why : 추상 개념이 섞이지 않는다.   

그룹핑을 통해 관련 있는 요소끼리만 특정 추상 개념을 담당하도록 모듈로 모은다. 그러면 다음과 같은 장점이 생긴다.

- 코드가 읽기 쉬워지고 변경시의 여파가 모듈 안으로 한정된다.
- 영향도가 명확하니 코드 변경이 쉬워지고 독립된 부분이라 재사용성이 높아진다.
- 작은 단위로 분할되어 복잡한 문제에 대처가능하다.

### how : 같은 부류의 요소를 캡슐에 담는다.   



## 3.14

### what : 

### why : 

### how : 


## 3. 15

### what : 

### why : 

### how : 


## 3.16

### what : 

### why : 

### how : 


## 3.17

### what : 

### why : 

### how : 


## 3.18

### what : 

### why : 

### how : 


## 3.19

### what : 

### why : 

### how : 


## 3.20

### what : 

### why : 

### how : 


## 3.21

### what : 

### why : 

### how : 



