# 3장 사상 - 프로그래밍의 이데올로기

## 3.1 프로그래밍 이론

### What : 프로그래밍을 이끄는 가치관  

프로그래밍의 최대의 관심사는 **확장 방법이 다양하고 필요한 요소만 있으며 읽고 이해하기 쉬운 코드**를 만드는 것이다. 이러한 코드를 실현하기 위한 프로그래밍 이론에는 3가지 가치인 **의사소통, 단순함, 유연성** 이 있다.

### Why : 가치관을 기술의 선택 기준으로  

프로그래밍에서 문제 해결방법은 상황에 따라 달라진다. 프로그래밍 이론에서 제시되는 가치는 상황에 따라 어떠한 개별 기술을 선택할지에 대한 적절한 이유를 제공해 준다.

### How : 가치관을 원칙을 통해 코드에 적용  

프로그래밍 이론에서 제시되는 가치를 판단 기준으로 이용하자. 하지만 가치는 추상적이기 때문에 가치와 프로그래밍 사이의 중간 역할인 6가지 원칙이 존재한다. **결과의 국소화, 반복의 최소화, 로직과 데이터의 일체화, 대칭성, 선언형의 표현, 변경 빈도**

### Rel1 : 포스 (forth)  

**어떤 기술을 적용할 때 고려해야 할 관점**을 포스라고 한다. 해결책이 충족해야할 요구사항, 과제에 포함된 제약, 해결책에 요구되는 특성 등이 존재한다. 프로그래밍 이론은 코드 구현 방법을 선택할 때 포스로 사용된다. 

### Rel2 : 지금 쓰는 도구는 왜 이런 형태가 되었을까?  

목적을 모르면 지식이 머리를 지나치기만 할뿐 진정으로 기술을 습득할 수 없다. 기술을 배울 때는 동작 원리나 발전 과정, 설계 배경 등도 동시에 알아야 나중에 기술을 사용할 때 목적을 달성하기 쉬워진다. 제대로 이유를 설명할 수 있을 때까지 끈길기게 이해하고 나서 코드를 확정하도록 하자.

<br/>

## 3.2 의사소통 - 3가지 가치 (1)

### What : 코드는 의사소통의 장이다.  

**코드는 문서이며 문서는 의사소통 수단**이다. 프로그래밍에서 원활한 의사소통은 코드를 읽은 사람이 코드를 이해하고 수정하며 사용할 수 있다는 의미이다.

### Why : 원활한 개발은 원활한 의사소통으로부터  

소프트웨어 개발 비용의 대부분은 최초 개발된 이후에 발생된다. 즉 유지보수에 드는 비용이며 이것을 절약하려면 코드는 읽기 쉽게 만들어져야 한다. 코드를 통해 개발자끼리 의사소통을 원활히 하기 위함이다. 코드는 작성시간보다 읽는 시간이 압도적으로 많다. 

### How : 코드를 읽는 쪽의 관점으로 전환하라  

코드를 통해 원활한 의사소통을 하려면 **다른 사람의 입장에서 생각하며 프로그래밍**을 해야한다. 프로그래밍을 할 때 컴퓨터가 아닌 읽는 사람을 생각한다는 발상의 전환을 하고 남에게 보여주는 문장이라는 의사소통으로서의 가치를 두자.

<br/>

## 3.3 단순함 - 3가지 가치 (2)

### What : 코드의 복잡성은 제거한다.  

**코드가 단순하다는 것은 코드에 불필요한 복잡성이 제거된 상태**를 가리킨다. 이 복잡성은 어떻게든 동작하게 만들려고 격투를 벌인 흔적에 의한 복잡성이다.

### Why : 코드의 복잡성은 화근이 된다.  

불필요한 복잡성에 가치는 전혀 없고 장래의 **변경을 어렵게 만들고 소프트웨어의 가치를 손상**시킨다. 

### How : 코드의 옥석을 구분한다.  

단순한 상태를 유지하려면 옥( 본질적인 부분 )을 잘 띄게 만들고 석( 불필요한 부분 )이 섞이지 않도록 설계한다. 단순함은 의사소통과 서로 좋은 영향을 주고 받는다. 타인의 관점을 살펴보면 단순화 작업이 순조롭게 진행된다. 다만 너무 단순하게 만들어서 정보가 적어져 이해하기 어려운 경우에는 코드가 장황해지더라도 의사소통을 우선시한다.

<br/>

## 3.4 유연성 - 3가지 가치 (3)

### What : 코드의 변경이 용이하다.  

1) 기존 코드에 새로 **추가를 해도 거부반응이 없다.** 2) 자신이 망가지지 않도록 **완충을 해서 받아들인다.** 

### Why : 코드는 반드시 변경된다.  

**코드는 반드시 변경**되기 때문에 변경이 쉬운 유연한 코드는 필수사항이다. 그러면 차후 개선 작업이 원활하다.

### How : 코드의 확장성을 높인다.  

**코드가 유연성을 갖게 하려면 확장하기 쉬우면서도 확장이 다른 부분에 파급되지 않도록 설계해야한다.** 하지만 유연성을 이유로 복잡성은 허용될 수 없다. 복잡성을 갖지 않고 유연성을 갖게 하려면 **즉시 효과가 나타나는 코드만 작성**하자. 경직된 설계의 하향식보다는 단순함에서 시작해서 단위 테스트를 통해 이루어지는 상향식이 효과적으로 유연성을 얻는다. 

<br/>

## 3.5 결과의 국소화 - 6원칙 (1)

### What : 변경의 영향을 억제하다.  

**결과란 '변경이 미치는 영향'**을 뜻한다. 즉 결과의 국소화는 **변경이 미치는 영향이 국소에 머무르도록 코드를 구성한다**는 의미이다. 모듈화 등 여러 기술이 생겨날 정도로 중요도가 높은 원칙이다.

### Why : 수정과 확인이 쉽도록  

결과가 국소화되어 있지 않으면 영향이 미치는 범위를 찾는 작업부터 해야하지만, **결과가 국소화되어 있으면 코드를 읽는 범위와 수정에 따른 영향 범위가 모두 한정된다.** 의사소통이 원활해지는 효과도 있으며 코드 전체가 아닌 단계적으로 필요한 부분만을 이해할 수 있다.

### How : 관계가 밀접한 코드를 한데 모은다.  

**관계성이 높은 코드는 모아서 모듈화하고, 낮은 코드는 서로 종속되지 않도록 코드를 작성한다.** 서로 자주 호출되는 모듈은 함께있어야 할 요소가 분산되어 있을 가능성이 크기 때문에 적절한 모듈쪽으로 기능을 모으든지, 통합하든지, 다른 관점의 모듈을 별도 작성하여 기능을 추출해서 동일 기능의 밀집성을 높인다.

<br/>

## 3.6 반복의 최소화 - 6원칙 (2)

### What : 중복을 제거한다.  

반복이란 **중복**을 뜻한다. 즉 **반복의 최소화**란 **중복을 최대한 제거한다**는 것이다. 

### Why : 수정의 영향을 국소화한다.  

**반복 코드는 '결과의 국소화' 원칙을 침해하고 변경 비용을 증대시킨다.** 복사된 반복 코드를 수정하는 것은 주변 부분을 완전히 이해한 다음에 판단하지 않으면 안되기 때문에 비용이 많이 드는 작업이 된다. 

### How : 코드를 분할해서 관리  

**코드를 다수의 작은 부분으로 분할하자.** 큰 코드 덩어리를 잘개 쪼개면 공통 분모를 쉽게 도출할 수 있다. 그리고 코드 안에서 같은곳, 비슷한 곳, 다른 곳인지를 알려주면 가독성이 높아지고 수정비용이 절약된다. 

<br/>

## 3.7 로직과 데이터의 일체화 - 6원칙 (3)

### What : 데이터와 조작은 가까이에  

로직과 데이터의 일체화란 **로직**과 **해당 로직이 조작하는 데이터**를 같은 함수나 같은 모듈등과 같이 가까이에 배치시키는 것을 의미한다.

### Why : 데이터와 조작은 수정 시점이 같다.  

코드를 수정할 때 로직과 로직의 조작 데이터는 보통 같은 시점에 변경된다. 따라서 로직과 데이터가 코드상 같은 곳에 있다면 코드를 읽는 양이 줄고 변경도 영향을 미치지 않아서 결과적으로 변경 비용이 절약된다.

### How : 데이터와 조작을 같은 장소에  

어떤 로직과 데이터를 가까이 두는 것이 좋을까? 최상의 답은 없다. 임시로 배치했다가 나중에 타당한 곳으로 옮기는 것이 효율적이다. 관계성은 코드를 작성하고 작동해봐야 알 수 있기 때문이다. 

<br/>

## 3.8 대칭성 - 6원칙 (4)

### What : 코드에 일관성을 갖게 한다.  

프로그래밍에서의 대칭성이란 똑같은 생각으로 작성한 코드라면 어느 부분에서든 똑같이 표현된다는 점을 의미한다. 즉 그룹 안에서의 수준 맞추기로 동질의 것은 같은 수준으로 표현한다는 것이다.

### Why : 다른 부분도 유추할 수 있다.  

코드에서 대칭성을 특정하고 명확하게 표현할 수 있다면 코드는 매우 읽기 쉬워진다. 코드를 일부만 읽어도 그 외의 부분을 쉽게 유추할 수 있기 때문이다. 대칭성의 추구는 본질상 중복을 제거하기 위한 준비작업이기도 하다. 비슷한 부분을 쉽게 파악하며 완전히 똑같아진 부분을 묶어서 중복을 제거할 수 잇다.

### How : 같은 것은 같은 표현으로  

코드를 작성할 때 같은 종류는 똑같이 표현하자.  

- 추가 메서드가 있다면 대응하는 삭제 메서드를 작성한다.
- 특정 그룹에 있는 함수는 같은 파라미터를 갖도록 한다.
- 특정 모듈 안의 데이터는 전부 생존 기간이 같게끔한다.
- 특정 함수 안에서 호출하는 함수의 추상도는 같은 수준으로 한다.

<br/>

## 3.9 선언형의 표현 - 6원칙 (5)

### What : 선언형으로 프로그래밍   

코드의 의도를 전하고자 할 때 가능한 명령형보다는 선언형으로 표현한다. 선언형 프로그래밍은 문제의 성질이나 충족해야 할 제약을 기술한다.

### Why : 흐름이 없어야 읽기 쉽다.  

선언형 코드는 순서나 조건 분기가 없다. 순수한 사실만이 선언적으로 작성되어 있어 가독성이 좋다. 반면에 명령형 코드는 머릿속에 상태, 제약, 데이터 흐름을 그려야 이해할수 있기에 흐름을 쫓아가야 한다.

### How : 선언형을 도입한다.

선언형 코드를 도입해 단순하게 의도를 표현한다. 선언형 프로그래밍 언어에는 함수형 언어, HTML, CSS, SQL이 있다. 명령형인 언어를 사용하더라도 선언형 표현을 부분적으로 도입한다. 대표적으로 어노테이션, DSL이 있다.

<br/>

## 3.10 변경 빈도 - 6원칙 (6)

### What : 변경 이유로 그룹핑  

변경 빈도란 코드를 수정하는 시점이 같다는 의미이다. 즉 변경 이유가 같다는 것이다. 같은 시점에 변경되는 요소는 같은 곳에 두고 다른 시점인 요소는 분리한다. 

### Why : 변경 범위가 좁아진다.  

모듈처럼 어떤 형태의 단위로 그룹핑된 코드에서 변경 이유를 여러 개 가진 코드는 깨지기 쉬운 코드다. 모듈 안에 변경과 관련없는 부분도 같이 영향을 받기 때문이다. 변경이 찾아지고 역할이 커지면 코드도 방해대져서 더욱 약하고 위험한 코드가 된다.  
반대로 변경 이유가 하나라는 것은 관련성이 높은 코드가 집합해 있다는 의미이다. 높은 응집성을 충족하고 있는 견고한 코드이다. 변경 대상 범위가 좁고 영향 범위가 한정되므로 수정하기 쉬운 코드라고 할 수 잇다.

### How : 변경 이유로 소속을 정한다.  

변경하는 시점이 같은 요소는 같은 곳에, 다른 요소는 다른 곳에 두도록 한다. 이는 로직과 데이터에도 적용된다.

### Rel : 단일 책임 원칙  

단일 책임 원칙 (SRP) 은 모듈을 변경하는 이유가 여러 개 존재해서는 안된다는 원칙이다. 변경 이유가 여러 개 있다는 말은 역할도 여러 개 있다는 것이며 깨지기 쉬운 모듈이다. 한개 모듈은 하나의 책임, 어떤 역할에 대해 순수한 것이 바람직한 상태인 것이다. 그런 상태로 만들려면 변경 이유나 빈도가 같은 코드를 한데 모으면 자연스럽게 단일 책임 원칙을 충족하는 모듈이 완성된다. 

<br/>

## 3.11 아키텍처 기본 기법

### What : 좋은 코드의 기초 원리   

아키텍처 기본 기법이란 소프트웨어 아키텍처를 적절하게 구축하는데 필요한 기초 원리이다. 기본 기법은 모듈의 설계방침으로 제시되며 10가지 기법인 [추상], [캡슐화], [정보 은닉], [패키지화], [관심의 분리], [충족성, 완전성, 프리미티브성(원시성, 순수성)], [정책과 구현의 분리], [인터페이스와 구현의 분리], [참조의 단일성], [분할 정복] 이 있다. 

### Why : 좋은 코드에는 품새가 있다.   

어떤 문제에 대해 뛰어난 해결책이 있으면 여러 차례 재사용했는데 그것이 기본 기법이다. 

### How :  품새(패턴)을 익힌다.   

기본 기법을 코드에 적용하자. 기본 기법은 본질적인 해법이라 개발 방법론이나 프로그래밍 언어와 관계없이 적용할 수 있다.

<br/>

## 3.12 추상(abstraction) - 아키텍처 기본 기법 (1)

### What : 개념적인 선 긋기   

추상이란 개념적으로 명확한 선 긋기를 수행하는 것이다. 선긋기에 따라 모듈이 명확히 구별된다. 추상은 **사상**과 **일반화** 라는 2가지 관점에서 정리된다.

- 사상 : 복잡한 대상의 몇 가지 성질을 버리고 특정한 성질에 주목하는 것이다.
- 일반화 : 구체적인 대상으로부터 공통 성질을 추출해서 더욱 범용적인 개념으로 정식화한다.

### Why : 복잡함에 대한 대항 수단   

추상은 인간이 복잡한 문제에 집중할 때 사용하는 기초적인 원리다.

- 사상 : 부차적인 부분을 제거해 본질을 드러낸다. 복잡도가 줄어들며 사용하기 쉽고 응용가능하다.
- 일반화 : 공통된 성질에 따라 그룹핑해서 같다고 간주한다. 그렇게 하면 한 현상에서 학습한 것을 다른 곳에 적용가능하다.

### How : 사상과 일반화를 구사   

추상화는 뛰어난 아키텍처를 구축하기 위해 필요한 프로그래머의 기초 기술이다. 추상을 통해 많은 대상에 일룔적인 공식을 적용할 수 있고 압도적으로 효율적인 생각을 할 수 있다.

- 사상 : 복잡한 대상에 집중할 때 사용한다. 본질을 파악하되, 지금의 문제에 관해 현재의 측면에서 본질을 파악한다.
- 일반화 : 여러 개의 대상에 집중할 때 사용한다. 공통된 성질들을 찾고 조합하여 범용적인 개념을 구성한다. 

<br/>

## 3.13 캡슐화 - 아키텍처 기본 기법 (2)

### What : 데이터와 로직을 그룹핑   

관계성이 강한 데이터와 로직을 모듈이라는 껍질로 감싸는 것을 캡슐화라고 한다.

### Why : 추상 개념이 섞이지 않는다.   

그룹핑을 통해 관련 있는 요소끼리만 특정 추상 개념을 담당하도록 모듈로 모은다. 그러면 다음과 같은 장점이 생긴다.

- 코드가 읽기 쉬워지고 변경시의 여파가 모듈 안으로 한정된다.
- 영향도가 명확하니 코드 변경이 쉬워지고 독립된 부분이라 재사용성이 높아진다.
- 작은 단위로 분할되어 복잡한 문제에 대처가능하다.

### How : 같은 부류의 요소를 캡슐에 담는다.     

관련 있는 데이터나 로직을 그룹핑해서 하나의 모듈로 모은다. 그리고 관련 없는 요소와는 섞이지 않도록 한다. 

<br/>

## 3.14 정보은닉 - 아키텍처 기본 기법 (3)

### What : 필요없는 것은 보여주지 않는다.   

모듈의 구현, 내부동작, 데이터 등을 해당 모듈을 사용하는 클라이언트로부터 은닉한다. 클라이언트는 공개된 함수를 통해 조작할 수 있다.

### Why : 관련을 정리해서 단순하게   

모듈의 내부 상세 부분을 은닉하면 인터페이스가 작아지고 정보의 교환이 단순해지며 코드 전체의 복잡성을 낮출 수 있다. 사용하는 측도 사용성이 좋아진다. 또한 모듈의 변경에 대한 파급을 최소한으로 억제할 수 있다.

### How : 내부는 은닉한다.   

모듈은 단순한 기능만을 공개하고 내부 상태, 기능은 모두 은닉한다. 정보 은닉을 실현하려면 캡슐화를 사용한다. 

### Dev : 캡슐화와 정보 은닉의 차이  

- 캡슐화 : 관계가 있는 요소를 모아 모듈화한다. 관계가 깊은 데이터와 함수는 한 군데에 모은다.
- 정보 은닉 : 모듈의 내부 상태나 내부 함수를 은닉한다. 내부에 대해서 외부의 직접적인 접근은 차단한다.

많은 기술 문서에서는 캡슐화를 정보 은닉이라는 의미까지 포함하는 형태로 사용한다. 따라서 캡슐화가 어느쪽의 의미로 사용되고 있는지 문맥을 따져봐야 한다.

### Rel : 파르나스의 규칙  

객체지향 설계에서 사용되는 규칙으로 2가지 조건으로 정의된다.

- 모듈의 **사용자**에게는 해당 모듈을 **사용**하는데 필요한 모든 정보를 주고 그 이외의 정보는 일체 보이지 않는다.
- 모듈의 **작성자**에게는 해당 모듈을 **구현**하는 데 필요한 모든 정보를 주고 그 이외의 정보는 보여주지 않는다.

내부를 몰라도 사용할 수 있고(재사용), 사용자에게 영향을 주지 않으면서 구현을 교체할수 있다(보수)는 이점이 있다.

<br/>


## 3. 15 패키지화 - 아키텍처 기본 기법 (4)

### What : 모듈을 그룹핑   

모듈을 의미 있는 단위로 모은 다음 그룹화한다. 이는 소프트웨어를 의미있는 단위로 분할하는데, 이 분할된 단위를 패키지라고 부른다. 패키지는 소프트웨어의 논리 구조를 물리 구조에 저장하는 방법을 결정한다. 소프트웨어의 기능이나 책임을 의미있는 단위로 저장하기 위한 물리적인 컨테이너 역할을 수행한다.

### Why : 모듈의 복잡도를 낮춘다.   

대규모 소프트웨어가 되면 대량의 모듈들이 복잡성을 초래하기에 모듈을 그룹핑할 필요갸 있는데 그것이 패키지이다.

- 소프트웨어 전체가 패키지라는 작은 단위로 분할되니 복잡성이 낮아지고 모듈 관리가 쉬워진다.
- 수정에 대한 영향도가 패키지로 한정되어 변경하기 쉽고 종속 관계가 정리되어 패키지 단위로 재사용 용이하다.

### How : 상향식으로 패키지 설계   

관련있는 모듈을 모아 패키지화한다. 패키지 설계는 모듈이 어느정도 만들어진 다음에 상향식으로 설계한다. 패키지는 소프트웨어 빌드 방법을 보여주는 지도에 해당한다. 패키지는 한 번 설계했다고 끝나는 것이 아니라 프로그래밍 진행과 함께 성장하고 진화해 가야 한다.

<br/>


## 3.16 관심의 분리; - 아키텍처 기본 기법 (5)

### What : 관심별로 코드를 분리   

**관심이란 소프트웨어의 기능이나 목적을 뜻한다.** 관심을 분리한다는 것은 각각의 관심에 관련된 코드를 모아 독립된 모듈로 만들어 다른 코드로부터 분리한다는 뜻이다. 설계 기법에서 패턴의 대부분은 관심의 분리를 실현하려는 목표를 가지고 있다. 프로그래밍에서 관심의 분리를 목적으로 하는 대표적인 기술은 관점 지향 프로그래밍이다.

### Why : 관심 단위로 변경이 이루어진다.   

코드의 변경은 관심 단위로 발생하니 관심별로 분리되면 다음의 이점이 있다.

- 관심별로 독립해서 수정할 수 있으므로 읽는 범위가 한정되고 변경이 쉬워진다.
- 영향 범위가 관심 안에 머무르므로 변경 시 품질이 안정된다.
- 코드를 작성할 때는 관심 단위로 개발하므로 분업, 병행하여 개발을 진행할 수 있다.

### How : 관심 단위로 모듈화   

관심별로 모듈을 작성하여 서로 다른 책임이나 관계없는 책임은 분리해 두자. 하나의 모듈이 다른 역할을 하고 있다면 역할을 독립시키기 위해 모듈을 분할한다. 기본적으로 하나의 모듈에 여러 역할을 갖게 해서는 안 된다.

### Rel: 관점 지향 프로그래밍  

관점 지향 프로그래밍(AOP: Aspect-Oriented Programming) 은 관심 중에서도 횡단적 관심을 분리;한 기술이다. 횡단적 관심이란 각 관심을 옆쪽에서 꿰는 듯한 관심을 뜻한다. 일반적으로 횡단적 관심은 분리되지 않는 상태로 상재되어 있는데 이것은 코드의 변경을 방해하는 큰 요인이다. 대표적으로 로그, DB 트랜잭션 시작 및 종료, 보안 접근 제어 처리등이 있다.   
AOP에서는 결합 규칙에 따라 횡단적 관심을 각 일반적인 관심에 자동으로 나중에 엮어내어, 코드에 대한 직접 호출을 방지하고 관심의 분리를 실현한다.

<br/>


## 3.17 충족성, 완전성, 프리미티브성 - 아키텍처 기본 기법 (6)

### What : 표현이 충분하고 완벽하면서 순수함   

모듈이 담당하는 추상에 대한 표현은 3가지 성격을 만족해야 한다.

- 충족성 : 충족성이란 모듈이 표현하고자 하는 추상이 그것을 전하기에 충분한지를 뜻한다. 
- 완전성 : 모듈이 표현하고자 하는 추사이 모든 특징을 갖추고 있는지를 뜻한다. 
- 프리미티브성 : 모듈이 표현하고자 하는 추상이 모두 순수한지 아닌지를 의미한다. 

### Why : 표현하고 있는 추상을 정확히 전한다.   

모듈이 표현하고자 하는 추상은 의도가 사용하는 사람에게 전해져야 하고, 유용해야 한다. 모듈이 충분하지 않으면 정보가 없어 사용자가 모듈의 본질을 놓친다. 모듈이 완전하지 않으면 사용자가 안심하고 사용할 수가 없다. 모듈이 프리미티브하지 않으면 사용자가 사용하기 어려워진다. 

### How : 모듈의 추상을 빈틈없이 표현   

모듈이 어떤 추상을 표현하고 있는지를 명확히 밝힌다. 정보는 너무 많아도, 적어도 전달되지 않는다. 그렇기에 모듈이 제공하는 함수는 충분하고 완전하고 순수한 라인업이어야 한다. 

<br/>


## 3.18 정책과 구현의 분리 - 아키텍처 기본 기법 (7)

### What : 정책과 구현은 섞지 않는다.   

**하나의 모듈에서 정책과 구현을 동시에 다뤄서는 안된다.**

- **정책 모듈** : 해당 소프트웨어의 전제에 종속되는 비즈니스 로직이나 그 밖에 모듈에 대한 파라미터를 선택한다.
- **구현 모듈** : 해당 소프트웨어의 전제에 종속되지 않는 독립된 로직 부분이다. 해당 소프트웨어의 전제 조건은 모듈에 대한 파라미터를 선택해서 이루어진다.

### Why : 구현은 안정적이지만 정책은 불안정   

구현 모듈은 특정 소프트웨어에 종속되지 않는 순수한 모듈이므로 다른 소프트웨어에서도 재사용 가능하다. 반면에 정책 모듈은 해당 소프트웨어에 특화되어 있으며 소프트웨어 변경시 같이 변경을 강요당한다. 그러니 두가지가 같이 다루어지면 재사용성이 나빠지는 것이다.

### How : 정책과 구현은 별개 모듈로 한다.     

소프트웨어의 전제에 종속되는 부분인 정책과 종속되지 않는 부분인 구현을 의식해서 설계하고 각각을 별개의 모듈로 나누어 코드를 작성한다. 만약 분리할 수 없을 때는 모듈내에서 명확히 각각을 알수 있게 해야 한다.  
코드를 보수하다보면 분리된 코드도 섞일수 있는데 특히 구현 쪽에 정책이 섞이지 않도록 수정 대상이 어떤 역할을 하는 모듈인지를 파악하고 나서 작업한다.

<br/>


## 3.19 인터페이스와 구현의 분리 - 아키텍처 기본 기법 (8)

### What : 구성은 인터페이스와 구현으로   

모듈은 인터페이스 파트와 구현 파트 2개의 분리된 부분으로 구성한다.

- **인터페이스 파트** : 모듈이 가능 기능을 정의하고 모듈의 사용 방법을 정하는 부분이다. 클라이언트에서 접근할 수 있는 함수의 원형으로 구성된다.
- **구현 파트** : 모듈이 가진 기능을 실현하는 코드 부분이다. 모듈이 내부에서 사용하는 로직과 데이터가 포함된다. 구현 파트는 클라이언트에서 접근할 수 없다.

### Why : 사용자는 인터페이스만 알면된다.   

인터페이스와 구현이 분리되면 클라이언트는 구현의 상세를 알 필요가 없고 모듈의 인터페이스 사양만 제시되어 사용성이 좋아진다. 또한 분리가 되면 기능 사용과 기능 구현의 독립성을 확보 할수 있게 되어 클라이언트에 대한 영향을 고려하지 않도록 구현을 수정할 수 잇다.

### How : 인터페이스를 사용해서 설계한다.   

인터페이스를 사용해서 코드를 설계하자. 모듈에 관한 설계 원리로 '구현이 아닌 인터페이스에 맞춰 프로그래밍하라'는 격언이 있다. 모듈끼리의 호출은 인터페이스만 사용하도록 한다. 인터페이스의 구현은 숨겨서 이것을 직접 호출하는 것은 허용하지 않도록 한다.

<br/>


## 3.20 참조의 단일성 - 아키텍처 기본 기법 (9)

### What : 정의는 한번만   

**모듈의 요소에 대한 선언과 정의는 1회로 제한한다.** 이렇게 하면 변수의 값 변화를 추적하지 않아도 된다.

### Why : side effect 가 없는 프로그래밍   

side effect가 없는 프로그래밍이 가능해진다. 프로그래밍에서 **side effect**란 **어떤 기능이 모듈의 상태를 변화시켜 이후로 얻게 될 결과에 영향을 미친다**는 뜻이다. 이것이 없으면 항상 같은 결과를 얻을수 있어 상황 종속에 따른 오류를 줄일 수 있다.

### How : 단일 대입을 한다.   

**단일 대입**을 수행한다. 단일 대입은 **변수에 값을 재대입하지 않는다**는 것이다. side effect를 피하려면 변수를 변하지 않는 것으로 파악해 처음 한 번 대입한 값은 나중에 변경하지 않도록 한다. 

### Dev : 변수 제어의 코드 품질을 올린다.  

원칙적으로 참조의 단일성을 지향한다 해도 실제 프로그래밍에서는 많은 변수를 관리해야 하고 오류가 발생한다. 다만 오류가 발생하기 쉬운 부분은 필연성이 없는 가변의 변수이다. 불필요한 가변성을 제거하고 불변의 변수를 늘린다면 품질이 향상된다.   
남은 가변의 변수들은 해당 변수에 접근하는 로직이나 스코프를 최대한 줄인다. 작은 함수를 많이 만들고 각각의 역할을 한정한다. 각각의 함수는 자신들이 건네받은 파라미터로만 작동하도록한다. 이렇게 코드를 작성하면 변수에 부적절한 값이 들어온다 해도 해당 부분을 특정하기가 쉽다. 즉 오류 해결을 좀더 쉽게 할수 있다.

### Rel : 참조 투과성  

참조 투과성이란 함수가 다음 2가지 특성을 갖는 것을 말한다. 참조투과성을 충족하는 함수는 동작이 외부 상태에 독립적이고 자기 완결적이며 테스트하기가 간단해고 처리의 최적화도 수행하기 쉽다.

- 호출 결과가 파라미터에만 종속된다 : 순수함수를 의미하며 파라미터 값에만 반환값이 종속된다.
- 호출이 다른 기능의 동작에 영향을 주지 않는다 : side effect를 갖지 않는다는 것이다.

<br/>


## 3.21 분할 정복 - 아키텍처 기본 기법 (10)

### What : 커다란 문제를 잘게 나눈다.   

어려운 커다란 문제를 여러개의 작은 문제로 분할해서 개별적으로 해결한다.

### Why : 커다란 상태로는 제어 불능   

커다란 문제는 규모가 커서 문제가 복잡하기 때문에 제어하기 쉬운 규모까지 문제를 분할하고 거기서부터 문제해결을 시작하는 방식이 효율적이다.

### How : 잘게 쪼개서 각개 격파한다.   

- 소프트웨어 전체를 설계할 때는 독립해서 설계할 수 있는 부분으로 분할한 다음 착수한다. 
- 모듈을 설계할 때는 책임과 책무라는 관점에서 모듈을 분할하도록 한다.
- 알고리즘을 설계할 때는 병합 정렬처럼 상향식으로 분할해서 해결가능 여부를 검토한다.
- 대량의 데이터를 처리하는 설계를 할 때는 계산을 작은 단위로 분할하여 분산 환경에서 병행 처리할 수 있는지를 검토한다.