# 2장 원칙 - 프로그래밍의 가이드라인

## 2.1 KISS (Keep It Short and Simple)

### What? 코드는 단순하게 유지한다.  

코드를 작성할 때는 최우선 가치를 단순성과 간결성에 둔다. 신규, 수정, 기능 확장할 때도 의도적으로 코드를 단순하게 유지한다.

### Why? 코드는 무질서로 향한다.  

코드는 아무 생각 없이 수정하다 보면 저절로 무질서해지고 복잡해지며 그것을 반복하면 최종적으로는 개선할 수 없는 썩은 코드에 다다른다. 

반면에 단순한 코드는 구성하는 각 요소가 모두 단순하고 각 요소가 담당하는 기능도 최소한으로 한정되어 있다. 각 요소끼리의 관계도 단순하다. 따라서 단순한 코드는 읽기 쉽고 이해하기 쉬우며 수정이 용이하다. 또한 의사소통 유지비용을 절약하며 개발 속도를 떨어뜨리지 않고 장기간의 유지보수가 가능해진다.

코드는 반드시 변경이 되기에 단순한 코드에서 얻게 되는 수정 용이성은 반드시 지켜져야 할 코드의 상태이다. 

### How? 코드의 불필요한 것을 하지 않는다.  

단순함을 프로그래밍의 나침반으로 삼는다. 코드에서 불필요한 것과 넘치는 것을 가능한 제거해야 한다. 그러기 위해서 코드가 동작할 수 있는 가장 간단한 방법은 무엇인지 항상 질문을 던져야 한다. 다음 상황들을 생각해 보자.

**새롭게 배운 기술을 사용하고 싶다.**  
새로 배운 기술을 사용하고 싶어서 불필요하게 기발한 코드를 작성할 때가 있는데, 코드는 뽐내려고 하는게 아니라 사용자에게 가치를 제공하기 위함이다. 코드를 작성하는 방식이 정말로 필요한지를 항상 곱씹어 보고 계속 코드를 단순하게 유지할 수 있는 방향으로 나아가야 한다.

**장래의 필요에 대비하고 싶다.**  
장래에 필요할거라 생각해서 코드를 더 많이 작성하는 경우가 있는데, 그렇게 생각하며 만든 코드는 결국 필요해지지 않는다. 필요해졌을 때 필요한 만큼만 코드를 작성하도록 해서 단순함을 유지하자.

**멋대로 요구사항을 추가한다.**  
멋대로 요구사항을 판단해서 불필요한 코드를 추가할 때도 있다. 사용자에게 요청하는거보다 쉽다고 생각하기 때문인데, 요구사항을 결정하는 것은 사용자이니 그래선 안된다. 현 시점에 필요 없어질 가능성이 있는 코드를 추가하면 유지보수에 드는 수고와 시간은 급격히 불어난다. 요구사항에 없는 불필요한 코드를 작성하지 않는 것이 단순함을 유지하는 것이다. 

### Dev? KISS의 적용 범위  

KISS는 원래 엔지니어링 전반에 적용되는 원칙이다. 다만 결과물이 갖는 복잡화 경향은 소프트웨어 개발에서 현저하게 나타난다.

### Rel1? less is more  

단순한 것이 더 아름답다는 의미이다. 건축분야의 표현으로, 외적인 요소와 내적인 요소 양쪽을 줄이고 단순화함으로써 다양한 외적요인에 견딜수 있고 더 풍부한 공간을 가지는 건축물을 계획할수 있다는 사상이다.  
소프트웨어에서도 불필요한 코드를 작성하지 않음으로써 코드를 단순하게 유지하고 갖가지 문제들을 피할 수 있다. 그러니 작성하는 코드가 정말로 필요한지를 항상 자문자답해야 한다.

### Rel2? 오컴의 면도날

오컴의 면도날이란 '어떤 사항을 설명하는 데 필요 이상으로 많은 전제를 가정해서는 안된다는 사고방식'이다. 즉 여러가지 설명이 가능하다면 가장 단순한 방식이 옳다는 것으로, 프로그래밍에서도 코드의 기능이 동일하다면 불필요한 것이 없는 것이 좋다. 

<br/>

## 2.2 DRY (Don't Repeat Yourself)

### What? 코드 복사는 금물  

똑같은 코드를 중복해서 작성해서는 안된다. 주요 사례로는 아래와 같다.  

1) 로직 덩어리를 다른 부분에 복사 붙여넣기  
2) 같은 조건을 다루는 제어문 블록이 중복해서 나타남  
3) 정수 리터럴을 직접 코드에 내장하는 것  
4) 단순한 코드를 그대로 설명하는 주석

### Why? 코드를 개선할 수 없다.  

코드에 중복이 있으면 오류 수정이나 기능 추가 등 코드를 개선하기 어려워진다. 어려움에는 다음과 같은 것들이 있다.

1) **코드를 읽는 작업이 어려워진다.** 같은 코드가 중복되면 양이 더 많아지고 더 복잡해져 가독성이 나빠진다. 코드를 정확히 파악하지 못하면 수정 방침조차 세울 수 없다.  
2) **코드를 수정하는 작업이 어려워진다.** 모든 곳을 정확하게 수정하지 않는 이상 전체적인 정합성을 보장할 수 없다. 각각의 부분에서 주변 코드를 읽어 수정이 필요한지를 판단해야 하는데, 중복 코드에 미세한 차이까지 있으면 더욱 깊게 읽어야 한다. 최악에는 해독이 불가능해진다.  
3) **테스트가 없다. **

### How? 코드를 추상화한다.

코드를 추상화함으로써 중복을 제거한다. 추상화하려는 코드는 함수화, 모듈화를 하고 데이터는 상수를 정의하고 사용되는 부분에 치환한다. 추상화를 하게 되면 코드의 양이 줄어들고, 가독성이 증가하고, 수정이 용이하며 재사용이 쉬워진다. 하지만 추상화를 하고자 하면 심리적인 벽이 있다. 먼저 추상화를 하는데는 시간이 걸리고, 디그레이드가 될 수 있으며 귀찮다. 그래도 중복을 피하면 장기적인 안목으로 봤을 때 유리해진다는 것이 역사의 결론이다.

### Dev1? DRY의 적용범위  

DRY는 소프트웨어 개발에 관한 모든 활동에 적용할 수 있다. 구체적으로는 반복되는 작업을 자동화 해야 한다. 자동화 대상으로 여겨지는 대표적인 작업으로는 **지속적인 통합** 이라 불리는 테스트, 빌드, 배포 작업이 있다. 지속적인 통합은 반복 수작업이 없어지는 것 외에도 빌드 품질이 안정되고 빌드가 속인화 되지 않으며 문제를 조기 발견할 수 있다는 등의 많은 장점을 누릴 수 있다.

### Dev2? DRY와 프로그래밍 기술  

프로그래밍 기술의 대부분은 DRY를 실현하기 위한 기능을 갖추고 있다. 사실 기술의 대부분은 코드 중복을 제거하는 것을 목적 중 하나로 삼고 있다. 또한 설계 기법에도 대부분 중복 제거라는 목적을 포함하고 있다. 대표적으로는 디자인 패턴이 있다. 이것은 코드를 재사용 가능하게 하려고 코드 구조 패턴을 재공한다. 다른 측면에서 보자면 '사고의 중복이 일어나지 않게 하는 기법'이라 할수 있다. 

기술, 기법들은 특정 목적을 갖고 고안되니 배울 때는 목적을 파악하는 것이 습득에 이르는 지름길이다.

### Dev3? 불가피한 DRY 위반  

소프트웨어 개발에는 어느정도 불가피한 중복도 존재한다. 소프트웨어에서 불일치가 발생하기 쉬운 부분은 추상화 스타일이 서로 다른 경계선이다. 그 중 대표적인 사례가 객체지향 프로그래밍의 클래스와 관계형 데이터베이스의 테이블이다. 서로간의 불일치를 메우기위하 관계형 데이터 베이스 쪽의 '테이블 정의',  코드 쪽의 '테이블 매핑 설정파일', '소스파일' 이렇게 세군데에 같은 정보를 갖고 있어야 한다. 이것은 어느 정도 불가피하다.

대책이라고 한다면, 정보는 어딘가 한군데에 집중해서 저장하고 거기에서 다른 정보를 자동으로 생성하는 구조를 만든다면 정보를 일괄 관리할 수 있다.

### Rel1? WET  

Write Everything Twice의 약어로 모두 같은 것을 반복한다는 의미이다. 즉 DRY의 반대되는 단어라고 보면 된다.

### Rel2? One Fact in One Place

OFOP라고 하며 **한 곳에는 하나의 사실** 이라는 의미로, 데이터 베이스 논리 설계에서 테이블 설계의 핵심이 되는 원칙이다. OFOP는 데이터베이스에 저장되는 데이터 중복을 금지한다. 이것을 실현하기 위해 정규화를 수행한다.

### Rel3? Once and Only Once

OAOO는 **한 번만, 단 한 번만** 이라는 의미이다. DRY의 의미나 목적이 동일하지만 적용 범위가 좁고 프로그래밍 컨텍스트에서만 사용된다. 

### Rel4? 레거시 코드  

테스트가 없는 코드를 레거시 코드라고 부른다. 예전에는 '옛날에 만들어진 이해할 수 없고 변경하기 어려운 코드'를 조롱하는 속어였지만 최근에 테스트에 의한 품질 보호를 중요시할 목적으로 재정의되었다.레거시 코드의 재정의에 따르면 테스트가 없는 코드는 예외없이 나쁜 코드이다. 코드를 개선한다고 해도 테스트를 하지 않으면 코드가 의도대로 작동하는지 확시;ㄹ하게 알 수 없다. 따라서 레거시 코드를 상대하게 되었다면 일단 테스트부터 수행하자.

<br/>

## 2.3 YAGNI (You Aren't Going to Need it)

### What? 코드는 필요할 때 최소한으로  

'아마 필요해지겠지' 같은 식으로 코드를 작성해서는 안된다. 정말로 필요해졌을 때 필요한 코드만을 작성한다는 방침으로 프로그래밍에 임해야 한다. 소프트웨어의 변경을 완벽하게 예측해서 코드를 작성하는 것은 불가능하다. 그러니 지금 필요한 코드만을 작성하도록 한다.

### Why? 코드의 예측은 빗나간다  

확장성을 고려해서 넣은 설계라도 예상은 대부분 빗나가며 거기에 들인 시간이 쓸모 없어진다. 또한 확장성을 염두에 두면 오히려 코드에 불필요한 복잡성을 담는 셈이 된다. 사용하지 않은 코드가 있으면 종종 난해하고 보수하기 어려운 코드가 만들어지며 오히려 방해물이 된다.

### How? 코드는 지금 필요한 것만  

범용성보다는 단순성을 생각한다. 우선 사용할 수 있는 데 가치를 두도록 한다. 범용성을 자랑하는 복잡한 방식보다는 궤적인 요구사항을 기초로 하는 단순한 방식을 선택하자. 단순한 방식이 사실 범용성이 더 높을 때가 많으며 단순한 코드를 변경하는 것이 범용적이고 복잡한 코드를 변경하는 것보다 간단하다.

### Dev1? YAGNI의 적용범위  

YAGNI는 코드에만 한정되는 것이 아니라 소프트웨어 기능에도 해당한다. 예상해서 만든 기능은 빗나갈 경우 전체 사용법을 복잡하게 만들고 사용성을 떨어뜨리기만 한다.

### Rel1? DTSTTCPW  

Do The Simplest Thing That Could Possibly Work의 약어로 **효과 있는 방법 중에서 가장 간단한 방법으로 하라** 는 의미이다. 프로그래밍에서는 경험적으로 '오늘 단순하게 하고 내일 변경이 필요해졌을 때 변경 비용을 지불하는 것' 이 '오늘 복잡하게 하고 결국 사용하지 않는 것'보다 좋은 결과를 낳는다고 알려져 있다.

<br/>

## 2.4 PIE (Program Intently and Expressively)

### What? 코드의 의도를 전한다  

코드를 작성할 때는 의도를 명확하게 표현해야 한다. 소프트웨어가 어떻게 동작하는 것인지 코드를 읽는 사람이 직관적으로 알 수 있게끔 코드를 작성한다.

### Why? 코드가 유일한 실마리  

소프트웨어의 동작은 문서들만 가지고는 정확하게 알 수 없다. 코드는 소프트웨어 동작을 정확하게 완벽하게 알기 위한 유일한 실마리이다. 따라서 이해하기 쉬운 코드를 작성해서 코드로 의도를 표현해야 한다.

### How? 코드는 읽기 쉬운 것이 최우선  

코드를 작성할 때는 '작성하기 쉬움'보다 '일기 쉬움'을 중시하자. 결과적으로 코드를 작성하는 시간보다 코드를 읽는 시간이 훨씬 많다. 따라서 코드는 작성하는 효율보다 읽는 효율이 우선시 된다. 읽고 이해하기 쉬운 코드의 가치는 누적해서 증가한다. 코드는 실행 효율보다 읽는 효율이 우선시 된다. 읽기 쉽다면 나중에 실행 효율을 높이는 것은 간단하기 때문이다.  
읽는 효율이 우선이므로 어려운 방식으로 뽐내지 말고 읽는 사람에게 의도가 제대로 전해지는 코드를 작성하자. 자기 코드든 남의 코드든 읽었을 때 곧장 의도를 알기 어렵다면 즉각 이해하기 쉽도록 다시 작성한다. 눈앞의 코드부터 바꿔나가면 자신의 모든 작업이 원활하게 진행될 것이다.

### Dev1? 두더지 잡기식 개발을 피한다.  

기능을 완성하기까지의 속도를 중시하는 대가로 코드 품질을 희생하고 마는 경향이 있다. 읽기 쉽고 오류가 없으며 품질이 좋은 코드(와 테스트)를 작성하려면 분명히 시간이 걸린다. 하지만 장기적으로는 반드시 이익을 가져준다.

### DEV2? 주석을 작성한다  

주석 없이도 읽을 수 있는 이해하기 쉬운 코드를 작성하는 것이 이상적이지만, 코드는 why '어째서 그것을 하는지'를 표현하지 못하기 때문에 주석을 사용할 필요가 있다.   
코드라는 문서는 읽는 사람과의 의사소통에 사용하는 것이다. 원활한 의사소통을 위해 why에만 머물지 말고 수단으로 사용해야 한다. 즉 주석으로 설명하지 않아도 되는 이해하기 쉬운 코드를 지향하면서, 그럼에도 표현할 수 없는 부분에는 주석을 활용하ㅣ는 식으로균형잡힌 코드를 작성하도록 한다. 

### Rel? 문학적 프로그래밍  

의도를 나타내는 프로그래밍의 궁극적인 형태로 문학적 프로그래밍(Literate Programming) 이라는 기법이 있다. 이것은 코드 자체를 문서화하는 기법으로 코드와 문서를 따로 작성하지 않고 하나의 문서에 짜집기 하듯 작성한다. 문학적 프로그래밍에서 코드는 스토리처럼 작성되며 장점들은 다음과 같다.

- 문서를 별도로 작성하지 않기 때문에 코드 설명이나 정당성의 근거를 기술하면서 프로그래밍을 진행할 수 있고, 프로그래머가 코드에 관해 다른 관점에서 생각해 볼 수 있다.
- 코드와 설명이 가까운 위치에 기술되므로 수정 작업이 쉽고, 코드를 변경할 때 설명이 적절하게 갱신된다.
- 전체적으로 코드 기반 문서가 단 하나만 존재하는 것이 보증된다.
- 일반적인 주석에는 기술되지 않는 종류의 정보( 알고리즘의 설명, 정당성을 입중할 증명, 설계상의 결정 근거 등 )도 코드에 포함된다.
- 풍부한 설명을 직접 참조할 수 있으므로 일반코드보다 유지보수가 매우 쉬워진다.

<br/>

## 2.5 SLAP (Single Level of Abstraction Principle)

### What? 코드 수준을 맞춘다.  

코드를 작성할 때 높은 수준의 추상화개념과 낮은 수준의 추상화개념을 분리하도록 한다. 추상화 단계를 분리할 때는 기능의 복잡도에 따라 여러 계층으로 분리한다. 각각의 계층에서는 자신의 계층에 속하는 요소에 대해 추상화 수준을 일치시킨다. 즉 함수는 추상화 수준에 따라 분할하고, 같은 함수에 속하는 코드의 추상화 수준은 모두 통일한다는 뜻이다.

코드의 추상화 수준을 일치시키면 책처럼 읽을 수 있다. 수준별로 책의 목차가 되고, 본문 내용이 되는 것이다.

```
function 고수준() {		// 수준1의 목차
  중수준1();
  중수준2();
}

function 중수준1() {		// 수준2의 목차01
  저수준1();
  저수준2();
}

function 저수준1() {		// 본문 내용
  // 처리...
}

function 저수준2() {		// 본문 내용
  // 처리...
}
```



### Why? 코드에 요약성과 열람성을 가져다준다  

코드가 수준이 일치된 함수로 분할되어 있으면 요약성과 열람성을 동시에 충족한다. 즉 함수 일람은 목차가 되고 요약성을 지닌다. 분할된 함수는 작은 코드 묶음이 되어 열람성이 좋아진다. 따라서 막힘없이 흐르고 이해하기 쉬워진다.

### How? 함수를 구조화한다.  

의도가 전달되기 쉽게끔 처리는 추상화 수준을 일치시킨 작은 단계의 함수로 변환하자./ 함수를구조화하면 각 함수는 자신보다 한 단계 낮은 수준의 함수를 호출하는 처리가 중심이 된다. 다른 함수를 호출하느 코드로 구성된 함수를 **복합 함수(composed method)** 라고 부른다. 복합 함수는 최대한 작게 만들며 추상화 수준이 다른 함수를 호출하지 않도록 한다. 

### Dev1? SLAP의 적용 범위  

SLAP은 함수뿐만 아니라 모듈 등에도 적용된다. 훌륭한 소프트웨어 설계에서는 개념이 여러 수준으로 분리되어 각기 다른 저장소에 저장된다. 높은 수준의 개념은 추상 클래스에 포함되고, 낮은 수준의 개념은 상속 클래스에만 포함되도록 만든다.

### Dev2? SLAP의 순서  

구체적인 처리를 작성하는 작업과 추상화 수준을 일치시키는 작업은 모드를 전환해서 별개의 작업으로 수행하도록 한다. 

### Rel? 코드와 책의 유사성  

|            | 책                                       | 코드                                       |
| ---------- | --------------------------------------- | ---------------------------------------- |
| 서문         | 책의 요지가 제시되며 거시적 관점에서 책의 위치를 설명한다.       | 파일 첫 머리의 주석에 해당한다. <br />코드에 기술한 내용을 설명하고 해당 코드가 어느 프로젝트에 속하는지를 명기한다. |
| 목차         | 책 내용의 순서를 보여준다.                         | 함수의 일람에 해당한다.                            |
| 섹션         | 보통 여러개의 섹션으로 구분되어 있다.                   | 하나의 파일에 여러 모듈이 기술되어 있거나, 파일 안의 함수를 논리적으로 몇 개의 그룹으로 분류할 수 있다면 여러 개의 큰 섹션으로 분할 할 수 있다. <br />방파제 주석이 논리적인 구분을 명시하는데 도움이 된다. <br />하지만 코드의 양이 많다면 섹션을 나누기보다는 파일을 나눈것이 좋은 방법이다. |
| 장          | 책의 장은 자기 완결된 한 덩어리의 내용에 적절한 제목을 붙인 것이다. | 함수에 해당한다. SLAP을 적용해서 구조화한 함수를 작성한다.      |
| 단락         | 책의 단락으로 공백 구분으로 표현한다.                   | 함수 안에서 코드의 블록에 해당한다. 논리적인 묶음을 공백 구분으로 표현한다.<br />각 함수의 로직은 문장의 나열로 구성되는데 논리적인 블록으로 나누고 공백 라인을 통해 후속 코드와 분리한다. |
| 문장         | 책의 각 문장은 코드 하나하나의 구문에 해당한다.             | 일기 쉽게 하기 위해 하나의 코드는 가능한 짧고 하나의 사항만을 작성하도록 한다. |
| 상호 참조 및 색인 | 책의 상호 참조나 색인                            | 통합 개발 환경이나 편집기의 건너뛰기 기능, 검색 기능이 담당한다.    |

<br/>

## 2.6 OCP (Open-Close Principle)

### What? 코드의 변경은 파급시키지 않는다  

코드는 확장에 대해서 열려 있고 수정에 대해서 닫혀 있는 2가지 속성을 동시에 충족하도록 설계한다. 확장에 대해서 열려 있다는 말은 코드의 동작을 확장할 수 있다는 것이다. 수정에 대해서 닫혀있다는 말은 코드의 동작을 확장하더라도 그 밖의 코드는 전혀 영향을 받지 않는다.

### Why? 코드의 변경에 유연하게 대응한다  

소프트웨어는 항상 변화한다. 변화에 노출되면서도 장기적으로 앉벙된 소프트웨어를 설계해야 하기 때문에 유연한 설계가 요구된다. 유연한 설계란 확장에 대해서 열려 있고, 수정에 대해서 닫혀 있는 설계이다. 유연하게 설계되어 있다면 요구사항이 변경되었을 때 코드에 새로운 처리를 추가하기만 해도 위험 요소 없이 해당 소프트웨어의 동작을 변경할 수 있다. 반면에 경직된 설계는 곧 깨지기 쉬운 설계이다.

### How? 코드에 인터페이스를 사용한다  

인터페이스를 사용해서 설계하자. 모듈을 설계할 때, 클라이언트가 모듈의 제공자인 서버를 직접 호출하는 방식은 경직된 설계이다. 다른 서버를 사용하고 싶다면 클라이언트를 변경해야 하기 때문이다. 그래서 클라이언트와 서버 사이에 모듈 사용자를 위한 클라이언트 인터페이스를 만든다. 서버는 클라이언트 인터페이스를 구현한다. 이렇게 하면 클라이언트는 서버 교체로 인해 코드를 변경할 필요가 없다. 기존 코드를 변경하지 않고도 기능 추가가 가능해진다.

### Dev1? OCP의 적용 범위  

코드의 모든 부분에 OCP를 적용하는 것은 과한 방식이다. 변경이 발생하지 않는다면 코드만 복잡해질 뿐 그저 쓸데없이 장황한 코드가 되기 때문이다. OCP의 과도한 적용을 방지하려면 변경 내용을 지나치게 예측하지 말아야 한다. 완벽한 예측은 불가능하기 때문이다. 그래서 어느 정도 태협해서 실제 변경이 발생하기를 기다리는 전략이 있다. 첫번째 변경이 일어나면 그때 실시하는 것이다.  
OCP의 적용의 핵심은 변경 내용을 예측하기보다 변화할 법한 부분을 예측하는 데 있다. 변화가 있을 법한 곳을 찾아내어 해당 부분을 인터페이스 뒤로 숨기는 기법을 **유동적 요소의 캡슐화** 라고 부른다.

### Dev2? OCP의 구현과 설계  

OCP를 구현하는 방법 가운데 대표적인 기술이 객체지향의 '다형성'이지만 OCP는 언어를 뛰어넘어 적용할 수 있다. 또한 디자인 패턴의 대부분은 OCP를 실현하기 위한 수단으로 사용할 수 있다. 대표적으로 스트레티지 패턴, 옵저버 패턴, 템플릿 메서드 패턴, 데코레이터 패턴 등이 있다.

### Rel? 변경 보호  

GRASP(General Responsibility Assignment Software Pattern) 라는 책임주도 개발 설계 기법에서 변경 보호(protected variations) 라는 설계패턴이 있다. 변경이 예측되는 불안정한 부분과의 접점을 식별해서 접점 주변에 안정된 인터페이스를 구축하는 식으로 책임을 할당하는 기법이다. 이것은 불안정한 부분에서 불안정을 이유로 자주 발생하는 변경에 따른 영향을 인터페이스라는 방어벽을 세워 보호하는 전략이다. 

<br/>

## 2.7 네이밍이 중요하다.

### What? 코드에서 네이밍은 가장 중요한 과제  

프로그래밍에서 네이밍을 가장 중요한 과제로 인식하고 신중하게 착수하도록 하자. '이름을 붙이는 행위'와 그런 과정을 통해 생겨난 '이름 자체'에 모두 중요한 가치가 있다.

- 이름을 붙이는 행위 : 적절한 이름을 붙일 수 있었다는 것은 해당 요소가 바르게 이해되고 설계되어 있다는 뜻이다.
- 이름 자체 : 이름은 코드를 통해 프로그래머끼리 의사소통하기 위한 최대의 터전이다. 이름에는 최대한의 배려가 있어야 한다.

### Why? 코드를 읽는 사람에 대한 사용자 인터페이스  

이름은 코드를 읽는 사람에 대한 사용자 인터페이스이다. 각 요소에 대해 적절하게 이름 붙여진 코드는 작성한 의도가 전해져 무엇을 어떻게 했는지 이해할수 있다. 읽으면 곧바로 의미를 알 수 있는 좋은 사용자 인터페이스이다.

**좋은 네이밍의 장점**

- 코드를 읽을 때 함수 이름만 봐도 이후의 처리 개요를 파악할 수 있으므로 적절히 건너뛰면서 읽을 수 있다.
- 코드를 작성할 때 해당 함수를 사용하는 곳에서는 이름이 가이드가 되어 목적이나 사용방법을 바로 이해할 수 있으므로 호출이 간단하다. 작성이 끝난 코드는 좋은 이름 덕분에 설명적이라 읽기 쉬워진다. 

**이해하기 어려운 코드에 걸리는 부하**

- 코드를 읽을 때 함수 이름만 보고 처리 내용을 알 수 없다면 내용을 이해하기 위해 함수 내부를 해석해야만 한다. 즉 파고 내려가는 읽기를 강요당하는 셈이다. 함수 계층이 얕다면 그다지 문제가 되지 않겠지만 계층이 깊어질수록 프로그래머에게는 커다란 부담이 된다.
- 코드를 작성할 때 사용하고 싶은 함수의 이름으로부터 여러 가지 판단을 내릴 수 없다면 역시 함수 내부를 분석할 필요가 생긴다. 어떻게 사용할 수 있더라도 작성이 끝난 코드는 호출하는 함수 이름이 나쁜 탓에 읽기 어려워진다.

적절한 이름을 떠올리려면 고도의 사고능력이 필요하고 시간도 걸린다. 그렇다고 부적절한 네이밍을 하게 되면 코드를 읽거나 사용하는 사람 모두에게 지속적으로 부정적인 영향을 주게 되는 셈이다. 

### How? 코드는 우선 이름을 정한다  

프로그래밍은 우선 이름부터 시작한다. 코드에 나타나는 갖가지 요소에 의도가 명확하게 전해지도록 이름을 붙이고 사용하거나 읽을 사람의 관점에서 명명해야 한다. 구체적인 주의 사항은 아래와 같다.

- 이름에는 더욱 많은 정보를 담도록 한다. 이름을 짧은 주석이라 생각하면 전해야 할 정보를 쉽게 포함할 수 있으며 후보를 열거해 놓고 선택하면 더 좋은 이름을 붙일 수 있다.
- 이름은 오해받지 않도록 주의한다. 다른 의미와 혼동되지 않게 여러번 자문해본다. 오해를 줄이기 위해 각 프로그래밍 언어의 관행을 알고 거기에 익숙해지는 것도 필요하다.
- 이름이 효과와 목적을 설명하도록 한다. 수단으로는 언급하지 않으면 코드를 읽을 때 상세를 이해하는 수고를 덜 수 있다.
- 이름을 스스로 점검해보고 싶다면 처리를 작성하기 전에 테스트를 작성하도록 한다. 그러면 사용자 관점에서 생각할 수 있다.
- 이름은 발음 가능한 것으로 한다. 실제 대화에서 사용하기 쉽고 코드를 읽을 때도 발음할 수 있어야 뇌에 부담이 가지 않는다.
- 이름은 검색 가능하도록 붙인다. 예를 들어 영문자와 숫자 한글자씩 이름을 붙이면 검색할 때 일치 결과가 많아 분석시에 수고가 많이 든다.

### Dev? 마인드 매핑 회피  

어떤 정보로부터 기억 속에 있어야 할 모습의 이미지로 변환하는 것을 마인드 매핑이라고 한다. 코드를 읽는 사람이 이름을 보고 마음 속에서 자기가 기존에 알고 있던 이름으로 변환해야 하는 마인드 매핑 상황은 최대한 피해야 한다. 이것은 뇌에 매우 부담을 가해 집중력을 떨어뜨린다. 마인드 패팅은 규약이나 문제 영역에서 벗어난 용어를 사용했을 때 발생한다. 독자적인 이름이 아닌 표준에 기반한 용어로 명명해야 한다.   
마인드 매핑은 한 글자짜리 변수 이름을 사용할 때도 발생한다. 한 글자짜리 변수 이름은 단순한 플레이스 홀더에 불과하다. 코드를 읽는 사람은 원래 있어야 할 이름으로 마인드 매핑을 해야 한다. 프로그래머는 사용자에게 가치를 제공하기 위해 자신의 능력을 사용한다. 다른 사람이 이해할 수 있게끔 명명하고 이해하기 쉬운 코드를 작성하자.

### Rel? 루프백 확인  

네이밍에는 '이름 가역성'이라는 개념이 있다. 이것은 '이름이란 명명의 기반이 된 내용의 설명문을 복원할 수 있어야 한다'는 네이밍 방침이다. 이 방침을 충족하려면 루프백 확인을 수행해야 한다. 내용의 설명문으로부터 이름을 떠올렸다면 반대로 이름에서 추측할 수 있는 설명문을 생각해 보는 것이다. [설면 -> 이름 -> 설명] 순서로 한바퀴 돌아서 원래로 돌아왔을 때 (루프백) 설명이 일치하면 좋은 이름이고 그렇지 않으면 주의가 필요하다.

