
GOF 디자인 패턴의 분류는 이미 객체지향 설계에 숙달한 사람을 대상으로 한다. 객체의 협력망을 만드는데 숙달된 사람을 말한다. 이 수업의 수준에서는 객체 역할 모델을 가르치면서 DP를 가르쳐 나갈 것이다.

객체지향 설계를 학습할 수 있는 분류

1. 다형성 : OOP의 근간이 되는 원리, 대체가능성이라고 불리는 자식대신 부모 형을 쓸수 있다는 것이다. 내적동질성이라는 개념도 있다.
2. 캡슐화 : 어떠한 복잡한 기능을 직접 외부에 노출하지 않고, 표현하고 싶은 기능을 노출한다. 하지만 은닉은 직접적인 노출을 피하는 것이다. 행동을 추상화해서 노출하는게 캡슐화이다.
3. 객체간 관계 : 객체가 망을 형성할때 관계를 맺게 된다. 부모 자식 관계, 계약 관계, 소유 관계, 
4. 변화율 : 어떤 것은 자주 바뀌고, 어떤 것은 자주 안바뀌는 부분은 부모, 자식 관계로 분류하는 경우가 많다. 같은 카테고리내에서 시간에 대한 변화를 담당하는 데 많이 쓰이는 전략이 부모 자식 간의 전략이다. 
5. 역할모델 : 수정하는 건수 별로 격리시키는 것을 말한다. 예를들어 데이터와 렌더러와 같은 분리이다. 역할 모델에 따른 분리이다. 수정 건수에 대해서 변화가 해당 부분만 수정될수 있도록 하는 것.

객체 설계를 배우기 힘든 이유는 변화율과 역할 모델을 동시에 반영한 설계를 만들기 때문이다. 디자인 패턴을 배울때 주요한 카테고리는 이러하다. 여기에 없는 카테고리 하나가 있는데, 바로 알고리즘이다. 객체지향설계에서 문제 해결시, 역할을 가진 객체 망으로 문제를 해결하지만, 근본적인 문제는 알고리즘이다. 컴퓨터는 어차피 알고리즘으로 문제를 푼다. 

우리가 해결해야 할 근본적인 문제는 알고리즘이고 이것은 상태와 분기에 대한 내용이다. 가장 기초적인 알고리즘을 해결하는 패턴중에 2가지가 있다.  우리가 알고있는 제어문은 조건문과 반복문이 있다. 우리는 조건문을 객체의 관계로 해결한다.

기존 제어문 기반의 알고리즘이 갖는 문제. " 수정하면 전체가 컴파일 된다. "

정의시점 : 함수를 만드는 것

실행시점 : 함수를 호출하는 것

정의시점과 실행시점은 상대적인 개념이다. 브라우저도 OS입장에서는 실행시점의 어플리케이션이다. OS는 정의시점의 객체라고 보면된다. 브라우저 입장에서는, 자바스크립트는 실행시점에 실행되는 것이다. 정의시점에서는 그 이후가 실행시점으로, 실행시점에서는 자기 이전은 정의시점으로 볼수 있다.

구구단을 1단만 나오도록 만들었는데, 10단까지 나오도록 하려면, 코드를 고쳐야한다. 그 코드와 관련된 테스트, 의존 하는 코드들의 여파 등을 다 확인해봐야 한다. 그래서 가장 좋은 것은 안 고치는게 제일좋다. 격리 이론자체가 최대한 수정이 없도록 하고 정말 필요한 부분만고칠려고 하는ㄱ ㅓㅅ이다. 

하지만 제어문은 그것에 위배된다. 코드를 고치지 않고서는 원하는 수정을 할수가 없으므로.

제어문 기반의 알고리즘은 나쁘다. 그렇다면 알고리즘이 변화한 부분만 수정하고 나머지는 건드리고 싶지 않다면? ==> 최대한 개별 알고리즘을 함수로 분리한다.



#### 알고리즘이 변화하는 이유?

1. 비즈니스 모델 변화 : 비즈니스
2. 연관 라이브러리 변화 : 외부 API 의존하는 이상 통제 불가
3. 호스트측 변화 : 사용하는 측의 변화, API서버를 쓸려고 하는데 브라우저에서 쓰는 것으로 확정되었을때 동일 도메인 정책에 대응해야할수 있다.

위의 3가지 다 전부 우리가 컨트롤 할수 없는 외부 요인이다. 대부분 통제 불가 요소.

기획 변화, 요구사항의 변화에 대해 욕하는 사람일수록 자기 코드가 변화에 대응할수 없도록 만든 개발자이다. 강한 응집성과 약한 의존성을 적용하지 않는 코드.

```javascript
if (case === 1) {
  case1();
} else if (case === 2) {
  case2();
} else if (case === 3) {
  case3();
}

// 함수를 빼서 특정 함수만 수정하면 여파가 줄어든다.
// if와 함수간의 암묵적인 계약관계가 있다. 이 함수를 프로시저로 보고, 리턴값 고려안함
// 상태 공유를 하지 않는다. 기본적인 시그니처에 대한 계약관계가 있다.
// 개별함수만 검사하면 되니까 여파가 줄어든다.
```

각 경우별 변화는 개별 함수만 변경하면된다. 하지만 문제는 경우가 변경될때 즉 case4가 더 생겨서 수정을 해야 하거나 그외 수정이 불가피 할때, 그것에 대한 여파를 검사해야 한다.

if문안의 수정 및 여파는 그안에서만 되는데, 경우 자체가 달라지면 다 체크하고 여파가 미치는지 확인해야 한다.

```javascript
const case1 =_=>{
  //공통부분
  //case1 전용
}

const case2 =_=>{
  //공통부분
  //case2 전용
}

// case1 함수, case2 함수에 공통점이 있을수도 있다. 중복코드가 있는데 각 공통 부분이 제대로 수정을 안하면 작동이 잘못될 수 있다.
// 코드가 중복되었는데, 무사히 수정할수 있는 가능성은 제로다. 수정시에 중복된 코드는 확정 버그를 발생한다고 봐도 된다.
// 중복을 어디까지 인식할수 있는가? 중복은 끊임없이 집착해서 계속 없애줘야 한다.
// 분기 전후에 공통부분을 미리 처리하도록 하는데 스프링에서는 인터셉터가 있다.
```

각 경우별 변화는개별 함수만 변경하면된다. ==> **문제는 경우가 변경될때**

개별 함수 내부에 공통부분이 발생하는 경우 ==> **분기 전후에 공통부분 미리 처리**

제어문에 기본적인 전략이며 코드에 방어적인 기제를 넣기 위해서 이정도는 한다.

객체지향에서는 이것을 어떻게 적용할 것인가?



#### 알고리즘 분화시 객체지향에서 선택할 수 잇는 두가지 방법

1 . 상속위임 (is a)

- 부모가 할일을 한다음에 나머지는 자식에게 맡기는 것
- 내부계약관계를 추상층에서 공통요소를 해결하고 상태를 공유할수 있다.
- 부모에 공통 요소 해결 결과를 상태를 남기면 자식이 그것을 가지고 가서 이어서 처리할수 있다.
- 공통 요소 해결 + 상태 공유 일때 상속 위임이 유리하다!

2 . 소유 위임 (has a)

- 외부 계약 관계로 각각 독립적인 문제를 해결하며 메세지를 주고 받는 것으로 문제를 해결한다.
- 소유 위임은 외부계약 관계라서 깔끔하고 프로토콜로만 통신한다. 
- 문제를 독립적으로 해결한다. 메세지를 주고 받는다. 
- 상태도 메세지 안에 주고 받으며 상태를 공유하지 않는다.



GoF 패턴에서는 대부분의 문제를 소유 위임으로 해결하려 한다. 상속 위임일 경우 부모를 하나만 가질수 있다는 제약 사항이 있어서 상속위임으로 문제 하나만 해결하고 다른 건 해결 못할 객체가 양산될 수 있다. 하지만, 소유위임의 객체로 막상 보면 문제를 한번에 하나만 해결하긴 한다. 실무에서는 소유 위임을 이용하면 다양한 객체를 소유해서 여러 문제를 해결할수 있다. 하지만 그러면 단일 책임 역할 모델에 위배될 수 있다.

따라서 상속위임, 소유위임이 그렇게 배타적인건 아니다. 상속 위임은 변화율에 대응하기 쉽고, 소유위임은 수정하는 역할 모델에 대응하기가 좋다.역할이 확실하게 나뉘어져 있어서 남남이면 소유 위임, 서로 의존성이 있는 애들은 상속위임을 쓴다.



```javascript
/************************************ 상속 위임 *********************************/
// service는 패치를 내장해서 원하는 json을 받아 주는 녀석이다.
const Service = class {
  constructor(baseUrl){
    this._baseUrl = baseUrl;
  }
  // 템플릿 메서드
  async getData(type) {
    // 공통 부분을 각 case 별로 할당하지 않고 빼놓았다.
    
    /************* 정의시점 공통부분 ************/
    /**/ const response = await fetch(
    /**/   this._baseurl + '/' + type, {method:"GET", body:""}
    /**/ );
    /**/ this._json = await response.json();
    /******************************************/
    
    // 타입에 대한 지식들을 부모가 가지고 있다.
    // Service 정의 시점이 아닌, 그 이후에 만들어진 것을 쓰기 때문에 실행시점이다.
    // 자기가 정의될때는 그 내용이 결정되지 않았으므로.
    
    // 서비스 정의 시점의 메소드를 쓰는게 아니라 그 이후에 만들어진
    // 자식의 코드가 실행되므로 실행시점 위임 부분이라한다.
    
    switch(type) {
      /************** 실행시점 위임부분 ************/  
      /**/ case 'member' : return this._checkMember(); // 상태공유 -> 인자 안 넘김
      /**/ case 'notice' : return this._checkNotice();
      /*******************************************/
      default : throw 'invalid type';
    }
  }
  _checkMember() {throw 'must overrided';}
  _checkNotice() {throw 'must overrided';} 
}

const Service1 = class extends Service {
  /********************* 실행시점에 위임된 알고리즘 ****************/
  /**/ _checkMember() {...}	// override
  /**/ _checkNotice() {...}	// override
  /**************************************************************/
}
```

Service가 정의될때 정의된 것이 아니라 그 이후, 자식

실행시점을 위임된 알고리즘을 자식이 가지고 있다.

자식은 실행시점에 부모의 알고리즘의 일부를 소유하기 위해서 이다.

알고리즘의 변화를 자식객체를 생성해서 몰수 있다.

아까는 함수의 내용을 변경했었는데, 이제는 함수의 내용을 바꾸지 않고 바뀐 함수만큼 객체를 만들어서 대응할 수 있다.

if로 개발 함수 호출할때와 다르게 이제는 기존 코드를 건드리지 않고, 외부에 자식을 새롭게 만들면 된다. 그 의미는 코드를 검증한 것들은 검증할 필요가 없게 된다. 변경될 일이 없으니까.

이것을 템플릿 메서드 패턴이라고 한다. 템플릿 메서드 패턴의 특징은 상속위임을 통해서 문제를 해결한다. 알고리즘의 분화, 변화에 대한 문제를.. 이패턴을 사용하면 상속된 자식을 늘림으로서 알고리즘의 변화에 대응할 수 있다. 나머지 변화되지 않는 부분을 건드리지 않고 해결할 수 있게 된다. 디자인 패턴은 수정시에 다른 부분을 건드리지 않고 그 부분만 건드리고 하지? 에 대한 것이다.

우리가 변화율, 역할 모델 관리하는 것과 같은 목표를 디자인 패턴도 같이 가지고 있다. 따라서 객체 지향 설계 배울때 디자인 패턴과 같이 공부하는게 좋다.

템플릿 메소드 패턴의 핵심인 템플릿 메서드가 getData이다. 템플릿 메소드는 공통부분을 처리하는 부분이 있고 실행시점의 위임한 부분이 조합되어서 하나의 알고리즘을 처리한다. 이것을 템플릿이라고 부르고, 템플릿의 구성만 자식이 끼어드는 형태가 되어서 템플릿 메서드라고 부르고, 전체를 템플릿 메서드 패턴이라고 한다.

나머지 디자인 패턴들은 소유위임을 지향하는데, 템플릿 메서드만이 상속위임을 지향하고 있다.

GoF는 상속위임이 없는 이유는 객체지향 설계에 익숙한 사람들이 만들어서 상속은 나머지 객체에 다 쓰고 있기 때문에, 그것을 가정하고 나머지 객체 문제를 해결하는 방식을 가르치기 때문에 없는 것이다.



```html
/* 정의 시점 */
<script src="Service.js"></script>
<script src="Service1.js"></script>
<script src="Service2.js"></script>


<script>
  /* 실행 시점 */
  const service = new Service1('/site1');	// service1.js를 본다.
  service.getData('member').then(console.log);
  
  const service = new Service2('/site1');	// service2.js를 본다.
  service.getData('member').then(console.log);
  
  // 정의 시점의 코드를 수정하지 않았는데, 실행시점에서 service의 알고리즘을 교체를 부분적으로 할 수 있다.

</script>
```



## 소유위임

자식이 없으므로 자신의 알고리즘의 일부를 받아줄 애를 직접 외부에서 계약을 맺어야 한다.



```javascript
const Service = class {
  constructor(baseUrl, checker) {	// checker라는 계약을 맺는다.
    this._baseUrl = baseUrl;
    if(!(checker instanceof Checker)) throw "invalid checker";
    this._checker = checker;	// 실행시점 위임객체
  }
  async getData(type) {
    const response = await fetch(`${this._baseurl}/${type}`, {method:"GET", body:""});
    const json = await response.json();
    switch(type) {
      // 실행 시점 외부 계약을 통한 위임
      case "member" : return this._checker.member(json); 	// 계약자에게 위임
      case "notice" : return this._check.notice(json);		// 외부계약, 인자로 값줌.
      default : throw "invalid type";
    }
  };
}

// 전략 객체
// 외부계약자이며, member와 notice라는 체커(알고리즘)를 공급
// 전략 객체를 공급해주면, 외부계약을 통해서 알고리즘의 일부를 그 객체에 위임해준다.
const Checker = class {	// 상속관계에 비해서 독립적이다.
  member(json){}
  notice(json){}
}
```



```html
// 실행시점 위임 Runtime Delegation

// 정의 시점
<script src="Service.js"></script>
<script src="Checker.js"></script>	// 외부계약자
<script src="Checker1.js"></script>	// Service와 무관하게 외부계약자의 상속받음.	
<script src="Checker2.js"></script>

// 실행시점
<script>
  const service1 = new Service('/site1', new Checker1());	// 외부 전략 객체를 입력
  service1.getData('member').then(console.log);
  
  const service2 = new Service('/site1', new Checker2());	// 외부 계약자만 변경
  service2.getData('member').then(console.log);
  
  // 실행시점의 코드가 공급자를 제외하고 동일하다. 따라서 공급자의 변경만으로도 작동이 달라진다는 것이다.
</script>
```

디자인 패턴을 쓰는 궁극적 목적중에 하나는 호스트코드가 똑같은 로직을 쓰고 있는데도, 무엇이 관계에 개입했느냐에 따라서 결과가 달라진다는 것이다. 공급자만 바꾸면 다른 코드를 바꾸지 않아도 결과를 바꿔줄수 있다느 ㄴ것이다. 나머지 코드의 여파가 최소화 시키는 것이 전략 패턴을 쓰는 목적이다.



#### 각 경우별 변화는 개별 함수만 변경하면 된다. "문제는 경우의수가 변경될때"

이럴때는 **포괄적 위임**을 쓸수밖에 없다.

예를들어 아까의 코드에서 서비스 밑에 분화된 객체가  서비스의 타입에 대한 지식 조차도 자식에게 포괄적으로 위임하는 것이다.

```javascript
/************************** 상속위임 에서의 포괄적 위임 **************************/
const Service = class {
  constructor(baseUrl) {
    this._baseUrl = baseUrl;
  }
  async getData(type) {
 	const response = await fetch(`${this._baseurl}/${type}`, {method:"GET", body:""});
    const json = await response.json();
    /****** type에 대한 권한을 포기하고 실행시점 포괄위임 ******/
    /**/ this._type = type; 	// 타입을 상태 공유로 위임한다.
    /**/ return this._check();
    
  }
  _check() {throw 'must overrided';}
};

const Service1 = class extends Service {
  _check() {
    /**** 코드가 구상층(자식층)으로 이전되었을뿐 정의시점 코드에 경우는 고정된다. ****/
    /**/ switch(this._type) {
    /**/   case ...
    /**/   case ...
    /**/   ....
    }
  }
}
```

자식에게는 부담이 늘었다. 타입에 대한 지식을 가져야 하므로.

지식을 자식으로 이사했을 때문이지 지식이 필요성이 달라지지 않았다.

그래서 오히려 더 악화되었다. 왜냐하면 중복방지를 위해서 한군데만 있으면되었는데, 이제는 자식을 만들때마다 복사해서 또 가야하기 때문이다. 복사되면 무조건 에러라고, 복붙이 생기면 무조건 버그라고 봐야 한다. 왜냐하면 수정이 발생하면 무너질수 있기 때문이다.

코드가 자식층으로 이전되었을뿐이지 코드 자체는 달라지는게 없이 다 받아야 한다. 그 지식에 대한..

그래서 템플릿 메서드 패턴으로 쓰면 포괄적 위임이 되면서 망가진다. 템플릿 메서드가 알고리즘 분화에 대응은 할수 있지만 경우의 수에는 대응하지 못한다.  따라서 이 패턴은 경우가 확정되어있을때만 쓸수 있다. 즉 템플릿이 확정되었을때만 쓸수 잇는 것이다.

포괄적 위임을 쓰는 순간 이미 다 위임해 버리기 때문에 더이상 템플릿이라고 할수도 없다.



```javascript
/************************** 소유위임 에서의 포괄적 위임 **************************/
const Service = class {
  constructor(baseUrl) {
    this._baseUrl = baseUrl;
    this._checkers = new Map();	// 라우팅 테이블
  }
  addChecker(type, checker) {
    if(!(checker instanceof Checker)) throw 'invalid checker';
    this._checkers.set(type, checker);
  }
  async getData(type) {
    if(!this._checkers.has(type)) throw 'no checker';
    const response = await fetch(`${this._baseurl}/${type}`, {method:"GET", body:""});
    const json = await response.json();
    this._checkers.get(type).check(json);	// 실행시점 전략객체 위임
  }
}

const Checker = class {			// 간이 인터페이스
  constructor(f) {this._f = f;}
  check(json) {this._f(json);}
}
```

케이스가 마음대로 늘어난다는 것은? 케이스가 마음대로 늘어날수 잇다는 것은 케이스가 정해져 있지 않다는 것이다. 이것은 케이스가 배열, 오브젝트 등의 저장할수 있는 형태로 되어 있다는 것이다. 케이스를 늘리고, 줄일수 있다는 것이다. 그래서 케이스를 적재할수 있는 MAP() 을 만들었다.

이제 케이스를 적재한다. 그래서 케이스에 해당하는 타입과 체커를 쌍으로 적재하게 된다. 체커가 알고리즘을 처리하는 체커 타입인지는 외부계약을 맺어야 한다. 기본적으로 전략 패턴이니까 외부계약을 맺고 있다.

검사해서 맞으면 맵에다가 해당 케이스를 처리할 해당 체커를 넣어준다. addChecker를 얼마나 호출했느냐에 따라서 처리할 케이스 경우의 수가 달라진다. 데이터는 해당 맵에 처리할 체커가 있는지를 실행시점에 평가 한다. 즉 getData 할때만 해당 체커가 있으면 되니까 그때 평가하는 것이다.





```html
<!-- 실행시점 위임 Runtime Delegation -->

<!-- 정의시점 -->
<script src="Service.js"></script>
<script src="Checker.js"></script>

<!-- 실행시점시점 -->
<script>
  const service = new Service('/site1');
  const M =V=>{throw `${v} is mandatory`;}
  
  /************** 실행시점에 경우가 추가된다. ********************/
  /**/ service.addChecker('member', new Checker(
  /**/ 	({name, nick, email=M('email'), id=M('id')})=>
  /**/    	({id, nick, name, email})
  /**/ ));
  /**/ 
  /**/ service.addChecker('admin', new Checker(
  /**/ 	({name, role=M('role'), email=M('email'), id=M('id')})=>
  /**/   	({id, rold, name, email})
  /**/ ));
  /************************************************************/
  
  service.getData('member').then(console.log);
  service.getData('admin').then(console.log);
</script>
```

