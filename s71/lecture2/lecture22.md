
GOF 디자인 패턴의 분류는 이미 객체지향 설계에 숙달한 사람을 대상으로 한다. 객체의 협력망을 만드는데 숙달된 사람을 말한다. 이 수업의 수준에서는 객체 역할 모델을 가르치면서 DP를 가르쳐 나갈 것이다.

객체지향 설계를 학습할 수 있는 분류

1. 다형성 : OOP의 근간이 되는 원리, 대체가능성이라고 불리는 자식대신 부모 형을 쓸수 있다는 것이다. 내적동질성이라는 개념도 있다.
2. 캡슐화 : 어떠한 복잡한 기능을 직접 외부에 노출하지 않고, 표현하고 싶은 기능을 노출한다. 하지만 은닉은 직접적인 노출을 피하는 것이다. 행동을 추상화해서 노출하는게 캡슐화이다.
3. 객체간 관계 : 객체가 망을 형성할때 관계를 맺게 된다. 부모 자식 관계, 계약 관계, 소유 관계, 
4. 변화율 : 어떤 것은 자주 바뀌고, 어떤 것은 자주 안바뀌는 부분은 부모, 자식 관계로 분류하는 경우가 많다. 같은 카테고리내에서 시간에 대한 변화를 담당하는 데 많이 쓰이는 전략이 부모 자식 간의 전략이다. 
5. 역할모델 : 수정하는 건수 별로 격리시키는 것을 말한다. 예를들어 데이터와 렌더러와 같은 분리이다. 역할 모델에 따른 분리이다. 수정 건수에 대해서 변화가 해당 부분만 수정될수 있도록 하는 것.

객체 설계를 배우기 힘든 이유는 변화율과 역할 모델을 동시에 반영한 설계를 만들기 때문이다. 디자인 패턴을 배울때 주요한 카테고리는 이러하다. 여기에 없는 카테고리 하나가 있는데, 바로 알고리즘이다. 객체지향설계에서 문제 해결시, 역할을 가진 객체 망으로 문제를 해결하지만, 근본적인 문제는 알고리즘이다. 컴퓨터는 어차피 알고리즘으로 문제를 푼다. 

우리가 해결해야 할 근본적인 문제는 알고리즘이고 이것은 상태와 분기에 대한 내용이다. 가장 기초적인 알고리즘을 해결하는 패턴중에 2가지가 있다.  우리가 알고있는 제어문은 조건문과 반복문이 있다. 우리는 조건문을 객체의 관계로 해결한다.

기존 제어문 기반의 알고리즘이 갖는 문제. " 수정하면 전체가 컴파일 된다. "

정의시점 : 함수를 만드는 것

실행시점 : 함수를 호출하는 것

정의시점과 실행시점은 상대적인 개념이다. 브라우저도 OS입장에서는 실행시점의 어플리케이션이다. OS는 정의시점의 객체라고 보면된다. 브라우저 입장에서는, 자바스크립트는 실행시점에 실행되는 것이다. 정의시점에서는 그 이후가 실행시점으로, 실행시점에서는 자기 이전은 정의시점으로 볼수 있다.

구구단을 1단만 나오도록 만들었는데, 10단까지 나오도록 하려면, 코드를 고쳐야한다. 그 코드와 관련된 테스트, 의존 하는 코드들의 여파 등을 다 확인해봐야 한다. 그래서 가장 좋은 것은 안 고치는게 제일좋다. 격리 이론자체가 최대한 수정이 없도록 하고 정말 필요한 부분만고칠려고 하는ㄱ ㅓㅅ이다. 

하지만 제어문은 그것에 위배된다. 코드를 고치지 않고서는 원하는 수정을 할수가 없으므로.

제어문 기반의 알고리즘은 나쁘다. 그렇다면 알고리즘이 변화한 부분만 수정하고 나머지는 건드리고 싶지 않다면? ==> 최대한 개별 알고리즘을 함수로 분리한다.



#### 알고리즘이 변화하는 이유?

1. 비즈니스 모델 변화 : 비즈니스
2. 연관 라이브러리 변화 : 외부 API 의존하는 이상 통제 불가
3. 호스트측 변화 : 사용하는 측의 변화, API서버를 쓸려고 하는데 브라우저에서 쓰는 것으로 확정되었을때 동일 도메인 정책에 대응해야할수 있다.

위의 3가지 다 전부 우리가 컨트롤 할수 없는 외부 요인이다. 대부분 통제 불가 요소.

기획 변화, 요구사항의 변화에 대해 욕하는 사람일수록 자기 코드가 변화에 대응할수 없도록 만든 개발자이다. 강한 응집성과 약한 의존성을 적용하지 않는 코드.

```javascript
if (case === 1) {
  case1();
} else if (case === 2) {
  case2();
} else if (case === 3) {
  case3();
}

// 함수를 빼서 특정 함수만 수정하면 여파가 줄어든다.
// if와 함수간의 암묵적인 계약관계가 있다. 이 함수를 프로시저로 보고, 리턴값 고려안함
// 상태 공유를 하지 않는다. 기본적인 시그니처에 대한 계약관계가 있다.
// 개별함수만 검사하면 되니까 여파가 줄어든다.
```

각 경우별 변화는 개별 함수만 변경하면된다. 하지만 문제는 경우가 변경될때 즉 case4가 더 생겨서 수정을 해야 하거나 그외 수정이 불가피 할때, 그것에 대한 여파를 검사해야 한다.

if문안의 수정 및 여파는 그안에서만 되는데, 경우 자체가 달라지면 다 체크하고 여파가 미치는지 확인해야 한다.

```javascript
const case1 =_=>{
  //공통부분
  //case1 전용
}

const case2 =_=>{
  //공통부분
  //case2 전용
}

// case1 함수, case2 함수에 공통점이 있을수도 있다. 중복코드가 있는데 각 공통 부분이 제대로 수정을 안하면 작동이 잘못될 수 있다.
// 코드가 중복되었는데, 무사히 수정할수 있는 가능성은 제로다. 수정시에 중복된 코드는 확정 버그를 발생한다고 봐도 된다.
// 중복을 어디까지 인식할수 있는가? 중복은 끊임없이 집착해서 계속 없애줘야 한다.
// 분기 전후에 공통부분을 미리 처리하도록 하는데 스프링에서는 인터셉터가 있다.
```

각 경우별 변화는개별 함수만 변경하면된다. ==> **문제는 경우가 변경될때**

개별 함수 내부에 공통부분이 발생하는 경우 ==> **분기 전후에 공통부분 미리 처리**

제어문에 기본적인 전략이며 코드에 방어적인 기제를 넣기 위해서 이정도는 한다.

객체지향에서는 이것을 어떻게 적용할 것인가?



#### 알고리즘 분화시 객체지향에서 선택할 수 잇는 두가지 방법

1 . 상속위임 (is a)

- 부모가 할일을 한다음에 나머지는 자식에게 맡기는 것
- 내부계약관계를 추상층에서 공통요소를 해결하고 상태를 공유할수 있다.
- 부모에 공통 요소 해결 결과를 상태를 남기면 자식이 그것을 가지고 가서 이어서 처리할수 있다.
- 공통 요소 해결 + 상태 공유 일때 상속 위임이 유리하다!

2 . 소유 위임 (has a)

- 외부 계약 관계로 각각 독립적인 문제를 해결하며 메세지를 주고 받는 것으로 문제를 해결한다.
- 소유 위임은 외부계약 관계라서 깔끔하고 프로토콜로만 통신한다. 
- 문제를 독립적으로 해결한다. 메세지를 주고 받는다. 
- 상태도 메세지 안에 주고 받으며 상태를 공유하지 않는다.



GoF 패턴에서는 대부분의 문제를 소유 위임으로 해결하려 한다. 상속 위임일 경우 부모를 하나만 가질수 있다는 제약 사항이 있어서 상속위임으로 문제 하나만 해결하고 다른 건 해결 못할 객체가 양산될 수 있다. 하지만, 소유위임의 객체로 막상 보면 문제를 한번에 하나만 해결하긴 한다. 실무에서는 소유 위임을 이용하면 다양한 객체를 소유해서 여러 문제를 해결할수 있다. 하지만 그러면 단일 책임 역할 모델에 위배될 수 있다.

따라서 상속위임, 소유위임이 그렇게 배타적인건 아니다. 상속 위임은 변화율에 대응하기 쉽고, 소유위임은 수정하는 역할 모델에 대응하기가 좋다.역할이 확실하게 나뉘어져 있어서 남남이면 소유 위임, 서로 의존성이 있는 애들은 상속위임을 쓴다.



```javascript
/************************************ 상속 위임 *********************************/
// service는 패치를 내장해서 원하는 json을 받아 주는 녀석이다.
const Service = class {
  constructor(baseUrl){
    this._baseUrl = baseUrl;
  }
  // 템플릿 메서드
  async getData(type) {
    // 공통 부분을 각 case 별로 할당하지 않고 빼놓았다.
    
    /************* 정의시점 공통부분 ************/
    /**/ const response = await fetch(
    /**/   this._baseurl + '/' + type, {method:"GET", body:""}
    /**/ );
    /**/ this._json = await response.json();
    /******************************************/
    
    // 타입에 대한 지식들을 부모가 가지고 있다.
    // Service 정의 시점이 아닌, 그 이후에 만들어진 것을 쓰기 때문에 실행시점이다.
    // 자기가 정의될때는 그 내용이 결정되지 않았으므로.
    
    // 서비스 정의 시점의 메소드를 쓰는게 아니라 그 이후에 만들어진
    // 자식의 코드가 실행되므로 실행시점 위임 부분이라한다.
    
    switch(type) {
      /************** 실행시점 위임부분 ************/  
      /**/ case 'member' : return this._checkMember(); // 상태공유 -> 인자 안 넘김
      /**/ case 'notice' : return this._checkNotice();
      /*******************************************/
      default : throw 'invalid type';
    }
  }
  _checkMember() {throw 'must overrided';}
  _checkNotice() {throw 'must overrided';} 
}

const Service1 = class extends Service {
  /********************* 실행시점에 위임된 알고리즘 ****************/
  /**/ _checkMember() {...}	// override
  /**/ _checkNotice() {...}	// override
  /**************************************************************/
}
```

Service가 정의될때 정의된 것이 아니라 그 이후, 자식

실행시점을 위임된 알고리즘을 자식이 가지고 있다.

자식은 실행시점에 부모의 알고리즘의 일부를 소유하기 위해서 이다.

알고리즘의 변화를 자식객체를 생성해서 몰수 있다.

아까는 함수의 내용을 변경했었는데, 이제는 함수의 내용을 바꾸지 않고 바뀐 함수만큼 객체를 만들어서 대응할 수 있다.

if로 개발 함수 호출할때와 다르게 이제는 기존 코드를 건드리지 않고, 외부에 자식을 새롭게 만들면 된다. 그 의미는 코드를 검증한 것들은 검증할 필요가 없게 된다. 변경될 일이 없으니까.

이것을 템플릿 메서드 패턴이라고 한다. 템플릿 메서드 패턴의 특징은 상속위임을 통해서 문제를 해결한다. 알고리즘의 분화, 변화에 대한 문제를.. 이패턴을 사용하면 상속된 자식을 늘림으로서 알고리즘의 변화에 대응할 수 있다. 나머지 변화되지 않는 부분을 건드리지 않고 해결할 수 있게 된다. 디자인 패턴은 수정시에 다른 부분을 건드리지 않고 그 부분만 건드리고 하지? 에 대한 것이다.

우리가 변화율, 역할 모델 관리하는 것과 같은 목표를 디자인 패턴도 같이 가지고 있다. 따라서 객체 지향 설계 배울때 디자인 패턴과 같이 공부하는게 좋다.

템플릿 메소드 패턴의 핵심인 템플릿 메서드가 getData이다. 템플릿 메소드는 공통부분을 처리하는 부분이 있고 실행시점의 위임한 부분이 조합되어서 하나의 알고리즘을 처리한다. 이것을 템플릿이라고 부르고, 템플릿의 구성만 자식이 끼어드는 형태가 되어서 템플릿 메서드라고 부르고, 전체를 템플릿 메서드 패턴이라고 한다.

나머지 디자인 패턴들은 소유위임을 지향하는데, 템플릿 메서드만이 상속위임을 지향하고 있다.

GoF는 상속위임이 없는 이유는 객체지향 설계에 익숙한 사람들이 만들어서 상속은 나머지 객체에 다 쓰고 있기 때문에, 그것을 가정하고 나머지 객체 문제를 해결하는 방식을 가르치기 때문에 없는 것이다.



```html
/* 정의 시점 */
<script src="Service.js"></script>
<script src="Service1.js"></script>
<script src="Service2.js"></script>


<script>
  /* 실행 시점 */
  const service = new Service1('/site1');	// service1.js를 본다.
  service.getData('member').then(console.log);
  
  const service = new Service2('/site1');	// service2.js를 본다.
  service.getData('member').then(console.log);
  
  // 정의 시점의 코드를 수정하지 않았는데, 실행시점에서 service의 알고리즘을 교체를 부분적으로 할 수 있다.

</script>
```



## 소유위임

자식이 없으므로 자신의 알고리즘의 일부를 받아줄 애를 직접 외부에서 계약을 맺어야 한다.



```javascript
const Service = class {
  constructor(baseUrl, checker) {	// checker라는 계약을 맺는다.
    this._baseUrl = baseUrl;
    if(!(checker instanceof Checker)) throw "invalid checker";
    this._checker = checker;	// 실행시점 위임객체
  }
  async getData(type) {
    const response = await fetch(`${this._baseurl}/${type}`, {method:"GET", body:""});
    const json = await response.json();
    switch(type) {
      // 실행 시점 외부 계약을 통한 위임
      case "member" : return this._checker.member(json); 	// 계약자에게 위임
      case "notice" : return this._check.notice(json);		// 외부계약, 인자로 값줌.
      default : throw "invalid type";
    }
  };
}

// 전략 객체
// 외부계약자이며, member와 notice라는 체커(알고리즘)를 공급
// 전략 객체를 공급해주면, 외부계약을 통해서 알고리즘의 일부를 그 객체에 위임해준다.
const Checker = class {	// 상속관계에 비해서 독립적이다.
  member(json){}
  notice(json){}
}
```



```html
// 실행시점 위임 Runtime Delegation

// 정의 시점
<script src="Service.js"></script>
<script src="Checker.js"></script>	// 외부계약자
<script src="Checker1.js"></script>	// Service와 무관하게 외부계약자의 상속받음.	
<script src="Checker2.js"></script>

// 실행시점
<script>
  const service1 = new Service('/site1', new Checker1());	// 외부 전략 객체를 입력
  service1.getData('member').then(console.log);
  
  const service2 = new Service('/site1', new Checker2());	// 외부 계약자만 변경
  service2.getData('member').then(console.log);
  
  // 실행시점의 코드가 공급자를 제외하고 동일하다. 따라서 공급자의 변경만으로도 작동이 달라진다는 것이다.
</script>
```

디자인 패턴을 쓰는 궁극적 목적중에 하나는 호스트코드가 똑같은 로직을 쓰고 있는데도, 무엇이 관계에 개입했느냐에 따라서 결과가 달라진다는 것이다. 공급자만 바꾸면 다른 코드를 바꾸지 않아도 결과를 바꿔줄수 있다느 ㄴ것이다. 나머지 코드의 여파가 최소화 시키는 것이 전략 패턴을 쓰는 목적이다.



#### 각 경우별 변화는 개별 함수만 변경하면 된다. "문제는 경우의수가 변경될때"

이럴때는 **포괄적 위임**을 쓸수밖에 없다.

예를들어 아까의 코드에서 서비스 밑에 분화된 객체가  서비스의 타입에 대한 지식 조차도 자식에게 포괄적으로 위임하는 것이다.

```javascript
/************************** 상속위임 에서의 포괄적 위임 **************************/
const Service = class {
  constructor(baseUrl) {
    this._baseUrl = baseUrl;
  }
  async getData(type) {
 	const response = await fetch(`${this._baseurl}/${type}`, {method:"GET", body:""});
    const json = await response.json();
    /****** type에 대한 권한을 포기하고 실행시점 포괄위임 ******/
    /**/ this._type = type; 	// 타입을 상태 공유로 위임한다.
    /**/ return this._check();
    
  }
  _check() {throw 'must overrided';}
};

const Service1 = class extends Service {
  _check() {
    /**** 코드가 구상층(자식층)으로 이전되었을뿐 정의시점 코드에 경우는 고정된다. ****/
    /**/ switch(this._type) {
    /**/   case ...
    /**/   case ...
    /**/   ....
    }
  }
}
```

자식에게는 부담이 늘었다. 타입에 대한 지식을 가져야 하므로.

지식을 자식으로 이사했을 때문이지 지식이 필요성이 달라지지 않았다.

그래서 오히려 더 악화되었다. 왜냐하면 중복방지를 위해서 한군데만 있으면되었는데, 이제는 자식을 만들때마다 복사해서 또 가야하기 때문이다. 복사되면 무조건 에러라고, 복붙이 생기면 무조건 버그라고 봐야 한다. 왜냐하면 수정이 발생하면 무너질수 있기 때문이다.

코드가 자식층으로 이전되었을뿐이지 코드 자체는 달라지는게 없이 다 받아야 한다. 그 지식에 대한..

그래서 템플릿 메서드 패턴으로 쓰면 포괄적 위임이 되면서 망가진다. 템플릿 메서드가 알고리즘 분화에 대응은 할수 있지만 경우의 수에는 대응하지 못한다.  따라서 이 패턴은 경우가 확정되어있을때만 쓸수 있다. 즉 템플릿이 확정되었을때만 쓸수 잇는 것이다.

포괄적 위임을 쓰는 순간 이미 다 위임해 버리기 때문에 더이상 템플릿이라고 할수도 없다.



```javascript
/************************** 소유위임 에서의 포괄적 위임 **************************/
const Service = class {
  constructor(baseUrl) {
    this._baseUrl = baseUrl;
    this._checkers = new Map();	// 라우팅 테이블
  }
  addChecker(type, checker) {
    if(!(checker instanceof Checker)) throw 'invalid checker';
    this._checkers.set(type, checker);
  }
  async getData(type) {
    if(!this._checkers.has(type)) throw 'no checker';
    const response = await fetch(`${this._baseurl}/${type}`, {method:"GET", body:""});
    const json = await response.json();
    return this._checkers.get(type).check(json);	// 실행시점 전략객체 위임
  }
}

const Checker = class {			// 간이 인터페이스
  constructor(f) {this._f = f;}
  check(json) {this._f(json);}	// arrow일경우 this는 전역, function() 이면 this
}
```

케이스가 마음대로 늘어난다는 것은? 케이스가 마음대로 늘어날수 잇다는 것은 케이스가 정해져 있지 않다는 것이다. 이것은 케이스가 배열, 오브젝트 등의 저장할수 있는 형태로 되어 있다는 것이다. 케이스를 늘리고, 줄일수 있다는 것이다. 그래서 케이스를 적재할수 있는 MAP() 을 만들었다.

이제 케이스를 적재한다. 그래서 케이스에 해당하는 타입과 체커를 쌍으로 적재하게 된다. 체커가 알고리즘을 처리하는 체커 타입인지는 외부계약을 맺어야 한다. 기본적으로 전략 패턴이니까 외부계약을 맺고 있다.

검사해서 맞으면 맵에다가 해당 케이스를 처리할 해당 체커를 넣어준다. addChecker를 얼마나 호출했느냐에 따라서 처리할 케이스 경우의 수가 달라진다. 데이터는 해당 맵에 처리할 체커가 있는지를 실행시점에 평가 한다. 즉 getData 할때만 해당 체커가 있으면 되니까 그때 평가하는 것이다.

정의시점 평가와 실행시점 평가가 중요하다.

notice를 체크하기 전에 addChecker하면 된다.

그래서 이것을 Lazy Check 라고 한다. 우리는 최대한 실행시점에 결정되어야 하는 것은 되도록이면 실행시점에 평가하려고 한다. 실행시점 평가에 따르면 getData 전에만 해당 타입이 있으면 된다. addChecker가 그전에만 호출되면된다. 생성때마다 호출될 필요 없고.

그다음 해당 체커를 읽어와서 체크를 실행하면 된다. 이러면 아예 케이스 가 없어도 된다. 케이스가 동적으로 해결될테니까.

이렇게 케이스를 담는 구조체를 일반적으로 라우팅 테이블이라고 한다. 이게 바로 라우터다. 라우터의 진짜 의미는 동적으로 케이스를 결정할수 있는 구조체이다. 노드 익스프레스에서도 라우터는 URL에 대한 케이스를 런타임에 늘려준다. 라우팅 테이블 작성에서 라우팅 테이블에 있는 케이스로 분기해서 처리하는 행위를 라우팅이라고 부른다. 

라우팅을 통해서 실행시점 전략객체 위임을 하게 되는 것이다. 

공부는 용어를 아는 것이 전부이다. 공부를 하는 이유는 용어를 알기 위함이다. 용어를 익히는 이유는 구체적으로 언어화를 하지 않으면 개념을 발전시키거나 이용하기가 어렵다. 뜬구름으로는 활용도 못하고 이용하기도 어렵다. 용어를 아는 것 만으로도 많은 것이 바뀐다.

공부할때 주의할 것은 전문용어를 이해하고, 전문용어에 대한 개념대로 구조체를 만들수 있고 전문 용어 개념 기반으로 외운 상태에서 추가하거나 활용, 변형하거나 할수 있다.

ES6에서는 익명클래스처럼 만들수 있는 간이 인터페이스 구문을 지원한다. 

인터페이스 구현해서 메서드만 구현하는 그런 패턴

생성자에서 함수를 하나 받고, 외부에 노출되는 인터페이스에서 항상 그 받은 함수를 호출하면 익명 구현하고 유사한 형태로 쓰이게 된다. 많이 씁니다. 체커에 익명 클래스 만드는 것과 비슷한 효과가 일어난다.

아마도 arrow 함수는 자신이 생성될때의 자신이 존재하던 execution context, lexical environment 를 스코프에 담는다.

익명클래스 : 자바에서는 클래스의 객체가 단 한번 사용되는 경우, 또는 상위 클래스나 인터페이스 메서드 하나를 재정의하기 위해 클래스를 선언하는 경우 클래스 선언, 객체 생성, 그 구현(재정의)를 동시에 한다. 그래서 클래스의 이름이 없으며 익명 클래스라고 한다.







```html
<!-- 실행시점 위임 Runtime Delegation -->

<!-- 정의시점 -->
<script src="Service.js"></script>
<script src="Checker.js"></script>

<!-- 실행시점시점 -->
<script>
  const service = new Service('/site1');
  const M =V=>{throw `${v} is mandatory`;}
  
  /************** 실행시점에 경우가 추가된다. ********************/
  /**/ service.addChecker('member', new Checker(
  /**/ 	({name, nick, email=M('email'), id=M('id')})=>
  /**/    	({id, nick, name, email})
  /**/ ));
  /**/ 
  /**/ service.addChecker('admin', new Checker(
  /**/ 	({name, role=M('role'), email=M('email'), id=M('id')})=>
  /**/   	({id, rold, name, email})	
  /**/ ));
  /************************************************************/
  
  service.getData('member').then(console.log);
  service.getData('admin').then(console.log);
</script>
```



이전에는 `const service1 = new Service('/site1', new Checker1());` 처럼 전략 객체를 받았지만, 지금은 `const service = new Service('/site1');`  와 같이 받지 않는다. 왜냐면 addChecker 하니까, 즉 케이스 자체를 런타임에 만들 것이니까. 

도우미 함수를 하나 만들었다.  무조건 throw 하는 함수로, 필수 인자를 설정하기 위해서 만들었다. required, mandatory 는 필수라는 의미이다.

addChecker에서 동적으로 케이스를 추가해 준다. 정의시점에서 대응하지 않고 실행시점에서 대응하며 유연하게 케이스를 변경할수 있게 되었다. 두번째는 checker 즉 간이 인터페이스는 마커인터페이스라고 한다. 별로 하는일이 없지만, 계약관계의 checker로 인식되는게 중요하다. checker로 인식되기 위해서 그 함수를 감싼거나 마찬가지라서 마커 인터페이스라고 하는 것이다 .계약관계를 성립하게 하기 위해서 클래스를 만들었다. 함수만 넘기면 계약관계를 만들수 없기 때문에 함수를 감싸서 형을 만들어야지 계약을 시킬수 잇기 때문에 마킹한다고 마커 인터페이스라고 한다.

```javascript
({name, role=M('role'), email=M('email'), id=M('id')})=>({id, rold, name, email})
```

그냥 `{ }` 을 쓰면 함수의 블록이 되어버리기 때문에 `( )` 를 사용했다. ES6 객체 리터럴에서는 변수와 키이름이 일치하면 한번만 쓸수 있다. ES6에서는 spread parameter 기능이 잇어 해체가 변수 정의 뿐 아니라 함수의 인자도 해체해서 받을수 있으며 함수의 기본값이 설정이 가능하다. 기본값에는 값으로 인식할수 잇는건 전부 올수 있다. 값으로 인식할수 있는 건 식이다. 값식, 연산식, 호출식이 올수 있다. 함수 호출도 값으로 작동할수 있다.

여기서 name 은 optional value 이지만, role, email, id는 없으면 throw 하므로 필수 값이 된다. ES6에서는 객체 리터럴의 파싱순서가 정의되었다. 왼쪽 -> 오른쪽으로 순차적으로 해석된다. 기본값 인자들은 기본값이 없는 인자들보다 뒤에 있어야 한다.

2가지 체크를 만들었으니 getData를 써도 잘 처리 한다. 이것을 처리할 라우팅 테이블에 라우터2개가 있으니까. 조건이지만, 라우팅 테이블에 등록된 조건들을 기본적으로 라우터라고 부른다.

전략패턴이 라우터랑 결합하니까 강력하지만, 문제가 있다. 



#### 기초 수업

참조와 값

참조 : 메모리의 주소를 알고 기억한다.  참조의 특징은 실제 메모리는 하나가 만들어졌는데 그것을 아는 애들이 엄청 많은 것이다.

값 : 매번 복사되는 녀석이다.

값과 참조는 어떻게 해서 만들어지는 것일까? 그냥 언어가 정한다. 

자바스크립트는 문자열을 값으로 보는 것, C++는 캐릭터형은 값, 문자열은 객체로 본다. 스크립트 언어는 보다 넓은 범위의 값을 가지고 있다. 보다 로우 레벨일 수록 바이트 로 치환할수 있는 애들만 값이 되고 그외에는 참조가 되곤 한다.

값은 다른애한테 할당하면 복사되고, 참조는 주소가 복사된다.

일반적으로 참조는 주소만 가지고 있기 때문에 경계를 넘는 것에 실패한다. 대표적으로 클라이언트와 서버사이. 따라서 이런 것은 참조를 값으로 바꿔야 넘길수 있다. 이런 과정이 일반적으로 일어나는 이유는 참조값이 경계면을 넘을수 없기 때문이다. 윈도우 포스트 메세지, 웹워커도 참조값 못 넘긴다. 쿠기, 로컬 스토리지 도 경계면을 넘어가지 못한다. 경계면을 넘길려면 값으로 바꿔서 집어넣고 다시 값에서 참조객체로 환원시키는 과정이 필요하다. (아마 직렬화)

경계면을 넘어갈때, 값으로 환원될때 문제가 되는 참조객체는 무엇인가? 

1 . 아주 큰거 (JS 문자 한계 2기가, 환원했는데 3기가면 값으로 넘길 방법이 없다. 숫자가 64비트 넘긴다. 뭐 이런 것들)

2 . 네이티브 객체, (화면의 DIV를 로컬 스토리지에 안됨..  네이티브 객체는 원래 환원이 되지 않는다.)

참조는 

```javascript
let a = {v: 3};
let b = a;
a = {v:5}
b.v	// 3
```

자바스크립트는 연결된 포인터가 없기 때문에 각각 따로 논다. 한번 할당될 뿐이지 참조한 포인터의 변화를 추적하지는 않고 a,b의 연결이 끊어진다. 연결된 포인터가 있다. 바로 htmlcollection 이다.

이러한 코드가 문제가 될수 있는 것은 코드의 의도와 다르게 작동할수 있기 때문이다. 컴퓨터 언어도 사람이 만든 것이다. 그래서 의도가 담길 수 있다. 하지만 이 코드에서는 의도와는 다르게 작동되는 것이다. 연결된 포인터가 없으니까 a 만 믿던 b는 a가 배신하면 다르게 작동되어 버린다. 

참조는 배신을 때릴수 있다. 위의 코드는 a와 b의 계약이 있다. a가 가리키고 있는 것을 b도 가리키는 계약이 있는데 , a가 다른 것을 가리키지만 b는 옛날 것을 계속 가리키고 있는 것이다. 옛날것은 없애버릴려고 하는데 말이다. 심각한 문제가 될수 있다. 이런 문제를 어떻게 할 것인가?

해결 못한다.

그래서 우리는 a가 행동할때 참조를 바꾸면 안된다는 것을 확정 사실로 받아들여야 한다. 그래서 처음부터 a는 참조를 갈아타지 않고 자기가 하고 싶은 일은 변경해야 하니까 이렇게 한다.

```javascript
let a = {
  v: {v: 3}
}
let b = a;
a.v = {v:5}
b.v.v	// 5
```

a가 v.v를 변경했기 때문에 	b는 여전히 a가 가리키는 것과 동일한 대상을 참조하는 것이다. 이것이 바로 참조의 참조라고 부른다. 이 원리는 링크드 리스트, 인터페이스와 구상체, 부모와 자식 등이 이러한 원리를 사용한다.

```javascript
const Parent = class {
  method() {
    console.log("Parent");
  }
}

const Child = class extends Parent {
  method() {
    console.log("Child");
  }
}

(new Parent).method();	// 인자 없는 클래스는 괄호 생략해서 만들수 있다.
(new Child).method();
```

객체지향에서 부모객체를 만들면 부모객체가 만들어진 참조를 잡으려고 할 것이다. 이 참조가 가리키고 있는 메소드라는 이름이 바로 함수 객체 의 참조 포인터의 이름이다. 이 이름이 가리키고 잇는 것이 함수의 위치이다.

```javascript
const Parent = class {
  method() {this._method();}
  _method() {console.log("parent");}
}

const Child = class extends Parent {
  _method() {console.log("child");}
}

(new Parent).method();
(new Child).method();
```

프로토타입 체인의 원리로 부모것을 호출하는 것이지만 그게 중요한게 아니라 나한테 없는 건 부모 것에 부르니까 이 이름에 해당 하는 부모 것을 찾을려고 하는게 중요하다. 즉 부모 자식간에는 포인터의 위치를 메소드 이름으로 계약한 것이다. 이름이 중요하다. 이름이 동적으로 연결된 포인터의 위치를 같이 마킹해주는 역할을 하는 것이다. 자식이 그 위치에 메소드란 위치가 없으니까 부모것에서 찾는 것이다. 자바스크립트에서는 프로토타입 체인을 사용한다.

이것이 OOP에서 대체가능성이 가능한 이유이다. 부모와 자식간의 포인터 공유가 되기 때문에 알고리즘 상에서 대체가능성, 자식도 부모의 것을 호출할수 있는 것이다. 

자식에서 부모의 메소드를 호출하면서 _method는 자식의 것이 호출이 가능한 것일까? 이러한 원리를 내적동질성이라고 부른다. 객체지향에서 대체가능성, 내적 동질성 이 있어야 다형성이 성립한다.  대체가능성은 child는 aprent 이기도 해, 내적동질성은 니가 한번 child면 끝까지 child이다. 왜냐면 child로 태어났으니까. 따라서 child에서 _method를 호출하면 child에 _method 가 있으니까 이걸 먼저 호출하는 것이다. 내적동질성 때문에. 자신이 태어나는 순간 아이덴티티는 무엇인가?

내적동질성을 성립하는 시스템은 여러가지가 있다. class 구문으로 만들면 전혀 다르게 만든다. es6 방식으로.

대체가능성은 `new Child instanceof Parent` 로 확인이 가능하다.

내적동질성은 오버라이드 된 메서드 호출을 통해서 알수 있다.

디자인 패턴, 객체지향원리는 내적 동질성과 대체가능성이 없으면 성립되지 않는다.

이 특성을 많이 이용하게 된다. 참조의 참조를 쓸때 자식을 링크드 리스트의 다음 노드로 볼수 있다. 다음 노드가 있으면 다음노드의 메서드 포인터로 들어가는 거고 그게 없으니 자신의 메서드 포인터로 가는 것이다.

클래스의 탄생은 C로부터 나왔다. 

참조의 참조, 참조의 참조를 타고 갈때 대체될수 있는데, 자식을 만들때 포인터가 옮겨갈수 있다. 이것이 런타임, 실행시점이라고 한다. 정의한 다음에 실행할때 문제가 생겨났다는 것이다. 단순히 실행해서 에러나는게 아니다. runtime에 바인딩이 이루어지는 것이다. 25분



#### 상태에 대한 분기는 사라지지 않는다. "그 분기가 필요해서 태어났기 때문"

#### ==> 정의시점에 제거하는 방법은? 1 . 분기 만큼 객체를 만든다 2 . 실행시점엥 경우의 수 공급

라우터 테이블 구성까지 성공, 분기에 대한 기본적인 개념 확립 필요하다.

반복문도 조건문인다. 조건문은 절대로 사라지지 않는다. 필요해서 태어났으니까. 필요해서 태어났 는데 없앨수가 없다. 우리가 할수 있는 것은 옮기는 거 밖에 없다. if 문을 모아두지 않으려는 이유는 if문을 모아둔 코드를 건드려야 하니까. if문을 코드문으로 두면, if가 추가될때마다 그 동네를 다 건드려야 하니까 분리해서 바깥으로 두고 싶은 것이다. 변화가 계속 이루어지면 계속 건드려야 하니까 그 여파가 컨트롤할수 없다. 그래서 쪼개서 바깥으로 빼고 싶은 것이다.

정의시점에 뭉쳐져 있지 않게 하고 실행 시점으로 분산해서 실행 시점에 취사선택을 하게끔 바꿔주는거 밖에 못하는 것이다. 어떻게 바꿔준다? 분기수만큼 객체를 만들어준다.

멤버용, 노티스일때, 경우의 수가 2개일때 2개의 객체를 만들고, 실행시점에 경우의 수를 공급해서 서비스를 안 건드릴수 있다. 여기서 얻은 것은 서비스를 안 건드린거 하나 이점을 얻었다.

#### 실행 시점으로 분기를 옮길 떄의 장단점

장점

1 . 정의 시점에 모든 경우를 몰라도 된다.

==> 장기적인 업데이트에 유리하다. 업데이트가 될때마다 라우팅 테이블에 넣는 라우터만 추가해 주면 된다. 수정 사항이 올때마다 다 뒤집을 필요가 없다.

2 . 정의 시점에 그 경우를 처리하는 방법도 몰라도 된다.

==> 처음엔 공방만 무기 있다가 나중에는 각종 이펙트, 부가 효과가 추가되면 나중에 추가하면된다.

일정한 통제 범위 내에서 확장 가능한 알고리즘 설계 가능하다.  일정 통제 범위내에서 확장이 자유롭다.

단점

1 . 실행 시점에 모든 경우를 반드시 기술해야 한다.

==> 예전에는 정의시점에 멤버, 노티스의 처리가 확실하게 다 기술되어 있었다. 타입에 대한 지식이 확정적이었기 때문에 안정적이고 오류가 나도 거기만 수정하면 되었다. 하지만 이젠 런타임으로 내려와서, 런타임에 기술했으니, 서비스는 그대로겠지만, 서비스 쓰고 있는 코드가 엉망일수 있다.

2 . 실행 시점마다 알고리즘의 안정성을 담보해야 한다.

==> 이 시점에 원하는 라이브러리, 환경이 준비 안되어 있을수 있다. 그 스크립트 코드들 환경떄마다 바꿔줘야 한다. 기존에는 한군데만 수정하면 안정성 답보할수 있던 것들이 개별 호스트 코드를 다 봐야 한다. 코드 만질때마다 단위테스트를 해야 한다.

매호스트코드마다 안정성을 따로 담보해야 한다.



우리는 이러한 문제를 해결하기 위해서 패턴으로 덮는다.

옛날에는 이러한 지식이 다 안에서 처리되고 들어 잇었는데 그게 다 밖에 나와서 추가 및 변경하기는 용이하지만 그것들이 다 밖으로 나와있다. 그래서 이것을 캡슐화를 해서 덮는다. 이렇게 하기 때문에 디자인 패턴이 같이 쓰여지는 것이다.

캡슐화 패턴 : 팩토리, 빌더 패턴

```javascript
// 생성 레시피 캡슐화
const M =v=>{throw `${v} is mandatory`;}
const ServiceBuilder = class {
  getService(baseUrl) {}
};
const MemberServiceBuilder = class extends ServiceBuilder {
  constructor(baseUrl) {this._baseUrl = baseUrl;}
  getService() {
    /*************** 기존 실행 시점 레시피를 정의 시점으로 이동 **************/
    /**/ const service = new Service(this._baseUrl);
    /**/ service.addChecker('member', new Checker(
    /**/ 	({name, nick, email=M('email'), id=M('id')})=>({id, nick, name, email})
    /**/ ));
    /**/ service.addChecker('join', new Checker(
    /**/ 	({error, isOK=M('isOk')})=>({isOK, error})
    /**/ ));
    /********************************************************************/
    return service;
  }
};

// 실행시점에는 정의 시점 레시피대로 구워진 객체를 사용
const service = new MemberServiceBuilder('/site').getService();
service.getData('member').then(console.log)
```



```html
// 실행시점 위임
<script src="Service.js"></script>
<script src="Checker.js"></script>
<script src="ServiceBuilder.js"></script>
<script src="MemberServiceBuilder.js"></script>		// 정의시점
<script src="AdminServiceBuilder.js"></script>		// 정의시점

<script>
  // 실행시점에 레시피 선택
  const service1 = new MemberServiceBuilder('/site1').getService();
  service1.getData('member').then(console.log);
  
  const service2 = new AdminServiceBuilder('/site1').getService();
  service2.getData('admin').then(console.log);
</script>
```

