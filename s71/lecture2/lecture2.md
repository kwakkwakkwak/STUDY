DP 의 카테고리

분류 : 생성패턴, 구조패턴, 행동패턴

구조패턴 : 객체들이 관계를 지을때 , 객체끼리 알아두는 방법

행동패턴 : 객체 사용시, 어떻게 협력해서 제공하는지

> 하지만 이미 객체지향 설계에 숙달한 사람을 대상으로 하는거임.......

우리는 객체 역할 모델을 알아가면서 진행할 것이다.

객체지향
- 다형성 : 
    - 대체가능성 : 자식 대신 부모형을 쓸수 있는 것이 대체 가능성이다. 
    - 내적 동질성

- 캡슐화
    - 복잡한 기능을 외부 노출 없이 표현하고 싶은 기능만 노출한다. 행위를 추상화해서 보여주는 것이 캡슐화
    - ex) ATM 외부 노출 기능 : 인출
    - 은닉 : 내장을 보여주지 않는 것.

- 변화율
    - 변화하는 정도
    - 부모자식 간으로 분리 하는 경우가 많다.
    - 같은 카테고리 안에서 변화율에 대응 하는 전략이 부모자식간으로 한다.
    - 같은 수정 건수 아래 있지만 시간에 따른..

- 역할 모델
    - 수정 건수에 따라서 대응하는 것

- 객체간 관계
    - 

알고리즘이란 상태와 분기의 문제 해결이다.

## 알고리즘 패턴

알고리즘을 해결하는 패턴중에 2가지가 있다.
제어문과 상태
- 제어문 : 조건문, 반복문
- 오늘은 조건문을 이용한 ....

기존 제어문 기반의 알고리즘이 갖는 문제 : 수정하면 전체가 컴파일 된다.
정의 시점, 실행시점은 상대적인 것이다.

여기서 컴파일된다는 것은 정의 시점이 된다는 것이다.

격리 이론을 쓰는 것은 가장 적게 수정하려고 하는 것.

기존 제어문 기반의 알고리즘은 수정하게 되면 전체를 수정해야 한다.
따라서 이런 것을 대처학 ㅣ위해서는 개별 알고리즘 코드를 함수로 만들어야 한다.

알고리즘이 변화하는 이유? 비지니스 변화, 라이브러리 변화, 호스트측 변화(사용측) => 대부분 통제불가 요소

잦은 변화에 대해서 지나치게 욕하는 사람은 자기코드가 변화에 대응할수 없게 짠 것이다. 강한 응집성, 약한 의존성이 되어 있지 않는 것이다.

```javascript
if(case == 1) {}
else if(case = 2){}
else if(case = 3){}
```

위와 같이 하면, 개별 함수만 검사하면 되니까 여파가 줄어들었다.
그나마 경우가 변경할때 개별 함수만 다루면 된다.
하지만 case4가 뜰경우 수정이 되어야 한다. 그리고 그것에 대한 검사, 체크가 필요하다.
우리는 저장을 하는 순간 다 검사가 필요하다.

여파가 분산되지 않고 해당 부분만 격리되도록 하고 싶다.

```javascript
const case1 =_=>{
    // 공통부분
    //case1전용
}

const case2 =_=>{
    // 공통부분
    //case2전용
}

// 공통부분이 생기게 되면 버그 발생의 가능성이 증가한다.
// 문제는 어디까지 정도까지 중복을 인지하고 볼수 있느냐?
// 중복은 끊임없이 집착해서 없애야 한다.
// 해결책 : 분기하기 전에 공통 부분을 미리 처리한다.
```

알고리즘 분화시 객체지향에서 선택할 수 있는 두가지 방법
- 상속 위임 ( 변화율에 대응하기 쉽다. )
    - 내부계약관계로 추상층에서 **공통 요소를 해결**하고 **상태를 공유**할수 있다.
    - 부모 자식 관계로 만들어서 자식이 처리하도록 위임한다.
    - 중복 제거뿐만 아니라 상태 공유도 가능하고 그것으로 문제 해결도 가능하다.

- 소유 위임 ( 역할 모델, 수정 건에 대한 대응이 쉽다. )
    - 외부계약 관계로 각각이 독립적인 문제를 해결하며 메세지(프로토콜)를 주고 받는 것으로 문제를 해결함
    - 좀더 복잡한 객체 관계를 만든다.
    - 우리는 프로토콜로만 해결을 할거야. 이 프로토콜에 상태가 저장된다.
    - **GOF DP 방향성**

- 템플릿 메소드 패턴
    - 상속 위임을 통해서 문제를 해결한다. 
    - 상속을 늘림으로서 알고리즘 분기를 해결한다.
    - 공통되는 부분을 처리하는 부분, 실행 시점의 위임부분이 하나의 메소드에 있는 것을 템플릿 메소드라고 한다.
    - 나머지는 소유위임을 지향, 하지만 이것만 상속 위임을 지향한다.

- 상속은 나머지 객체 위임에 있기 때문에 GOF패턴에서는 상속위임이 보기 힘든 것이다.

## 소유위임
- 소유위임은 자식이 없으므로 그것을 받아줄 것을 계약을 맺어야 한다.
- 외부계약자의 메소드를 통해서 값을 전달, 외부 계약자에 위임.


각 경우별 변화는 개별 함수만 변경하면 된다. " 문제는 경우가 변경될떄" ==> "포괄적 위임"


템플릿 메소드 패턴은 경우의 수를 대응할수 없다. 이것은 이미 경우가 확정되었을때만 쓸수 있다.
또한 포괄적 위임을 구현하면 이미 템플릿이 아니게 되는 것이다.

그래서 이러한 경우는 소유 위임으로 해결해야 한다.

라우터 : 케이스를 동적으로 처리하는 것.
라우팅 : 

주의 : 공부는 용어를 아는게 전부이다. 그 말의 의미를 정확하게. 구체적으로 언어화하지 않으면 뜬구름 잡고, 이용하기도 어렵다.

require, mandatory : 필수 라는 의미

=====================================================

참조와 값.
참조 : 메모리 주소 기억
    특징 : 메모리에 하나만 있는데 아는 놈들은 열라 많다.
값 : 메모리에 계속 만들어짐

참조 : 언어가 알아서 정한다.
JS는 문자열을 값으로 정했다. (그래봤자 내부적으로는 참조겠지뭐)

로우 레벨일수록 바이트로 할수 있는 것만 값으로~

값 : 복사시에 값이 그대로 복사된다.
참조 : 주소값만 ~

참조는 경계면을 넘는데 실패한다. 경계는 클라이언트와 서버 사이의 경계
경계를 넘길려면 참조를 값으로 넘겨야 하고 값으로 넘겨진 것을 다시 참조로 변경해준다.

쿠키 그외 것들.. 에 저장할때도 마찬가지로 경계를 못넘어.. 번역을 과정이 필요하다.

네이티브 객체, 큰 문자, 숫자 등은 환원이 되지 않는다. 
참조는 


```javascript

let a = {v:3};
let b = a;
a = {v:5};
b.v	// 3
// 이런 방식이 문제가 되는 것은 해당 코드의 의도와 다르게 작동하기 때문이다.
// 의도에 따르면 5가 나와야 하지만... 그렇지 않다.
```

이런식으로 참조는 배신을 때릴 수 있다.
우리는 이러한 문제를 해결할수가 없다는 것을 인정하라. 
참조를 바꾸면 안된다. 

```javascript

let a = {
    v:{v:3}
};
let b = a;
a.v = {v:5};
b.v.v
// 참조의 참조를 쓴다.
// 인터페이스 구상체, 부모와 자식, 링크드 리스트에 사용된다.

const Parent = class {
    method(){
        console.log("Parent");
    }
};

const Child = class extends Parent {
    method() {
        console.log("Child");
    }
};

(new Parent).method();  // 인자 없으면 이렇게 해도 new 로 생성자 호출 가능
(new Child).method();

```

```javascript

const Parent = class {
    method(){
        this._method();
    }
    _method() {
        console.log("Parent");
    }
};

const Child = class extends Parent {
    _method() { // 해당 부분으로 부모의 _method 의 포인터가 이동한다.
        console.log("Child");
    }
};
(new Parent).method();
(new Child).method();

// 객체지향 프로그래밍에서 대체가능성이 가능한 것은 부모와 자식간의 포인터 공유가 가능하기 때문에 그렇다.
// 내적 동질성 : 내가 탄생하는 순간, 자신의 아이덴티티는 무엇인가?
```

실행시점 : 런타임 (정의한 다음에 실행할때 문제가 생겼다.)

===========================================

상태에 대한 분기는 사라지지 않는다. 그 분기는 필요해서 생겨난 것이다.
정의 시점에 제거하는 방법은? (실행 시점에 취사선택을 하도록 하는 방법은)
=> 1. 분기 수 많큼 객체를 만들고
=> 2. 실행시점에 경우의 수를 공급한다. 이러면서 정의 시점의 코드를 수정하지 않을수 있다.

실행시점으로 분기를 옮길 때의 장단 점

장점
1. 정의 시점에 모든 경우를 몰라도 된다. ( 만드는 시점에 모든 경우의 수를 몰라도 된다. 사실 다 아는게 불가능이기도 하고)
2. 정의 시점에 그 경우를 처리하는 방법도 몰라도 된다.
> 일정한 통제 범위 내에서 확장가능한 알고리즘 설계 가능 

단점
1. 실행 시점에 모든 경우를 반드시 기술해야 한다. ( 서비스는 엉망이지는 않겠지만, 서비스가 쓰고 있는 그 코드가 엉망일수 있다.)
2. 실행 시점마다 알고리즘의 안정성을 담보해야 한다. ( 모든 코드들을 단위테스트 해야했다. )
> 매 호스트코드마다 안정성을 따로 담보해야 한다.

이러한 것을 대응하기 위해 캡슐화 패턴 ( 팩토리, 빌더 패턴 )을 사용한다.
디자인 패턴의 한가지 목적을 이루면 다른 똥은 또다른 패턴으로 덮는다. -_-)a

지식, 레시피 : 특정 도메인에 대한 지식을 이야기한다.

레시피 : 타입에 대한 지식, 타입에 대한 조직화, addChecker 에 대한 지식등 비즈니스 도메인과 관련된 로직
진짜 자바 수업 같네..

생성에 대한 지식을 캡슐화 하기 위해서 쓴다.
디자인 패턴은 무조건 협력한다. 그래서 하나하나 배울수가 없다.
많은 역할을 만들면 역할을 중재하는 무엇이 나온다.
내장을 밖으로 내놓으면 캡슐화를 다시..

서로가 서로를 덮도록..
이러한 것을 컴포넌트 패턴이라고 한다. ( MVC 패턴 ) 더이상 패턴이 증식하지 않도록 한 것














