## To Be Actual Programmer

### 프로그래밍이 어려운 이유

1. 실제로 개발가능한 개발자가 되는 공부는 **복잡성**을 다루는 공부이다. 기계만이 처리 가능한 복잡성을 어떻게 개발자는 다룰 수 있는 것인가? 바로 복잡성을 정복하는 여러가지 수단을 고안해 냈고 그로 인해 복잡성을 다룰수 있게 된 것이다. 결국 프로그래머는 복잡성을 관리할 수 있는지, 없는지에 따라 실제 개발 가능한 개발자인지 아닌지가 판가름 나게 되는 것이다. 하지만 입문 레벨의 학습 방법에서는 이것을 배우기가 어렵다.

2. 단 하나의 프로그래밍 법칙은 `모든 프로그래밍은 변한다.`이다. 모든 프로그램은 변하는 데 이 복잡한 프로그램이 향후 변화에 대해서 받아들일 수 있도록 프로그래밍을 했는지가 중요하다.

> **실제 프로그래머가 된다는 것은 복잡성을 정복할 수 있다는 것이다.**

<br/>
<br/>

## Program & Timing

### 프로그램은 어디서부터 프로그램인가?

컴퓨터 메모리에 적재된 이후에 설행되기 직전 상태부터 프로그램이라고 한다. 즉 **실행가능한 코드가 메모리에 적재된 상태가 프로그램**이고 그것을 만드는 것이 프로그래밍, 만드는 사람을 프로그래머라고 한다. 

```
┌──────────────────┬──────────────┐
│ LANGUAGE CODE    │ LINT TIME    │
├──────────────────┼──────────────┤
│ MACHINE LANGUAGE │ COMPILE TIME │
├──────────────────┼──────────────┤
│ FILE             │              │
├──────────────────┼──────────────┤
│ LOAD             │              │
├──────────────────┼──────────────┤
│ RUN              │ Runtime      │
├──────────────────┼──────────────┤
│ TERMINATE        │              │
└──────────────────┴──────────────┘
```

**LANGUAGE CODE**  
프로그래밍 언어로 코딩하는 것이다. 컴파일 전에 제대로 코딩하는지에 대해서 힌트를 주는 것을 Linting이라고 한다. 그리고 이 시점, 즉 코드를 짜고 있을 때 Lint Time 이라고 한다. 

**MACHINE LANGUAGE**  
기계언어로 컴파일을 하게 된다. 즉 기계가 이해할 수 있는 언어로 만들어 준다. 컴파일을 할때 코드가 틀리면 에러가 발생하게 된다. 이 시점을 Compile Time 이라고 한다. 개발자는 컴파일러를 속일 수도 있다.

**FILE, LOAD**  
컴파일이 끝나고 나면 프로그램이 될 수 있는 파일로 만들어진다. 그 다음  실행을 하게 되면 먼저 메모리에 적재가 일어나게 된다. 

**Runtime**  
메모리에 적재를 한 후에 실행을 하게 된다. 컴파일에서 걸리지 않았던 것들이 Runtime에서 걸리기도 하며 이것을 Runtime Error 라고도 한다. 이 시점을 Runtime이라고 하며 실행시점이라고도 한다. 

**TERMINATE**  
실행이 끝나면 종료가 된다.

<br/>

### CONTEXT ERROR
프로그래밍 생명주기에는 안 나와있지만, Runtime Error 조차 안 걸리는 경우가 있다. 이러한 것을 **Context Error** 라고 한다. 린트, 컴파일, Runtime에서 에러가 나면 다행이지만, Context Error가 나오면 굉장히 상황이 악화된 것이다. 따라서 기본적인 프로그래밍 전략은 최대한 앞의 시점에서 에러를 잡고 좋은 코드를 짜는 것이며 이것은 컴파일 랭귀지의 전략이기도 하다.

<br/>

### Runtime Language

그에 반해서 현대패러다임은 복잡한 컴파일 과정 없이 간편하게 실행시킬 수 있는 Runtime 스크립트 라는 방식을 도입했다. 그래서 Runtime 언어에서는 아래와 같은 일이 일어난다.

```
┌──────────────────┬──────────────┐
│ LANGUAGE CODE    │ LINT TIME    │
├──────────────────┼──────────────┤
│ FILE             │              │
├──────────────────┼──────────────┤
│ LOAD             │              │
├──────────────────┼──────────────┤
│ MACHINE LANGUAGE │              │
├──────────────────┼──────────────┤
│ RUN              │ Runtime      │
├──────────────────┼──────────────┤
│ TERMINATE        │              │
└──────────────────┴──────────────┘
```
**LANGUAGE CODE**  
먼저 JS 를 작성한다. 린트에 도움을 받는다.

**FILE, LOAD**  
그다음 저장한다. 그다음 로드한다. 브라우저에서 URL 뜨게 되면 메모리에 적재가 된다.

**MACHINE LANGUAGE**  
적재된 코드를 기계어로 알아서 매번 변경한다. 이것을 오토컴파일이라고 볼 수 있다. 현대의 자바스크립트는 오토 컴파일을 하는데, 컴파일 언어와는 큰 차이가 있다. 컴파일 방식에서는 컴파일해서 하나의 파일로 만들기 위해서 코드를 전부 빠짐 없이 해석해서 컴파일을 한다. 하지만 오토 컴파일 방식에서는 내가 지금 바라보는 파일에 대해서만 검사하고 컴파일하는 것이다. 하지만 거기에 더 나악서 하나의 파일 내에서도 부분적으로만 머신코드로 바꾸고 그외에는 해석하지 않는다. 이렇게 부분적인 컴파일 전략을 사용한다. 따라서 전체검사의 혜택이 없어서 개발자에게 더 많은 책임을 부여한다.

**Runtime, TERMINATE**  
실행이 되고 종료한다.

위의 과정들이 일반적인 스크립트 언어의 작동 방식이다. 여기에 JS에서는 린트타임과 Runtime 에서의 에러만 잡는건가? 실행시점에서는 실행시점에 에러가 발생하기 전까지는 에러를 잡을 수 없기 때문에 에러를 잡기가 상당히 어렵다. 즉 Runtime Error은 기본적으로 잡을 수 없다. 

<br/>
<br/>

## 스크립트 언어의 보완 수단
스크립트 언어에서는 컴파일 언어와 다른 이러한 부분에 대한 보완할 수단이 필요하다. 
1. 컴파일 스타일로 짜는 것은 타입 스크립트와 같은 것들이 있다.
2. 스크립트 개발론이 있다.

JS에서는 Runtime 밖에 없지만, Runtime을 자세히 보면 기저가 되는 함수, 클래스를 만들고 정의하고 다시 그것을 이용하는 응용 클래스, 응용 함수를 만들게 된다. 그다음 다시 그것을 사용하는 코드가 나온다. 앞 문장에서 나온 일련의것들을 각각 추상 레이어라고 보았을때, 그 안에서 다시 static time, runtime이 각각 상대적으로 나뉘어진다. 그래서 레이어 별로 Runtime을 세세하게 나누는 전략을 하게 되면 실행 중에 에러가 어디에서 나는지를 나눌수가 있게 된다. 이렇게 되면 에러가 일어난 부분에서 그 부분에서의 코드만 수정하면 된다. 

원래는 물리적으로는 나뉘어 있지 않는데, 스크립트 개발론에서는 의미론 적으로 나뉘어서 관리를 하게 된다. 그러면 찾기가 더욱 용이해 진다. 복잡성을 정복하기 위한 기본적인 전략은 노란선 즉 격리를 하는 것이다. 

![](./1.png)


### 격리

복잡성을 정복하는 방법에는 **격리**가 있다. 클래스, 라이브러리, DP , 프레임워크, 어떤 것을 쓰던 주요한 관심사는 어떤 에러가 났을때 어디 소속, 책임인지를 알수 있도록 격리 구간을 만드는데 있다. 개발자로서 성공하기 위해서는 격리하는 방법을 잘 알아야 한다. 

예를 들어 프로그램에서 15가지 요소로 되어 있는데 13번 요소는 13번 함수에서만 에러가 난다고 하면 해당 에러가 발생했을 때에는 신속하게 찾아 들어갈 수 있다. 이러한 감각을 익혀나가면 좋은 개발자가 될 수 있다.

<br/>

### 프로그래밍 공부

처음 입문하는 사람들이 지루하고 어렵기 때문에, 흥미를 유발하는 방법론을 사용한다. 조금밖에 모르는 상태에서  토이프로젝트를 만들게 한다. 이것을 반복하게 되면 대부분의 입문자들이 무의미한 토이프로젝트를 만들고 아무것도 모르는 상태로 끝나게 되며 그 수준이 깊어지지 않게 된다.

자신의 프로그래밍이 깊어지기 위해서는 본인이 코드 하나를 짜더라도 어떤 의미와 어떤 역할, 어디까지 격리할수 있는지에 대한 인식하는 훈련이 필요하다. 이것은 추상적이기 때문에, 배우기 쉽지 않지만 제대로 된 개발자가 되기 위해서라면 배워야 한다. 이것이 바로 제대로 된 프로그래밍인 것이다.

이제부터는 컴퓨터 사이언스에 입문했으니 책에 나오는 언어중에 모르는것이 없도록 하고, 당연하다고 생각되는 것들도 의심해보고 그냥 지나치는 일이 없도록 한다.

<br/>
<br/>

## LEXICAL GRAMMAR

**LEXICAL GRAMMAR 은 js의 구성요소중에 가장 기저가 되는 것**이다. LEXICAL은 어휘적인 이라는 뜻이다. 즉 어휘적인 문법이다. JS를 짜려면 JS내에 존재하는 문자들에 대해서 알아야 한다.

- CONTROL CHARACTER :  제어문자로 한국어, 영어에서는 안쓴다.
- WHITE SPACE  : 공백문자, 공백은 57개 정도 된다.그래서 JS에서는 그것을 정의해두었다.
- LINE TERMINATORS : 개행문자로 줄을 끊어주며 유니코드에는 6가지 이상의 개행문자가 존재한다.
- COMMENTS : 주석이며 주석을 하면 그 라인 또는 블록이 주석처리 되며, 엔진이 해당 부분을 무시한다.
- KEYWORD : 예약어로 미리 약속되어 있어서 엔진이 이 단어를 만나면 특정한 기능을 수행하게 약속되어 있다.
- LITERALS : 리터럴은 언어에서 정의한 더이상 쪼갤수 없는 값의 표현이다. 예를 들어 숫자 37을 보면 37보다 더 쪼개서 표현할 방법이 없다. 최소한의 표현이 37이다. 

<br/>
<br/>

## LANGUAGE ELEMENT
자바스크립트 언어는 크게 보면 3가지 요소인 문, 식, 식별자로 구성되어 있다. 식별자와 식은 값과 관련되어 있으며 값이 아닌 모든 것들은 문이다.

<br/>

### STATEMENT ( 문 )

**종류**: `공문, 식문, 제어문, 선언문` 또는 `단문, 중문`

**문이란 자바스크립트 엔진이 어떻게 해석할 지 알려주는 힌트**이다.  힌트이기 때문에 실행된 이후에 메모리에서 없어진다. if문, return문을, throw문을 변수에 할당할 수 없다. 이 녀석은 단지 힌트일 뿐이기 때문이다. 따라서 엔진에 실행에 관여할수 있을 뿐이지 메모리로 남지않고, 연산이 될 뿐이다. 명령일 뿐이지 메모리에 흔적이 남지 않고, 값이 될수 없다. 그럼 어디까지가 문이고 식일까? 그것은 언어 설계자의 선택에 따른다. 문을 값으로 환원되지 않는, 자바스크립트 엔진에 던져 주는 실행 방법이나 명령이다. 



**문에는 공식적으로 4가지가 있다.**

- 공문 : 아무것도 없는 문을 말한다. `; ; ;` 이런 것들. 스크립트를 짤때 실수를 많이해서 그러하다. 엄격한 문의 구분을 못하니까 그것을 보완하기 위해서 만든 것이다. 
- 식문 : 하나의 식은 하나의 문이 될 수 있다. `3+5`는 연산식이지만 `3+5;` 이러면 문이 되는데 아무 문제가 없다. 하나의 식은 하나의 문이 될 수 있기 때문이다. 
- 제어문 : 28개 정도 있다. 제어문이 아닌 문중에는 선언문이 있다.
- 선언문 : 식별자를 선언하기 위한 문이다. 


**이 외에도 단문, 중문이라는 분류 체계가 있다.** 

- 단문 : 문장 하나를 말하는 것이다.
- 중문 : 문장 여러개를 묶어서 하나의 문장처럼 보는게 중문이다. 자바스크립트에서는 중괄호를 열고 닫으면 그 안의 문장 전체를 묶어서 하나의 문장으로 봐 주는 기능이 있다. 그래서 어떠한 문에 단문이 올자리면 예외없이 중문이 올 수 있다. 

<br/>

### EXPRESSION ( 식 )

**종류** : `값식, 연산식, 호출식`

**식은 최종적으로 하나의 값으로 수용되는 것**을 말한다. 즉 식은 값의 확장된 표현이다. 그래서 식은 단일한 값으로 수용되며 하나의 값이 될 수 있다.

- 값식 : 3, 7, true (value expression)  하나의 값은 식이 된다.  
- 연산식 : 연산자를 이용함. `1+3`은 산술 연산자를 사용한 연산식이라고 한다.  연산자가 들어간 식  
- 호출식 : 함수a가 있어 a() 라고 하면 a의 리턴값일 것이다. 함수로 호출하는 것도 호출식의 일부.

서로가 서로를 포함할 수 있는 관계이다. 식의 조합은 하나의 값으로 떨어진다. 언어에서 큰 축을 구성하고 있는 것이 식이며 식은 값이다. 

연산식에는 구분법이 여러가지 있다. 

| 구분법                 | 연산자                     |
| ------------------- | ----------------------- |
| 연산자에 종류에 따라서 나누는 방법 | 산술 연산자, 논리 연산자..        |
| 목적에 따라 나누는 방법       |                         |
| 필요한 항의 수로 나누는 방법    | 단항 / 이항 / 삼항 연산자/다항 연산자 |

연산자는 오퍼레이터, 오퍼레이션 이라고 부르기도 한다.

<br/>

###  IDENTIFIER ( 식별자 )

**종류** : `기본형, 참조형`  또는` 변수, 상수`

값은  저장하지 않으면 즉시 메모리에서 사라진다. 프로그램은 로드 과정을 통해서 적재되어 실행되는데, CPU는 프로그램이 실행되는 과정에서는 프로그램을 계속 소비해 없애 버린다. 값은 소비되어 없어져 버려서 재활용할 수 없어 무의미한 값의 표현이 된다. 

순수한 값을 나타내는 식은 볼 수는 있고 소비는 되지만 이용하기가 어렵다. 그러면, 이 값들을 어딘가에 저장했다가 꺼냈다가 해야 하는데 그것이 바로 변수이다. 

**변수란 메모리 주소의 별명**이다. 변수는 2가지 역할이 있는데, 메모리 주소의 별명이며 해당 값(데이터)에 대한 타입정보를 가지고 있다는 것이다. 이렇게 이 두가지 의미를 담는 특정한 이름을 지정하는 행위를 **식별자**라고 부른다. 

식별자는 안에 담는 값의 형태가 primitive type(기본형), 

식별자는 안에 담는 값의 형태가 2가지 형태가 올 수 있다. 첫번째는 3과 같은 값이며, 두번째는 참조가 들어온다. 참조란 다른 메모리 주소를 가르키는 것이다.

- primitive type(기본형) : 값을 쓰는 경우에는 모든 값은 복사할 수 있다. 복사되는 값의 타입을 primitive type(기본형) 이라고 한다.  기본형의 특징 값의 복사가 일어난다. 
- reference type(참조형) : 참조형의 특징은 같은 메모리 주소를 가리키고 있는 것이다. 참조만 복사가 된다.


기본형과 참조형을 정하는 것은 언어 설계자들이 정한다. 언어 설계자들이 기본형을 정했다면 그 외에는 참조형이라고 할 수 있다.

- 변수 : 계속 값을 변경할 수 있다.
- 상수 : 상수는 한번 대입되면 변경할 수 없도록 보호해주는 장치가 있다.

**중요한 원칙** : **프로그래밍 할때 변화가능성을 배제함 으로서 복잡성을 줄일 수 있다**. 변수를 사용할 때 원칙은 무조건 **상수로 정의하고, 변해야할 이유가 있을 때만 변수로 사용**한다. 우리의 노력은 복잡성을 정복하고 수정가능성을 확보하는데 있다. 

