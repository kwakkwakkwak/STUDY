# 3강

## INTERFACE

자바스크립트에서 인터펭이스는 고유명사이다.

1 . 인터페이스란 사양에 맞는 값과 연결된 속성키의 셋트  
2 . 어떤 oBJECT라도 인터페이스의 정의를 충족시킬 수 있다.  
3 . 하나의 Object는 여러개의 인터페이스를 충족시킬 수 있다.

자바스크립트에서도 오브젝트나 클래스가 여러 인터페이스를 충족시킬수 있다. 중요한 것은 1번이다. 

<br/>

### INTERFACE TEST

1 . test라는 키를 갖고  
2 . 값으로 문자열인자를 1개 받아 불린 결과를 반환하는 함수가 온다.

```javascript
{
  test: function(str){return true;}
}

// test라는 key, value자리에 문자 인자 하나 받고 불린 결과 반환하는 함수가 있다는 요구조건만 맞으면 어떻게 함수를 짜든 상관이 없다.
const object = {
  test(str) {
    return true;
  }
}

const Test = class {
  test(str) {
    return true;
  }
}

// 클래스 정의에서 인터페이스를 만족시키면 그 인스턴스들은 자동으로 원래 인터페이스의 요구사항을 맞출수 있을 것이다.
const test = new Test;
```

<br/>

클래스가 인터페이스를 구현하고 있을 뿐이지, 테스트가 있다는 것을 보장하지는 않는다. 동적언어에서는 말이다. test가 Test클래스의 인스턴스인 것은 확인할 수 있지만, 그렇다고 해서 test라는 메소드를 가지고 있는지를 보장되지 않는다. 그냥 Test의 인스턴스일 뿐이다. 그래서 런타임, 컴파일에러가 일어나지 않는다. 이것을 일으키는 유일한 방법은 상속구조를 이용해서 throw를 던져줄 수 밖에 없다. 그렇기는 하지만 그럼에도 불구하고 어떤 객체가 느슨하게 인터페이스를 구현했다면, 상관하지 않겠어. 그것이 덕타이핑이라고 한다. 이 클래스가 실제로 무엇을 하든지 간에 해당 인터페이스의 조건을 만족하지만 한다면, 그 인터페이스의 구상체로 볼 것이다. 이것이 원래 무엇을 하는지는 상관 없고 원하는 인터페이스를 잘 구현하기만 했다면 이것을 테스트 인터페이스를 사용할 수 있는 객체로 볼것이다. 이것이 덕타입이다. 이것을 쓰는 이유는 런타임에는 컴파일타임의 타입체크가 되지 않기 때문에 쓴다. 

이것이 어려운 점은 이것은 우리 머릿속에 있는 약속이라는 점이다. 우리가 테스트 인터페이스를 구현할 수 있는 이유는, 하나만 기억하면되고 간단하기 때문이다. 실제 어플리케이션에서는 인터페이스를 200개 이상되면 사용할수 있을까? 실제 덕타입들은 이러한 문제를 가지고 있다.

여튼 JS의 인터페이스는 덕타이핑을 구현하기로 약속한 프로토콜 같은 것이다. 



## ITERATOR INTERFACE

1 . next라는 키를 갖고  
2 . 값으로 인자를 받지 않고 IteratorResultObject를 반환하는 함수가 온다.  
3 . IteratorResultObject는 value와 done라는 키를 갖고 있다.  
4 . 이중에서 done은 계속 반복할 수 있을지 없을지에 따라 불린 값을 반환한다.

자바스크립트에서 미리 규정하고 있는 인터페이스들이 있다. 약 18가지 정도 되는데 더 늘어나고 있다. 그리고 반복문과 관련된 인터페이스에는 Iterable, Iterator가 있다. 

자바스크립트 표준에 존재하는 이터레이터 인터페이스는 1 ~ 4 까지를 요구한다.  참고로 인터페이스가 인터페이스를 부르는 경우가 많다.

```javascript
//////////////////////////////////////////////
{
  next: function() {
    return {value:1, done:false}
  }
}
//////////////////////////////////////////////
{
  data:[1,2,3,4],
    next: function() {
      return {
        done:this.data.length === 0,
        value:this.data.pop()
      }
    }
}
//////////////////////////////////////////////
const iter = {
  data:[1,2,3,4],
    next() {
      return {
        done:this.data.length === 0,
        value:this.data.pop()
      }
    }
}
```

이렇게 충족하는 객체는 만드는 이유는 소비하는 측이 있기 때문이다. 소비하는 측에서는 이러한 이터레이터 리저트 오브젝트를 요구하는 이유는 계속 next를 부를지 말지를 판정하기 위함이다. value는 그때그때 값을 얻어내기 위함이다. 

어디다가 쓸까? 코드를 보면 data라는 키에 데이터가 담겨 있다. 이것은 외부에 보이지 않는 자신만의 데이터이다. next를 호출할 때마다 본인의 데이터가 length가 0인지 체크하고, value에는 데이터의 pop()이 이루어진다. 





## ITERABLE INTERFACE

1 . Symbol.iterator라는 키를 갖고  
2 . 값으로 인자를 받지 않고 Iterator Object를 반환하는 함수가 온다.

이터레이터 인터페이스를 구현한 것이 이터레이터 오브젝트인데, 이것을 반환하는 함수가 필요하다는 것이다. 이터러블은 이터레이터 오브젝트를 반환한다. 

```javascript
const iterator = {
  data:[1,2,3,4],
    next() {
      return {
        done:this.data.length === 0,
        value:this.data.pop()
      }
    }
}

const iterable = {
  // symbol.iterator에 함수를 넣는다.
  [Symbol.iterator]() {
    return iterator;
  }
}
```

Symbol은 참조가 아니라 복사가 일어난다. 모든 심볼은 유니크 값이다. 이러한 심볼을 오브젝트의 키로 사용하려면 계산된 오브젝트 이름이라는 ES6문법을 사용해야 한다. `[ ]` 로 감싸면 된다. Symbol은 new를 사용하지 않고 `Symbol(value)` 로 사용한다.  `Symbol.iterator` 와 같은 부류들은 이미 언어에서 규정되어 내장되어 있다. well-known symbol은 문자열(@@)로 대체가 가능하다. 키가 변수의 명령 규칙이 맞지 않을 때에도 계산된 오브젝트 이름을 사용해야 한다. 

```
[Symbol.iterator]와 ['@@iterator'] 는 동일하게 동작한다. 
```

이터러블 인터페이스의 키가 이터레이터이다. 그 이유는 이 메소드가 반환하는 것이 이터레이터 이기 때문이다.  이 메서드의 요구사항이 이터레이터를 반환하는 것이다. @@iterator은 향후 스펙에서 바뀔수 있기 때문에 [Symbol.iterator] 로 써야 한다. 예전 엔진 개발하던 사람들이 사용하던 흔적인 것이다.



```javascript
const Iterator = class {
  constructor() {
    this.data = [1,2,3,4];
  }
  next() {
    return {
      done: this.data.length === 0,
      value: this.data.pop()
    }
  }
}


const iterable = {
  // symbol.iterator에 함수를 넣는다.
  [Symbol.iterator]() {
    return new Iterator();
  }
}
```

이때마다 new iterator를 하면 새롭게 반복할수 있는 이터레이터를 얻게 된다. 이터러블이 존재하는 이유는 이터레이터만 있으면 한번 반복되고 나면 없어지는데, 그것 원본은 그대로 둔 상태에서, 계속해서 반복가능한 객체를 얻기 위해서, 이터러블이라는 중간층을 하나 더 두는 것이다. 이렇게 하면 이터러블을 통해서 이터레이터를 얻을 때마다 새롭게 반복시킬수 있는 객체를 얻을 수 있을 것이다. 이것이 이터러블 인터페이스이다.

대부분 이터러블을 요구한다. 이터러블만 받아주는, 이터러블과 이터레이터를 다 받아주는 문법도 존재한다.

