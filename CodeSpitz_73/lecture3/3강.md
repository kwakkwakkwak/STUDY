# 3강

## INTERFACE

자바스크립트에서 인터페이스는 고유명사이다.

1 . 인터페이스란 사양에 맞는 값과 연결된 속성키의 셋트  
2 . 어떤 oBJECT라도 인터페이스의 정의를 충족시킬 수 있다.  
3 . 하나의 Object는 여러개의 인터페이스를 충족시킬 수 있다.

자바스크립트에서도 오브젝트나 클래스가 여러 인터페이스를 충족시킬수 있다. 중요한 것은 1번이다. 

<br/>

### INTERFACE TEST

1 . test라는 키를 갖고  
2 . 값으로 문자열인자를 1개 받아 불린 결과를 반환하는 함수가 온다.

```javascript
{
  test: function(str){return true;}
}

// test라는 key, value자리에 문자 인자 하나 받고 불린 결과 반환하는 함수가 있다는 요구조건만 맞으면 어떻게 함수를 짜든 상관이 없다.
const object = {
  test(str) {
    return true;
  }
}

const Test = class {
  test(str) {
    return true;
  }
}

// 클래스 정의에서 인터페이스를 만족시키면 그 인스턴스들은 자동으로 원래 인터페이스의 요구사항을 맞출수 있을 것이다.
const test = new Test;
```

<br/>

클래스가 인터페이스를 구현하고 있을 뿐이지, 테스트가 있다는 것을 보장하지는 않는다. 동적언어에서는 말이다. test가 Test클래스의 인스턴스인 것은 확인할 수 있지만, 그렇다고 해서 test라는 메소드를 가지고 있는지를 보장되지 않는다. 그냥 Test의 인스턴스일 뿐이다. 그래서 런타임, 컴파일에러가 일어나지 않는다. 이것을 일으키는 유일한 방법은 상속구조를 이용해서 throw를 던져줄 수 밖에 없다. 그렇기는 하지만 그럼에도 불구하고 어떤 객체가 느슨하게 인터페이스를 구현했다면, 상관하지 않겠어. 그것이 덕타이핑이라고 한다. 이 클래스가 실제로 무엇을 하든지 간에 해당 인터페이스의 조건을 만족하지만 한다면, 그 인터페이스의 구상체로 볼 것이다. 이것이 원래 무엇을 하는지는 상관 없고 원하는 인터페이스를 잘 구현하기만 했다면 이것을 테스트 인터페이스를 사용할 수 있는 객체로 볼것이다. 이것이 덕타입이다. 이것을 쓰는 이유는 런타임에는 컴파일타임의 타입체크가 되지 않기 때문에 쓴다. 

이것이 어려운 점은 이것은 우리 머릿속에 있는 약속이라는 점이다. 우리가 테스트 인터페이스를 구현할 수 있는 이유는, 하나만 기억하면되고 간단하기 때문이다. 실제 어플리케이션에서는 인터페이스를 200개 이상되면 사용할수 있을까? 실제 덕타입들은 이러한 문제를 가지고 있다.

여튼 JS의 인터페이스는 덕타이핑을 구현하기로 약속한 프로토콜 같은 것이다. 



## ITERATOR INTERFACE

1 . next라는 키를 갖고  
2 . 값으로 인자를 받지 않고 IteratorResultObject를 반환하는 함수가 온다.  
3 . IteratorResultObject는 value와 done라는 키를 갖고 있다.  
4 . 이중에서 done은 계속 반복할 수 있을지 없을지에 따라 불린 값을 반환한다.

자바스크립트에서 미리 규정하고 있는 인터페이스들이 있다. 약 18가지 정도 되는데 더 늘어나고 있다. 그리고 반복문과 관련된 인터페이스에는 Iterable, Iterator가 있다. 

자바스크립트 표준에 존재하는 이터레이터 인터페이스는 1 ~ 4 까지를 요구한다.  참고로 인터페이스가 인터페이스를 부르는 경우가 많다.

```javascript
//////////////////////////////////////////////
{
  next: function() {
    return {value:1, done:false}
  }
}
//////////////////////////////////////////////
{
  data:[1,2,3,4],
    next: function() {
      return {
        done:this.data.length === 0,
        value:this.data.pop()
      }
    }
}
//////////////////////////////////////////////
const iter = {
  data:[1,2,3,4],
    next() {
      return {
        done:this.data.length === 0,
        value:this.data.pop()
      }
    }
}
```

이렇게 충족하는 객체는 만드는 이유는 소비하는 측이 있기 때문이다. 소비하는 측에서는 이러한 이터레이터 리저트 오브젝트를 요구하는 이유는 계속 next를 부를지 말지를 판정하기 위함이다. value는 그때그때 값을 얻어내기 위함이다. 

어디다가 쓸까? 코드를 보면 data라는 키에 데이터가 담겨 있다. 이것은 외부에 보이지 않는 자신만의 데이터이다. next를 호출할 때마다 본인의 데이터가 length가 0인지 체크하고, value에는 데이터의 pop()이 이루어진다. 





## ITERABLE INTERFACE

1 . Symbol.iterator라는 키를 갖고  
2 . 값으로 인자를 받지 않고 Iterator Object를 반환하는 함수가 온다.

이터레이터 인터페이스를 구현한 것이 이터레이터 오브젝트인데, 이것을 반환하는 함수가 필요하다는 것이다. 이터러블은 이터레이터 오브젝트를 반환한다. 

```javascript
const iterator = {
  data:[1,2,3,4],
    next() {
      return {
        done:this.data.length === 0,
        value:this.data.pop()
      }
    }
}

const iterable = {
  // symbol.iterator에 함수를 넣는다.
  [Symbol.iterator]() {
    return iterator;
  }
}
```

Symbol은 참조가 아니라 복사가 일어난다. 모든 심볼은 유니크 값이다. 이러한 심볼을 오브젝트의 키로 사용하려면 계산된 오브젝트 이름이라는 ES6문법을 사용해야 한다. `[ ]` 로 감싸면 된다. Symbol은 new를 사용하지 않고 `Symbol(value)` 로 사용한다.  `Symbol.iterator` 와 같은 부류들은 이미 언어에서 규정되어 내장되어 있다. well-known symbol은 문자열(@@)로 대체가 가능하다. 키가 변수의 명령 규칙이 맞지 않을 때에도 계산된 오브젝트 이름을 사용해야 한다. 

```
[Symbol.iterator]와 ['@@iterator'] 는 동일하게 동작한다. 
```

이터러블 인터페이스의 키가 이터레이터이다. 그 이유는 이 메소드가 반환하는 것이 이터레이터 이기 때문이다.  이 메서드의 요구사항이 이터레이터를 반환하는 것이다. @@iterator은 향후 스펙에서 바뀔수 있기 때문에 [Symbol.iterator] 로 써야 한다. 예전 엔진 개발하던 사람들이 사용하던 흔적인 것이다.



```javascript
const Iterator = class {
  constructor() {
    this.data = [1,2,3,4];
  }
  next() {
    return {
      done: this.data.length === 0,
      value: this.data.pop()
    }
  }
}

const s = Symbol();
const iterable = {
  // symbol.iterator에 함수를 넣는다.
  [Symbol.iterator]() {
    return new Iterator();
  }
}
iterable['@@iterator']
```

이때마다 new iterator를 하면 새롭게 반복할수 있는 이터레이터를 얻게 된다. 이터러블이 존재하는 이유는 이터레이터만 있으면 한번 반복되고 나면 없어지는데, 그것 원본은 그대로 둔 상태에서, 계속해서 반복가능한 객체를 얻기 위해서, 이터러블이라는 중간층을 하나 더 두는 것이다. 이렇게 하면 이터러블을 통해서 이터레이터를 얻을 때마다 새롭게 반복시킬수 있는 객체를 얻을 수 있을 것이다. 이것이 이터러블 인터페이스이다.

요구할 때에는 대부분 이터러블을 요구한다. 이터러블만 받아주는, 이터러블과 이터레이터를 다 받아주는 문법도 존재한다.



```javascript
{
  [Symbol.iterator]:function() {
    return {
      next: runction() {
      return {value:1, done:false};
    };
  }
}
```

이터레이터는 next라는 함수를 갖고 있는, (value, done을 반환하는) 이터레이터 오브젝트 리절트를 반환하는 이 함수를 갖고 있는 이 객체를 반환하면 된다. 이것이 최소 구현이다. 이것이 우리의 이터러블 인터페이스를 만족하기 때문이다.



## LOOP

지금까지 우리는 인터페이스에 대한 개념과 내부에 내장되어 잇는 표준 인터페이스 2가지가 무엇이고 어떻게 구현하는지를 알아 보앗다. 자바스크립트 6.0 이후는 내부에 인터페이스라는 개념이 구현되어서 덕 타이핑을 할 수 있는 인터페이스 표준이 있고, 만약에 언어에서 인터페이스를 요구하면 인터페이스의 스펙대로 만들어줘야 한다. 자바스크립트에서는 다양한 인터페이스를 요구한다. 스펙에 있으며 그 스펙에 따라서 최소구현이나 그 이상으로 의미 구현을 할 수 잇다.

하지만 이터러블은 이미 배열, 문자 등등에서 구현하고 있다. 자바스크립트 6 이후에는 엔진도 바뀌었고, 자바스크립트의 코어 오브젝트라 불리는 것들의 동작도 바뀌었다. 

예전에는 for in 으로 오브젝트를 순회할 경우 키가 랜덤하게 나왔다. 순서 보장이 되지 않았다. 하지만 es6에서는 오브젝트에 키 정렬 순서라는 것이 생겼다. 숫자로 반환될 수 잇는 문자열들이 먼저 숫자 크기대로 정렬이 되고, 그다음에 알파벳, 그다음에 심볼끼리 정렬이 된다. 순회와 별개로 생성할 때에는 순차적으로 생성이 된다. 계산되는 필드 때문에 순차적으로 만들어진다. (아래 참조)

```javascript
let b = 0;
const c = {
  [b++] : 1;
  [b++] : 2;
  // ...
  // ...
}
```

객체, 배열의 동작이 내부적으로 달라졌다. 특성이 다르므로 es6는 다 모른다고 보면 된다.



### WHILE문으로 살펴보는 ITERATOR

```javascript
const arr = [1,2,3,4,5];
while(arr.length > 0) {		// 계속 반복할지 판단
  console.log(arr.pop());	// 반복시마다 처리할 것 (함수와 같이 서브루틴으로 처리되는 경우도 많다.)
}
```

```javascript
// 이터레이터 인터페이스 기반으로 보자
{
  arr : [ 1,2,3,4,5],
  next : function() {
    return {
      done : arr.length === 0,  // 계속 반복할지 판단
      value: this.arr.pop()     // 반복시마다 처리할 것 
    }   
  } 
}
```

while구문에서는 계속 진행할지 안할지를 외부에 맡겼었는데, 아래의 구문에서는 진행할지에 대한 유무도 내부에서 통제, 처리하도록 했다. 이터레이터의 구조는 루프의 구조를 흉내내고 있다.이러한 차이를 흉내내서 값으로 바꾸었다. 하나는 값이고, 하나는 문이다. 값은 메모리 상의 저장, 할당될수 있지만, 문은 죽 실행되고 나서 사라진다. 문으로 루프를 돌리게 되면 재현 못하고, 원할 때 다시 실행할 수도 없고, 옛날 것을 복원할 ㅅ도 없다. 문으로 하는 것들은 대부분 휘발성이다. 문으로 하는 일을 값으로 바꾸지 않으면 대부분 휘발된다. 휘발되면 컴퓨터에 따라서 달라질수 잆고, 따라서 실행되는 타이밍이 달라질 수 있다. 문과 달리 값은 통제할 수가 있다.  next를 호출하지 않으면 그 다음 로직이 실행되지 않는다. next를 호출하지 않으면 반복이 일어나지 않는다. 이렇게 될 수 있는 이유는 값으로 정의하였기 때문이다. 함수를 호출하는 것을 지연실행이라고 부른다. 

원래 flow는 죽 흘러 간다. 하지만 이것을 하지못하게 하려면 지연을 시켜야 한다. 그러면 flow controll을 통해서 실행되지 못하게 막을 수 있다.  

```javascript
const a = b || c;
// b가 참이면 a에 b를 넣고 아니면 c를 넣는다. b가 falsy가 아니라면 연산이 아예되지 않으므로 연산을 지연시키는 것이다. 

const d = e && f;
// e가 참이 아니라면 f는 연산할 필요조차 없다. 이것도 마찬가지로 연산 지연이다.

const obj = {
  get a(){return 3;}
}
```

es5.0 이후에는 모든 프로퍼티는 함수가 호출될 가능성이 존재한다. 게터 세터 정의가 가능하기 때문이며 특히 프록시가 있어 더 심하다. () 이게 없어도 함수 호출이 가능한 것이다.

제어문을 이용한 지연이 가능하다. if , else 등.. 

lazy란? 원래는 한번에 다 실행되어야 하는데, 실행 도중에 실행을 미루거나 점프시킬수 있는 모든 행위는 지연실행이라고 부른다. 언제의 기준으로 lazy인가? 원래 코드를 짜면, 메모리에 올라가면 다 실행되는게 이미 결정이 나버린 것인데, 이 경우는 실행하다 즉 런타임에 결정이 된다는 것이다.그래서 레이지라고 부르는 것이다. 

제어문을 이용한 레이지 판단을 시킬 수 있고, 연산자를 이용한 것이 있고, 마지막으로 가장 활용성이 높은게 호출 지연이 있다. 코드를 함수에 가두면, 호출할 때까지는 그 코드가 실행되지 않는다. 

무언가 지연, 반복, 여러 번실행, 실행학 싶을때 실행 등을 하기 위해서 함수를 만든다. 함수를 실행했을 때 결과는 값이다. 그래서 우리는 값타입으로 바꾸거나 객체로 만들거나 함수로 만들어서 원하는 때에 실행할 수 있게끔 바꾼다. 이것이 지연실행 기법이다.

그런 의미에서 보면 문으로 되어 있는 이 제어문은 휘발성이다. 통제가 되질 않는다. 그에 비해서 이터레이터는 next를 호출하기 전까지는 다음번 루프가 실행되지 않는다. 원할때 루프를 진행할 수 있다. 어떠한 이유로? 값으로 바꾸고 함수의 호출지연을 사용하기 때문이다. 그래서 함수로가 호출될때까지 진행되지 않는다. 대신, 문은 실행을 엔진이 해준다. 하지만 우리가 만든 값은 실행기를 바깥에 두어야 한다. 누군가는 next를 호출할 실행기가 있어야 실행이가능하다. 따라서 실행기가 있고 공급기가 존재한다. 이러한 관점에서 보면, 

1. 반복자체를 하지는 않지만
2. 외부에서 반복을 하려고 할 때
3. 반복에 필요한 조건과 실행을
4. 미리 준비해둔 객체

=> 반복 행위와 반복을 위한 준비를 분리

1. 미리 반복에 대한 준비를 해두고
2. 필요할 때 필요한 만큼 반복
3. 반복을 재현할 수 잇다.

양키들은 모든 것을 명사로 만든다. 명사화 시킬려고 하는 것이다. 동양은 서술적인 묘사를 즐겨한다. 서양은 대상화를 하려고 한다. 양키들은 문을 대상으로 만드는 것을 좋아한다.

문은 외부에서 계속 통제를 해야 했다. 하지만 지금은 외부가 아닌 내부에 물어본다. 반복할지 안할지 자신이 결정한다. 외부에서는 니가 원할때까지 반복만 시켜줄께~ 한다. 이것을 객체라고 부른다. 객체는 여러가지 특징이 있는데 먼저 캡슐화, 다형성(내적 일관성, 대체가능성) 이 있다. 

캡슐화

은닉

남에게 안보여주면 은닉이다. 하지만 객체지향만이 은닉이 가능한 것이 아니다. 객체지향의 특성은 캡슐화이다. ATM기에서 돈을 인출하는 것. 고객에게 인노출된 인터페이스는 버튼을 누르면 돈이 나오는 것이지만, 실제로는 고나련 정보를 받아서 전송하고, 적절한 사람인지, 돈이 있는지 등을 확인하고.. 타등등 의 복잡한 과정을 거친다. 하지만 외부에선 그저 카드나 통장넣고 인출 누르세요~ 라고 한다.  캡슐화는 외부에는 내가 보여주고 싶은 행위, 결과를 보여주되 내부의 일은 안 보여준다. 이것의 장점은 내부의 보수와 외부의 사용을 격리시킬 숭 ㅣㅆ다. 프로그램의 목적인 격리이다. 내부의 수정사항이 잇는 것을 외부의 사람의 사용에 여파를 끼치지 않도록 하기 위해서 캡슐화를 사용한다. 

아까까지는 루프를 할때마다 외부코드에서 어떻게 할 것인지 햇어야 했는데 이제는 안쪽에 완전히 캡슐화되어 버리고, 외부에서는 done인지 아닌지만 확인하면 된다. 객체지향에서는 모든 문을 제거하려고 한다. 객체의 상태로 바꾸거나 객체의메서드에 위임하려고 한다. 

55분



이터레이터 코드를 보면 이러한 목적이 부합이 되는 것을 알수 있다. 아까까지는 매번 할때마다 바깥쪽 코드에서 제어 조건을 다 기술하고 관리했어야 했는데 지금은 안쪽에 완전히 캡슐화 되어 버리고 바깥쪽에서는 done인지 아닌지만 리턴하게 되는 것이다. 이러한 것이 객체지향때문에 나온 것이다. 객체지향에서는 모든 문을 제거하려고 한다. 객체의 상태 또는 메소드에 위임하려고 한다. 4 . 미리 준비한 객체가 나오는 것은 루프에 대한 실행과 조건을 다 캡슐화 했으니까, 실행 결과를 리턴하는 것 까지 전부 캡슐화되어 있다.  바깥쪽에서는 잔액 없음, 잇음 밖에 얻지 못한다. 즉 value와 done밖에 얻지 못한다. 기존에 문을 관리하던 책임에서 그 책임을 전부 객체에게 맡기고 우리는 그저 next만을 호출한다. 

**반복행위와 반복을 위한 준비를 분리**

반복행위 : 반복을 시키는 행위, 여기서는 next 호출을 말한다.

반복을 위한 준비 : 반복호출전에 코드에서, 상태에서의 값이나 기타등이 준비되는 것

행위와 내부 상태가 격리되니까 외부에서 몇번이든 계속 재현시킬 수 있다. 이터레이터 가지곤 부족하니까 이터러블이라는 준비과정을 둔 것이다. 이번에 이터레이터 다시 돌릴 건데 다시 초기화 하고 준비해야되지 않냐? 이러한 과정까지도 객체에게 위임하고 캡슐화하는 것이다. 니가 어떻게 준비하는지 잘 모르겠고, 이터레이터를 요구하는 타이밍에 이터러블 인터페이스를 다시 요구할 테니까 내가 심볼이터레이터를 부를때 재반복할수 있는 준비를 알아서 해라. 반복 준비한 다음에 다시 재현하고 통제할 수 잇다.

이러한 관점은 루프문을 컴파일러 수준에서 구성할 때 똑같은 일이 일어나는 것을 알수 있다. 그 구조를 컴파일러가 해주고 있는 것이다.



## ES6 + LOOP

니가 원하는 이터레이터 인터페이스를 준비하면 ES6에서는 스펙에 명시된 형태로 동작을 하게 된다. ES6에서는 어떻게 준비된 코드를 소비하게 될 것인가. ES6는 근본적으로 지연실행에 기반한 이터레이터 객체를 소비하는 형태로 되어 있다. 그 이전에는 문을 통한 플로우 컨트롤에 집중했다면,  6이후의 루프의 철학은 객체의 상태를 통한 지연 루프 혹은 값을 통한 루프 혹은 캡슐화를 통한 루프, 즉 언어에서는 실행만 책임지는 것이다. 안은 니 알아서 해.



### 사용자반복처리기

**직접 이터레이터 반복처리기를 구현**

```javascript
const loop = (iter, f) => {
  // iterable => iterator
  if(typeof iter[Symbol.iterator] == 'function') {
    iter = iter[Symbol.iterator]();
  }
  
  // not iteratorObject => pass
  if(typeof iter.next != 'function') return;
  
  while(true) {
    const v = iter.next();
    if(v.done) return; // quit
    f(v.value);	// pass current value
  }
}
```

es6문법안에서 무엇이 일어나는가

이터러블을 소비한다고 했다. 스펙에 따라서 이터레이터를 직접 소비하는 애들도 있다. 이터레이터를 보내도 실행해주고 이터러블을 보내도 실행해주기도 한다. 루프라는 함수를 구현하는데, 이터레이터 객체와 콜백함수를 받는다. 

이터객체가 심볼 이터레이터를 갖는지 조사해본다. 만약 그것을 함수 타입으로 갖고 있으면 이터러블 객체인 것이다. 이터러블이 이터레이터 메소드를 갖고 있다. 첫번째 줄이 의미하는 것은 이터라는 객체가 이터러블이라는 것의 증거를 나타낸다. 이터레이터라는 메소드를 갖고 있으면 그 객체는 이터러블 객체이구나. 이터러블 객체에게는 이터레이터 메소드를 호출하여 이터레이터 객체를 받을 수 있다.  



```javascript
/*
수동으로 구현한, 자바스크립트 이터레이터 이터러블 인터페이스을 구현한 객체를 소비하는 처리기이다.
이터러블 이터레이터 객체를 소비하는 소비자라고 할수 있다.
*/

const loop = (iter, f) => {
  // 이 코드가 의미하는 것은 if는 옵셔널, 이터러블이면 이터레이터로 바꿔줄 것이다. 없었다면 들어오는 값들은 전부 이터레이터로 볼것이다. 라는 것이다. 
  if(typeof iter[Symbol.iterator] == 'function') {
    iter = iter[Symbol.iterator]();
  }
  
  // 이터레이터의 특징은 next를 호출할 수 있다.
  // 이 시점에서 이터레이터이기를 원하는 것이다. 만약 next가 함수가 아니면 끝인 것이다.
  // 쉴드 패턴
  if(typeof iter.next != 'function') return;
  
  // 여기부터 iter은 무조건 iterator인 것이다.
  // 그 의미를 내포한 제어문을 짜보면 이렇게밖에 짤수 밖에 없다.
 
  // while은 실행기이다.
  while(true) {
    // 루프를 돌때마다 우리는 그저 next를 호출하면 되는 것이다.
    // 이때의 v값은 iterator result object 이다.
    const v = iter.next();
    
    // done이 트루이면 빠져나오면 된다.
    if(v.done) return; // quit
    
    // 만약 done으로 나가지 않았으면 해당 값으로 콜백함수 호출을 한다.
    f(v.value);	// pass current value
  }
}
```



구글링 해보면 기초가 제대로 나오는 경우가 잘 없다. 그러니 달달 외워야 한다. 이과생들은 대학교에 가면 태반이 누적해서 암기해야 가능하다. 대입 수준 이상의 꾸준한 공부를 하는 것은 이과생들이다. 문과애들은 벼락치기용 공부만 하다보니 그런 곳에서 밀리는 것이다.  외울때까지 공부해야 안 헷갈리고 제대로 쓸수 있다.

하나의 객체가 여러개의 인터페이스를 가질수 있다. 

```javascript

/*
이터러블이자 이터레이터이다. 
*/
const iter = {
  // 이터러블은 자신을 리턴하면 된다. 그러니 이터러블이다.
  [Symbo.iterator]() {
    return this;
  },
  // 이터레이터로서는 배열 루프 도는 것
  arr:[1, 2, 3, 4, 5],
  next() {
    return {
      done: arr.length == 0,
      value: this.arr.pop()
    };
  }
}

loop(iter, console.log);
```

우리는 루프 함수를 이용하면 이터러블이나 이터레이터 객체를 편하게 소비할수 있는 기반이 만들어 졌다.



### 내장반복처리기

**Array destructuring(배열 해체)**

이터러블 객체

… 해체 구문의 정체는 이터러블의 해체를 말한다. 이 해체구문의 대괄호 `[a, ...b]` 는 이터러블의 해체를 말하는 것이다. 여기서 이터러블 구문은 이터러블과 이터레이터를 둘다 받아준다. 언어의 요소에 따라서 어떤 녀석은 이터러블만, 어떤 녀석은 이터레이터 까지 다 받아준다. 해체구문은 둘다 받아준다. 진짜 이름은 iterable destructuring 이다. 그래서 이터러블을 만족하는 녀석을 보내보면 마찬가지로 잘 동작한다.

```javascript
const iter = {
  [Symbol.iterator]() {return this;},
  arr:[1,2,3,4],
  next() {
    return {
      done:this.arr.length === 0,
      value:this.arr.pop()
    };
  }
};

const [a,...b] = iter;
console.log(a,b);
```

```javascript
const iter2 = {
  [Symbol.iterator]() {return this;},
  number : 0,
  next() {
    return {
      done:this.number > 6,
      value:this.number <= 6 ? this.number++ : this.number
    };
  }
};

// const [c, ...d] = iter2;
//  console.log(c,d);		// 0, [1,2,3,4,5,6]

const [e,...f] = iter2[Symbol.iterator]();
console.log(e,f);
```

```javascript
//배열은 왜 되는 것일까?
const [a,...b] = [1,2,3,4];

// 배열에는 심볼 이터레이터 메소드가 있겠구나
const [c, ...d]] = [1,2,3,4][Symbol.iterator]();
console.log(typeof [][Symbol.iterator]); 
// 배열때문에 해체가 아니라 이터레이터가 있어서 해체가 된 것이다.
const [a1, h, ...a2] = 'ABCDEFG';
console.log(a1, h, a2);
console.log(""[Symbol.iterator]);
```

이것이 값과 행위자를 분리해서 일어나는 일이다. 이전의 for문, while문을 할때는 응용이 불가능 했다. 하지만 지금은 루프의 새로운 소비자인 이너레이터 해체, rest 연산자 (나머지를 다 호출해서 나온 것). 연산자가 소비하기도 하고 구문이 소비하기도 한다. 값으로 만들어놓은 바람에 기존에는 문밖에 안되었던 루프가 수많은 행위자들을 소비하기 시작했다. 지연실행 때문에. 누구라도 next만 호출하면 루프가 된다. 그래서 해체 구문이 하나 소비한 다음에 연산자가 이어받아서 나머지를 소비한다. 이러한 묘기가 가능한 것이다.  이제 루프는 자기가 상태를 관리하기 때문에 여러 소비자를 대응해 줄 수 있게 된 것이다.



내장반복 처리기, 처리기라는 것은 실행기, 실행기 중에는 첫번째로 해체, 그리고 나머지 연산자. 두가지가 소비를 하고 있었다.



**Spread(펼치기)**

```javascript
const iter = {
  [Symbol.iterator]() {return this;},
  arr:[1,2,3,4],
  next() {
    return {
      done:this.arr.length == 0,
      value:this.arr.pop()
    }
  }
}

const a = [...iter];
console.log(a);		// [4,3,2,1]
// 내부에서 소비를 죽 한다.
```

배열을 주는 것과 배열을 감싼 이터레이터가 있는 것과 무슨 차이가 있는 것일까? 통제권을 가지고 잇을 수 있다. 루프에 대한 조건을 객체가 캡슐화하기 때문에, 루프에 대한 조건을 외부가 아닌 객체 안에서 통제할 수 있다. 그렇다는 것은 클래스를 만들어서 생성자에서 어떻게 처리할지를 받아서 처리해 주고 외부에서 출력하면 객체가 더 많은 통제권을 가지게 될 것이다. 값이 되었든 반복에 대한 조건이 되었든. 그래서 루프와 소비자를 나눈 덕분에 서로 다른 길을 가게 되고 수정할수 있는 부분을 나눌 수 있다.



```javascript
class Iter {
  constructor({data, func}) {
	this.idx = 0;    
    this.data = data;
    this.func = func;
  }
  [Symbol.iterator]() {return this;}
  next() {
	const [done, value] = this.func();
    return {done, value};
  }
}

const iter1 = new Iter({
  data:[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20],
  func(one) {
    this.idx += 1;
    return [this.idx > this.data.length, this.data.filter(o=> o%this.idx===0)];
  }
});

const [a1, a2, a3, a4, ...a5] = iter1;
```



**Rest Parameter(나머지 인자)**

```javascript
const iter = {
  [Symbol.iterator](){return this;},
  arr:[1,2,3,4],
  next() {
    return {
      done:this.arr.length === 0,
      value:this.arr.pop()
    };
  }
}

const test = (...arg)=>console.log(arg);
test(...iter);  // [4, 3, 2, 1]
```

함수 인자에 점3개로 하면 함수 안에서 나눠져서 들어간다. 여러개의 인자로 받은 것을 하나의 배열로 만들어서 내부에 준다. 스프레드 연산자는 함수가 아닌 곳에서 쓰이고 있는 얘네들은 오히려 묶어서 죽 펼쳐주는 역할을 한다. 반면에 나머지 인자 연산자는 함수 선언시에 사용된다. 여러개의 인자들을 모아서 하나의 배열로 만들어주는 것이다. 함수에는 실제로 이터레이터를 보낼 때는 펼쳐서 보낸 것이다. 이것은 	test(4, 3, 2, 1)로 보낸 것이라고 보면된다. 그래서 레스트와 스프레드는 자주 쓰인다. 레스트로 보내고 스프레드로 소비한다. 이것들은 전형적인 한쌍이라고 보면 된다.

ES6에서는 보다 명확하게, 보다 단일한 규칙으로 하는 것을 추구한다. arguments와 다르게 코드로 봤더니 레스트로 사용한 arg가 그것을 받고 배열로 들어오는게 정상일 것이라고 읽는다. 그래서 레스트 오퍼레이터가 추가된 것이다. 레스트 오퍼레이터가 이터레이터를 소비하지는 않는다. 이것의 의미는 그저 무한 인자라는 의미이다. 그저 arguments를 코드상으로 명확하게 보여주는 문법이 추가된 것일 뿐이다. 다만 레스트 파라미터와 스프레드를 같이 쌍으로 쓰는 경우가 많다. 스프레드는 이터레이터 객체를 value값으로 다 풀어버린다. 레스트 파라미터 + 스프레드를 사용하면 apply, call이 다 없어진다. 이것들을 사용했던 모든 것들이 사라진다. 생성자의 인자는 apply, call 할수 없었지만 레스트 파라미터는 이제 가능하다. 함수만 한정적으로 보면 대체할수 있다고 생각하겠지만 생성자 까지 본다면 대체할 수가 없다.



**For of**

```javascript
const iter = {
  [Symbol.iterator](){return this;},
  arr:[1,2,3,4,5],
  next(){
    return {
      done:this.arr.length === 0,
      value:this.arr.pop()
    }
  }
}

for(const v of iter) {
  console.log(v);
}
```

기존에는 for, for in구문이 있었지만 이번에 이터레이터를 소비할 수 있는 for of 구문이 추가되었다. for of를 쓰면 앞쪽에 들어오는 값은 value, 뒤쪽에 오는 것은 이터레이터 또는 이터러블 객체가 올수 잇다. 이터레이터가 오면 마지막 done이 될때까지 죽 동작한다. 하지만 통제는 iter객체가 통제한다. 배열, 문자열, 이터레이터, 이터러블이 다 올수 있다. 이터러블, 이터레이터 객체 구현했다면 for of 를 쓸 것이다 .



### 연습

**제곱의 요소를 갖는 가상 컬렉션**

```javascript
const N2 = class {
  constructor(max) {
    // 처음에 인자값으로 max를 받아서 max를 알고 있는 상태이다.
    this.max = max;
  }
  [Symbol.iterator]() {
    // 이터레이터 만드는 과정을 보면 처음에 cursor를 0으로 두고,
    // max까지 증가하는 전략을 두고 있다.
    // 이터러블을 호출할 때마다 0부터 max전까지 루프를 도는 정책을 가지고 있는 것이다.
    // 객체별 정책을 만들수 잇다. 
    let cursor = 0,
        max = this.max;
    return {
      done:false,
      // next를 호출할 때마다 판단을 한다.
      // value는 원래부터 존재하지 않고 next호출할때마다 만들어준다.
      // 원하는 만큼 next를 호출해서 원하는 만큼 값을 만들어 주면되니까.
      // 루프를 값으로 바꾸었을때 연산이 개입하는 경우이다. 
      // 요소가 존재하지 않는 루프를 만드는 것이다. 
      next() {
        if(cursor > max) {
          this.done = true;
        }else {
          // 커서값을 이용해서 next가 함수니까 next입장에는 커서값이 자유변수이다.
          // 커서의 값은 계속 하나의 값으로 참조가 된다.그래서 this를 안써도 01234 올라간다.
          this.value = cursor * cursor;
          cursor++;
        }
        // this 가 이터레이터 객체이면서 이터레이터 리절트 오브젝트이기도 하다.
        // 여러개 가질수 있다. next만 보고 이터레이터라고만 생각하면 안된다.
        // done과 value가 있으니 이터레이터 리절트 객체이기도 한 것이다.
        // 이러한 것이 덕타입의 파워이다.
        // 덕타입은 진짜 클래스가 무엇인지 관심이 없다. 그 메소드와 값만 있으면 된다.
        // 덕타입의 파워가 있기 때문에 오브젝트 재활용이 되는 것이다.
        
        return this;
      }
    }
  }
}
```

배열을 이미 확정된 값으로 루프를 돌았다. 하지만 얘는 next를 할 때마다 함수를 호출한다. 그렇다는 것은 지연을 시킬 수 잇다는 것이다. 각 루프 단계에 필요한 값을 미리 갖고 있지 않아도 된다는 것이다. 왜냐면 함수가 호출될 때마다 만들면 되니까. next할때마다 만들면 되니까 배열 값들을 미리 갖고 있어야할 필요가 없다.



```javascript
// new N2(5)는 이터러블 객체이다. 이것이 이터레이터를 리턴하고
// 그것이 동작하면서 done과 value를 리턴할 것이다.
console.log([...new N2(5)]);

// for of도 마찬가지이다.
for(const v of new N2(5)) {
  console.log(v);
}
```



# GENERATOR

가장 쉬운 단계는 이터레이터 제너레이터 라고 해석하는 경우이다. 가장 쉽게 쓰는 예이다.

이터레이터 제너레이터는 이터러블이다. 이터레이터를 만드는게 이터러블이니까, 이터레이터를 만든다는 의미에서 이터러블과 제네레이터가 하는일이 똑같다. 이터러블은 심볼 이터레이터를 호출하는 것의 반환값으로 그때마다 이터레이터를 만들어내고 있다. 제네레이터는 제네레이터 함수를 호출하면 그 결과가 이터레이터가 나온다. 따라서 for에 제네레이터를 그냥 줄수는 없다. 하지만 굉장히 이터러블과 비슷한데 억울할 것이다.제네레이터를 호출한 결과는 이터레이터니까for of에게 줄수 있다. 그러면 제네레이터는 어떻게 해서 이터레이터를 만들까? 

이터러블, 이터레이터를 만드는 과정은 쉽지 않다. 이터러블 인터페이스, 이터레이터 인터페이스, 이터레이터 리절트 오브젝트 인터페이스로 외워야 한다. 그래서 이것을 외우지 않은 문법적 장치를 해준다. 그게 제네레이터이다.

```javascript
const g2 = function*(max) {
  // 이터레이터의 커서와 다르게 여기서는 지역변수로 잡았다.
  // 지역변수로 그냥 잡아서 쓰면된다. 이터레이터에서는 자유변수나 속성(내부프로퍼티)으로 쓴 것이다. 
  let cursor = 0;
  // while이 이터레이터의 next역할을 한다.
  while(cursor < max) {
    yield cursor * cursor;
    cursor++;
  }
  // 이터레이터에서 done이 true가 되는 시점이 제네레이터에서는 그저 함수를 빠져나오면 되는 것이다.
  // 이렇게 깔끔하게 대체할수 있게 된다. 
  // 이터레이터에서는 객체를 리턴했으니까 next가 사용할수 있는게 뭐다?객체가 계속 next하는 상태를 유지하려면 얘의 객체에 있는 this의 속성을 사용하든지 함수를 매번 만들어서 자유변수를 사용하던지해서 외재화되어 있는 상태를 이용해야지만 next의 일관성을 캡슐화할수 있을 것이다. 내가 몇번째 넥스트인지를 알려면 어딘가 기록해야 한다. 왜냐면 얘가 오브젝트이니까 밖에서 넥스트를 부르면 몇번째 넥스트인지는 상태를 외재화 시켜야 하는 것이다.이 함수의 지역변수면 사라진다. 그래서 자유변수를 쓰든 속성을 쓰든 둘중 하나이다. 넥스트 함수안에 둘수는 없다.그래서 복잡한 코드가 될 것이다.
  // 그에 비해서 문으로 바꾼 제네레이터는  지역변수와 for문이 끝이다.우리가 원래 제어문으로 짜던식으로 짜면 된다. 나머지는 for문을 멈출줄 아는 제네레이터 블록이 알아서 한다. 따라서 우리는 지역변수를 쓸수 있다.이게 복잡성을 크게 낮춘다.관리할 대상이 훨씬 줄어들어서.. 
}
```

제네레이터는 펑션 에스터레스크* 를 써야 한다. 함수랑 똑같이 보인다. 인자도 받고 하니까. 하지만 이것은 return이 없다. 이것을 호출하면 이터레이터 객체가 만들어진다. 커서가 0이고 맥스보다 작은경우에 계속돈다.리턴 대신에 일드를 한다. 일드는 value에 해당할 것이라고 예상할 수 있다. 일드하는 동안은 done이 false이겠지만 함수를 빠져나가면 done이 true이겠구나. 이렇게 되는 이터레이터 오브젝트를 만들어서 반환하는 것을 언어가 감추고서 문법으로 노출한 것이 바로 제네레이터 구문일 것이다.



플로우 컨트롤 하는 문을 제어할수 없다.언어가 실행되면 무조건 실행된다고 했다. 하지만 여기서는 while문을 쓰고 있는데 왜 중간에 멈추는 것인가? 제네레이터는 제어문을 멈출줄 안다. 일반적인 함수라는 것은 일반적인 플로우에서는 들어오면 나가지지만, 제네레이터는 next를 호출하지도 않았는데 멈췄다가 그다음번 next에 또 들어온다. 그것도 처음부터 다시 들어오는게 아니라 멈춘 지점부터 다시 시작한다.  제네레이터는 중간에 빠져나갔다가 들어올떄는 그다음부분으로 들어온다. 이게 코루틴의 기초이다. 일반적인 루틴은 진입점이 제일위고 반환점이 아래에 몰려 있는데, 코루틴은 여러번 진입하고 진입할때의 포인트로 여러곳에 있다. 

그래서 이게 똑같이 이터레이터 객체를 만들어낸다. 여기서 센스가 필요하다. 그전까지는 상태를 직접 관리해서 next함수에서 어떻게 상태를 조절할 지에 대한 판단을 이터러블, 이터레이터에 넣어놓앗었는데, 제어문을 쓰는데도 불구하고 이 제어문이 지연실행을 일으킨다. 따라서 while문은 평범한 while문이 아니다.일드가 있으므로서 지연실행을 일으킬 수 있는 while이다.그것이 바로 제네레이터 블럭이다. 이 블럭은 코루틴 블럭이라서 플로우의 일방적인 흐름을 만들지 않고 지연 실행, 마치 함수를 호출하는 것 처럼 지연을 만들 수 있다. 이 제네레이터 구문은 대부분의 모던 랭귀지에 채용이 되어 있다. 옛날의 단순 for문 에서 발전해서 이제는 루프를 상태로바꿀줄 알게 되었고, 실행기의 다양한 형태를 만들줄도 알게 되었고 기존의 제어문을 코루틴이라는 고도화되어 있는 루프로 바꾸어서 다시 제어문으로 돌릴수도 있게 된 것이다. 

진보되어 있는 루프에 대한 사용법, 철학, 개념을 이제 자바스크립트도 채용하게 된 것이다. 현대의 루프는 상태를 이용하고, 캡슐화를 이용하고 소비층을 만들고 다시 그것을 소비하는 코루틴문을 이용해서 다시 제어문을 되돌릴 수도 있다.



위의 코드 주석 내용임



```javascript
// 소비하는 방법
console.log([...g2(5)]);
// [0, 1, 4, 9, 16]

for(const v of g2(5)) {
  console.log(v);
}
```

소비하는 방법은 간단하다. 제네레이터를 호출하면 이터레이터가 반환된다. 그래서 소비할수 잇다 스프레드, for of가 소비할 수 잇다.