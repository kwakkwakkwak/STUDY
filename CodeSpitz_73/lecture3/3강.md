# 3강

## INTERFACE

자바스크립트에서 인터페이스는 고유명사이다.

1 . 인터페이스란 사양에 맞는 값과 연결된 속성키의 셋트  
2 . 어떤 oBJECT라도 인터페이스의 정의를 충족시킬 수 있다.  
3 . 하나의 Object는 여러개의 인터페이스를 충족시킬 수 있다.

자바스크립트에서도 오브젝트나 클래스가 여러 인터페이스를 충족시킬수 있다. 중요한 것은 1번이다. 

<br/>

### INTERFACE TEST

1 . test라는 키를 갖고  
2 . 값으로 문자열인자를 1개 받아 불린 결과를 반환하는 함수가 온다.

```javascript
{
  test: function(str){return true;}
}

// test라는 key, value자리에 문자 인자 하나 받고 불린 결과 반환하는 함수가 있다는 요구조건만 맞으면 어떻게 함수를 짜든 상관이 없다.
const object = {
  test(str) {
    return true;
  }
}

const Test = class {
  test(str) {
    return true;
  }
}

// 클래스 정의에서 인터페이스를 만족시키면 그 인스턴스들은 자동으로 원래 인터페이스의 요구사항을 맞출수 있을 것이다.
const test = new Test;
```

<br/>

클래스가 인터페이스를 구현하고 있을 뿐이지, 테스트가 있다는 것을 보장하지는 않는다. 동적언어에서는 말이다. test가 Test클래스의 인스턴스인 것은 확인할 수 있지만, 그렇다고 해서 test라는 메소드를 가지고 있는지를 보장되지 않는다. 그냥 Test의 인스턴스일 뿐이다. 그래서 런타임, 컴파일에러가 일어나지 않는다. 이것을 일으키는 유일한 방법은 상속구조를 이용해서 throw를 던져줄 수 밖에 없다. 그렇기는 하지만 그럼에도 불구하고 어떤 객체가 느슨하게 인터페이스를 구현했다면, 상관하지 않겠어. 그것이 덕타이핑이라고 한다. 이 클래스가 실제로 무엇을 하든지 간에 해당 인터페이스의 조건을 만족하지만 한다면, 그 인터페이스의 구상체로 볼 것이다. 이것이 원래 무엇을 하는지는 상관 없고 원하는 인터페이스를 잘 구현하기만 했다면 이것을 테스트 인터페이스를 사용할 수 있는 객체로 볼것이다. 이것이 덕타입이다. 이것을 쓰는 이유는 런타임에는 컴파일타임의 타입체크가 되지 않기 때문에 쓴다. 

이것이 어려운 점은 이것은 우리 머릿속에 있는 약속이라는 점이다. 우리가 테스트 인터페이스를 구현할 수 있는 이유는, 하나만 기억하면되고 간단하기 때문이다. 실제 어플리케이션에서는 인터페이스를 200개 이상되면 사용할수 있을까? 실제 덕타입들은 이러한 문제를 가지고 있다.

여튼 JS의 인터페이스는 덕타이핑을 구현하기로 약속한 프로토콜 같은 것이다. 



## ITERATOR INTERFACE

1 . next라는 키를 갖고  
2 . 값으로 인자를 받지 않고 IteratorResultObject를 반환하는 함수가 온다.  
3 . IteratorResultObject는 value와 done라는 키를 갖고 있다.  
4 . 이중에서 done은 계속 반복할 수 있을지 없을지에 따라 불린 값을 반환한다.

자바스크립트에서 미리 규정하고 있는 인터페이스들이 있다. 약 18가지 정도 되는데 더 늘어나고 있다. 그리고 반복문과 관련된 인터페이스에는 Iterable, Iterator가 있다. 

자바스크립트 표준에 존재하는 이터레이터 인터페이스는 1 ~ 4 까지를 요구한다.  참고로 인터페이스가 인터페이스를 부르는 경우가 많다.

```javascript
//////////////////////////////////////////////
{
  next: function() {
    return {value:1, done:false}
  }
}
//////////////////////////////////////////////
{
  data:[1,2,3,4],
    next: function() {
      return {
        done:this.data.length === 0,
        value:this.data.pop()
      }
    }
}
//////////////////////////////////////////////
const iter = {
  data:[1,2,3,4],
    next() {
      return {
        done:this.data.length === 0,
        value:this.data.pop()
      }
    }
}
```

이렇게 충족하는 객체는 만드는 이유는 소비하는 측이 있기 때문이다. 소비하는 측에서는 이러한 이터레이터 리저트 오브젝트를 요구하는 이유는 계속 next를 부를지 말지를 판정하기 위함이다. value는 그때그때 값을 얻어내기 위함이다. 

어디다가 쓸까? 코드를 보면 data라는 키에 데이터가 담겨 있다. 이것은 외부에 보이지 않는 자신만의 데이터이다. next를 호출할 때마다 본인의 데이터가 length가 0인지 체크하고, value에는 데이터의 pop()이 이루어진다. 





## ITERABLE INTERFACE

1 . Symbol.iterator라는 키를 갖고  
2 . 값으로 인자를 받지 않고 Iterator Object를 반환하는 함수가 온다.

이터레이터 인터페이스를 구현한 것이 이터레이터 오브젝트인데, 이것을 반환하는 함수가 필요하다는 것이다. 이터러블은 이터레이터 오브젝트를 반환한다. 

```javascript
const iterator = {
  data:[1,2,3,4],
    next() {
      return {
        done:this.data.length === 0,
        value:this.data.pop()
      }
    }
}

const iterable = {
  // symbol.iterator에 함수를 넣는다.
  [Symbol.iterator]() {
    return iterator;
  }
}
```

Symbol은 참조가 아니라 복사가 일어난다. 모든 심볼은 유니크 값이다. 이러한 심볼을 오브젝트의 키로 사용하려면 계산된 오브젝트 이름이라는 ES6문법을 사용해야 한다. `[ ]` 로 감싸면 된다. Symbol은 new를 사용하지 않고 `Symbol(value)` 로 사용한다.  `Symbol.iterator` 와 같은 부류들은 이미 언어에서 규정되어 내장되어 있다. well-known symbol은 문자열(@@)로 대체가 가능하다. 키가 변수의 명령 규칙이 맞지 않을 때에도 계산된 오브젝트 이름을 사용해야 한다. 

```
[Symbol.iterator]와 ['@@iterator'] 는 동일하게 동작한다. 
```

이터러블 인터페이스의 키가 이터레이터이다. 그 이유는 이 메소드가 반환하는 것이 이터레이터 이기 때문이다.  이 메서드의 요구사항이 이터레이터를 반환하는 것이다. @@iterator은 향후 스펙에서 바뀔수 있기 때문에 [Symbol.iterator] 로 써야 한다. 예전 엔진 개발하던 사람들이 사용하던 흔적인 것이다.



```javascript
const Iterator = class {
  constructor() {
    this.data = [1,2,3,4];
  }
  next() {
    return {
      done: this.data.length === 0,
      value: this.data.pop()
    }
  }
}

const s = Symbol();
const iterable = {
  // symbol.iterator에 함수를 넣는다.
  [Symbol.iterator]() {
    return new Iterator();
  }
}
iterable['@@iterator']
```

이때마다 new iterator를 하면 새롭게 반복할수 있는 이터레이터를 얻게 된다. 이터러블이 존재하는 이유는 이터레이터만 있으면 한번 반복되고 나면 없어지는데, 그것 원본은 그대로 둔 상태에서, 계속해서 반복가능한 객체를 얻기 위해서, 이터러블이라는 중간층을 하나 더 두는 것이다. 이렇게 하면 이터러블을 통해서 이터레이터를 얻을 때마다 새롭게 반복시킬수 있는 객체를 얻을 수 있을 것이다. 이것이 이터러블 인터페이스이다.

요구할 때에는 대부분 이터러블을 요구한다. 이터러블만 받아주는, 이터러블과 이터레이터를 다 받아주는 문법도 존재한다.



```javascript
{
  [Symbol.iterator]:function() {
    return {
      next: runction() {
      return {value:1, done:false};
    };
  }
}
```

이터레이터는 next라는 함수를 갖고 있는, (value, done을 반환하는) 이터레이터 오브젝트 리절트를 반환하는 이 함수를 갖고 있는 이 객체를 반환하면 된다. 이것이 최소 구현이다. 이것이 우리의 이터러블 인터페이스를 만족하기 때문이다.



## LOOP

지금까지 우리는 인터페이스에 대한 개념과 내부에 내장되어 잇는 표준 인터페이스 2가지가 무엇이고 어떻게 구현하는지를 알아 보앗다. 자바스크립트 6.0 이후는 내부에 인터페이스라는 개념이 구현되어서 덕 타이핑을 할 수 있는 인터페이스 표준이 있고, 만약에 언어에서 인터페이스를 요구하면 인터페이스의 스펙대로 만들어줘야 한다. 자바스크립트에서는 다양한 인터페이스를 요구한다. 스펙에 있으며 그 스펙에 따라서 최소구현이나 그 이상으로 의미 구현을 할 수 잇다.

하지만 이터러블은 이미 배열, 문자 등등에서 구현하고 있다. 자바스크립트 6 이후에는 엔진도 바뀌었고, 자바스크립트의 코어 오브젝트라 불리는 것들의 동작도 바뀌었다. 

예전에는 for in 으로 오브젝트를 순회할 경우 키가 랜덤하게 나왔다. 순서 보장이 되지 않았다. 하지만 es6에서는 오브젝트에 키 정렬 순서라는 것이 생겼다. 숫자로 반환될 수 잇는 문자열들이 먼저 숫자 크기대로 정렬이 되고, 그다음에 알파벳, 그다음에 심볼끼리 정렬이 된다. 순회와 별개로 생성할 때에는 순차적으로 생성이 된다. 계산되는 필드 때문에 순차적으로 만들어진다. (아래 참조)

```javascript
let b = 0;
const c = {
  [b++] : 1;
  [b++] : 2;
  // ...
  // ...
}
```

객체, 배열의 동작이 내부적으로 달라졌다. 특성이 다르므로 es6는 다 모른다고 보면 된다.



### WHILE문으로 살펴보는 ITERATOR

```javascript
const arr = [1,2,3,4,5];
while(arr.length > 0) {		// 계속 반복할지 판단
  console.log(arr.pop());	// 반복시마다 처리할 것 (함수와 같이 서브루틴으로 처리되는 경우도 많다.)
}
```

```javascript
// 이터레이터 인터페이스 기반으로 보자
{
  arr : [ 1,2,3,4,5],
  next : function() {
    return {
      done : arr.length === 0,  // 계속 반복할지 판단
      value: this.arr.pop()     // 반복시마다 처리할 것 
    }   
  } 
}
```

while구문에서는 계속 진행할지 안할지를 외부에 맡겼었는데, 아래의 구문에서는 진행할지에 대한 유무도 내부에서 통제, 처리하도록 했다. 이터레이터의 구조는 루프의 구조를 흉내내고 있다.이러한 차이를 흉내내서 값으로 바꾸었다. 하나는 값이고, 하나는 문이다. 값은 메모리 상의 저장, 할당될수 있지만, 문은 죽 실행되고 나서 사라진다. 문으로 루프를 돌리게 되면 재현 못하고, 원할 때 다시 실행할 수도 없고, 옛날 것을 복원할 ㅅ도 없다. 문으로 하는 것들은 대부분 휘발성이다. 문으로 하는 일을 값으로 바꾸지 않으면 대부분 휘발된다. 휘발되면 컴퓨터에 따라서 달라질수 잆고, 따라서 실행되는 타이밍이 달라질 수 있다. 문과 달리 값은 통제할 수가 있다.  next를 호출하지 않으면 그 다음 로직이 실행되지 않는다. next를 호출하지 않으면 반복이 일어나지 않는다. 이렇게 될 수 있는 이유는 값으로 정의하였기 때문이다. 함수를 호출하는 것을 지연실행이라고 부른다. 

원래 flow는 죽 흘러 간다. 하지만 이것을 하지못하게 하려면 지연을 시켜야 한다. 그러면 flow controll을 통해서 실행되지 못하게 막을 수 있다.  

```javascript
const a = b || c;
// b가 참이면 a에 b를 넣고 아니면 c를 넣는다. b가 falsy가 아니라면 연산이 아예되지 않으므로 연산을 지연시키는 것이다. 

const d = e && f;
// e가 참이 아니라면 f는 연산할 필요조차 없다. 이것도 마찬가지로 연산 지연이다.

const obj = {
  get a(){return 3;}
}
```

es5.0 이후에는 모든 프로퍼티는 함수가 호출될 가능성이 존재한다. 게터 세터 정의가 가능하기 때문이며 특히 프록시가 있어 더 심하다. () 이게 없어도 함수 호출이 가능한 것이다.

제어문을 이용한 지연이 가능하다. if , else 등.. 

lazy란? 원래는 한번에 다 실행되어야 하는데, 실행 도중에 실행을 미루거나 점프시킬수 있는 모든 행위는 지연실행이라고 부른다. 언제의 기준으로 lazy인가? 원래 코드를 짜면, 메모리에 올라가면 다 실행되는게 이미 결정이 나버린 것인데, 이 경우는 실행하다 즉 런타임에 결정이 된다는 것이다.그래서 레이지라고 부르는 것이다. 

제어문을 이용한 레이지 판단을 시킬 수 있고, 연산자를 이용한 것이 있고, 마지막으로 가장 활용성이 높은게 호출 지연이 있다. 코드를 함수에 가두면, 호출할 때까지는 그 코드가 실행되지 않는다. 

무언가 지연, 반복, 여러 번실행, 실행학 싶을때 실행 등을 하기 위해서 함수를 만든다. 함수를 실행했을 때 결과는 값이다. 그래서 우리는 값타입으로 바꾸거나 객체로 만들거나 함수로 만들어서 원하는 때에 실행할 수 있게끔 바꾼다. 이것이 지연실행 기법이다.

그런 의미에서 보면 문으로 되어 있는 이 제어문은 휘발성이다. 통제가 되질 않는다. 그에 비해서 이터레이터는 next를 호출하기 전까지는 다음번 루프가 실행되지 않는다. 원할때 루프를 진행할 수 있다. 어떠한 이유로? 값으로 바꾸고 함수의 호출지연을 사용하기 때문이다. 그래서 함수로가 호출될때까지 진행되지 않는다. 대신, 문은 실행을 엔진이 해준다. 하지만 우리가 만든 값은 실행기를 바깥에 두어야 한다. 누군가는 next를 호출할 실행기가 있어야 실행이가능하다. 따라서 실행기가 있고 공급기가 존재한다. 이러한 관점에서 보면, 

1. 반복자체를 하지는 않지만
2. 외부에서 반복을 하려고 할 때
3. 반복에 필요한 조건과 실행을
4. 미리 준비해둔 객체

=> 반복 행위와 반복을 위한 준비를 분리

1. 미리 반복에 대한 준비를 해두고
2. 필요할 때 필요한 만큼 반복
3. 반복을 재현할 수 잇다.

양키들은 모든 것을 명사로 만든다. 명사화 시킬려고 하는 것이다. 동양은 서술적인 묘사를 즐겨한다. 서양은 대상화를 하려고 한다. 양키들은 문을 대상으로 만드는 것을 좋아한다.

문은 외부에서 계속 통제를 해야 했다. 하지만 지금은 외부가 아닌 내부에 물어본다. 반복할지 안할지 자신이 결정한다. 외부에서는 니가 원할때까지 반복만 시켜줄께~ 한다. 이것을 객체라고 부른다. 객체는 여러가지 특징이 있는데 먼저 캡슐화, 다형성(내적 일관성, 대체가능성) 이 있다. 

캡슐화

은닉

남에게 안보여주면 은닉이다. 하지만 객체지향만이 은닉이 가능한 것이 아니다. 객체지향의 특성은 캡슐화이다. ATM기에서 돈을 인출하는 것. 고객에게 인노출된 인터페이스는 버튼을 누르면 돈이 나오는 것이지만, 실제로는 고나련 정보를 받아서 전송하고, 적절한 사람인지, 돈이 있는지 등을 확인하고.. 타등등 의 복잡한 과정을 거친다. 하지만 외부에선 그저 카드나 통장넣고 인출 누르세요~ 라고 한다.  캡슐화는 외부에는 내가 보여주고 싶은 행위, 결과를 보여주되 내부의 일은 안 보여준다. 이것의 장점은 내부의 보수와 외부의 사용을 격리시킬 숭 ㅣㅆ다. 프로그램의 목적인 격리이다. 내부의 수정사항이 잇는 것을 외부의 사람의 사용에 여파를 끼치지 않도록 하기 위해서 캡슐화를 사용한다. 

아까까지는 루프를 할때마다 외부코드에서 어떻게 할 것인지 햇어야 했는데 이제는 안쪽에 완전히 캡슐화되어 버리고, 외부에서는 done인지 아닌지만 확인하면 된다. 객체지향에서는 모든 문을 제거하려고 한다. 객체의 상태로 바꾸거나 객체의메서드에 위임하려고 한다. 

55분



이터레이터 코드를 보면 이러한 목적이 부합이 되는 것을 알수 있다. 아까까지는 매번 할때마다 바깥쪽 코드에서 제어 조건을 다 기술하고 관리했어야 했는데 지금은 안쪽에 완전히 캡슐화 되어 버리고 바깥쪽에서는 done인지 아닌지만 리턴하게 되는 것이다. 이러한 것이 객체지향때문에 나온 것이다. 객체지향에서는 모든 문을 제거하려고 한다. 객체의 상태 또는 메소드에 위임하려고 한다. 4 . 미리 준비한 객체가 나오는 것은 루프에 대한 실행과 조건을 다 캡슐화 했으니까, 실행 결과를 리턴하는 것 까지 전부 캡슐화되어 있다.  바깥쪽에서는 잔액 없음, 잇음 밖에 얻지 못한다. 즉 value와 done밖에 얻지 못한다. 기존에 문을 관리하던 책임에서 그 책임을 전부 객체에게 맡기고 우리는 그저 next만을 호출한다. 

**반복행위와 반복을 위한 준비를 분리**

반복행위 : 반복을 시키는 행위, 여기서는 next 호출을 말한다.

반복을 위한 준비 : 반복호출전에 코드에서, 상태에서의 값이나 기타등이 준비되는 것

행위와 내부 상태가 격리되니까 외부에서 몇번이든 계속 재현시킬 수 있다. 이터레이터 가지곤 부족하니까 이터러블이라는 준비과정을 둔 것이다. 이번에 이터레이터 다시 돌릴 건데 다시 초기화 하고 준비해야되지 않냐? 이러한 과정까지도 객체에게 위임하고 캡슐화하는 것이다. 니가 어떻게 준비하는지 잘 모르겠고, 이터레이터를 요구하는 타이밍에 이터러블 인터페이스를 다시 요구할 테니까 내가 심볼이터레이터를 부를때 재반복할수 있는 준비를 알아서 해라. 반복 준비한 다음에 다시 재현하고 통제할 수 잇다.

이러한 관점은 루프문을 컴파일러 수준에서 구성할 때 똑같은 일이 일어나는 것을 알수 있다. 그 구조를 컴파일러가 해주고 있는 것이다.



## ES6 + LOOP

니가 원하는 이터레이터 인터페이스를 준비하면 ES6에서는 스펙에 명시된 형태로 동작을 하게 된다. ES6에서는 어떻게 준비된 코드를 소비하게 될 것인가. ES6는 근본적으로 지연실행에 기반한 이터레이터 객체를 소비하는 형태로 되어 있다. 그 이전에는 문을 통한 플로우 컨트롤에 집중했다면,  6이후의 루프의 철학은 객체의 상태를 통한 지연 루프 혹은 값을 통한 루프 혹은 캡슐화를 통한 루프, 즉 언어에서는 실행만 책임지는 것이다. 안은 니 알아서 해.



### 사용자반복처리기

**직접 이터레이터 반복처리기를 구현**

```javascript
const loop = (iter, f) => {
  // iterable => iterator
  if(typeof iter[Symbol.iterator] == 'function') {
    iter = iter[Symbol.iterator]();
  }
  
  // not iteratorObject => pass
  if(typeof iter.next != 'function') return;
  
  while(true) {
    const v = iter.next();
    if(v.done) return; // quit
    f(v.value);	// pass current value
  }
}
```

es6문법안에서 무엇이 일어나는가

이터러블을 소비한다고 했다. 스펙에 따라서 이터레이터를 직접 소비하는 애들도 있다. 이터레이터를 보내도 실행해주고 이터러블을 보내도 실행해주기도 한다. 루프라는 함수를 구현하는데, 이터레이터 객체와 콜백함수를 받는다. 

이터객체가 심볼 이터레이터를 갖는지 조사해본다. 만약 그것을 함수 타입으로 갖고 있으면 이터러블 객체인 것이다. 이터러블이 이터레이터 메소드를 갖고 있다. 첫번째 줄이 의미하는 것은 이터라는 객체가 이터러블이라는 것의 증거를 나타낸다. 이터레이터라는 메소드를 갖고 있으면 그 객체는 이터러블 객체이구나. 이터러블 객체에게는 이터레이터 메소드를 호출하여 이터레이터 객체를 받을 수 있다.  



```javascript
/*
수동으로 구현한, 자바스크립트 이터레이터 이터러블 인터페이스을 구현한 객체를 소비하는 처리기이다.
이터러블 이터레이터 객체를 소비하는 소비자라고 할수 있다.
*/

const loop = (iter, f) => {
  // 이 코드가 의미하는 것은 if는 옵셔널, 이터러블이면 이터레이터로 바꿔줄 것이다. 없었다면 들어오는 값들은 전부 이터레이터로 볼것이다. 라는 것이다. 
  if(typeof iter[Symbol.iterator] == 'function') {
    iter = iter[Symbol.iterator]();
  }
  
  // 이터레이터의 특징은 next를 호출할 수 있다.
  // 이 시점에서 이터레이터이기를 원하는 것이다. 만약 next가 함수가 아니면 끝인 것이다.
  // 쉴드 패턴
  if(typeof iter.next != 'function') return;
  
  // 여기부터 iter은 무조건 iterator인 것이다.
  // 그 의미를 내포한 제어문을 짜보면 이렇게밖에 짤수 밖에 없다.
 
  // while은 실행기이다.
  while(true) {
    // 루프를 돌때마다 우리는 그저 next를 호출하면 되는 것이다.
    // 이때의 v값은 iterator result object 이다.
    const v = iter.next();
    
    // done이 트루이면 빠져나오면 된다.
    if(v.done) return; // quit
    
    // 만약 done으로 나가지 않았으면 해당 값으로 콜백함수 호출을 한다.
    f(v.value);	// pass current value
  }
}
```



구글링 해보면 기초가 제대로 나오는 경우가 잘 없다. 그러니 달달 외워야 한다. 이과생들은 대학교에 가면 태반이 누적해서 암기해야 가능하다. 대입 수준 이상의 꾸준한 공부를 하는 것은 이과생들이다. 문과애들은 벼락치기용 공부만 하다보니 그런 곳에서 밀리는 것이다.  외울때까지 공부해야 안 헷갈리고 제대로 쓸수 있다.

하나의 객체가 여러개의 인터페이스를 가질수 있다. 

```javascript

/*
이터러블이자 이터레이터이다. 
*/
const iter = {
  // 이터러블은 자신을 리턴하면 된다. 그러니 이터러블이다.
  [Symbo.iterator]() {
    return this;
  },
  // 이터레이터로서는 배열 루프 도는 것
  arr:[1, 2, 3, 4, 5],
  next() {
    return {
      done: arr.length == 0,
      value: this.arr.pop()
    };
  }
}

loop(iter, console.log);
```

우리는 루프 함수를 이용하면 이터러블이나 이터레이터 객체를 편하게 소비할수 있는 기반이 만들어 졌다.



### 내장반복처리기

```javascript

```









