# javascript  스터디

학습 팁 : 언어 학습할 때 이해를 돕는 방식

1. 학습을 하면서 가설을 만들어 본다.
2. 그 가설을 검증한다. ( 답을 먼저 보는게 아니라 문제부터 푸는 것 )

마찬가지로 책 설명을 먼저 보고 예제 보지 않고 만든 다음에 예제와 비교해보는 것이 좋다.



초기화 : 선언과 동시에 값을 할당하는 것이다.

대입 : 값을 할당한다.

자료형이 결정된다는 것은 자료 크기가 정해진다는 것이다.

콜백 : 원래는 호출하지만, 그 호출을 위임하는 것이다. 그리고 위임받은 쪽이 호출하고 백해준다.

변수에서 체크해야 하는 것은 스코프이다. 컴퓨터는 애매한 것, 모호한 것을 싫어한다.

함수 스코프가 만들어져 있을려면 해당 스코프 안의 변수가 다 만들어져 있어야 한다.

변수를 만드는 시점, 변수에 값을 할당하는 시점이 다르며 변수를 만드는 것을 먼저 실행한다.

호이스팅을 하는 이유는 애매한 것을 줄이기 위해서 이다. 그래서 대입과 선언으로 나눈다음 선언을 먼저 처리하는 것이다. 

블럭스코프에서 변수가 사라지면 그만큼 메모리가 사라지고 그만큼 아낄 수 있다.

parseInt 같은 파싱 함수는 꼭 필요할 때만 쓰자. 원래 파싱하는 것들은 느리다.

컴퓨터는 임의로 판단하지 못하므로, 손해가 없는 쪽으로 계산한다. 



### JS의 타입

- Number, String, Boolean, Function, Symbol (es6추가), Undefined, Null
- Object
  - Function, Array, Date, RegExp, Error



String :  문자열은 길이가 가변이라 객체로 봐야 하지만 JS에서는 기본형으로 해놓고 내부로 숨겼다.

NaN : 타입은 number인데, 숫자로 표현할수 없는 데이터가 있을 때 뜬다.

null : 해당 공간, 참조형(그릇 : obect )은 있지만 그안에 참조 값이 없는 것이다. 즉, 가리키는 값이 없다.

undefined : 자료형, 값이 정의되지 않았다. 타입에도 undefined가 있다. 정해지지 않았기 때문에 연산을 할수가 없다.

자바스크립트에서는 자료형이 값을 넣는 순간에 정해진다.



### 원시 데이터 타입이란?

- 객체는 참조형이다.  참조를 죽 하더라도 결국에는 참조가 아닌 진짜 값을 받아야 한다.
- 그 역할을 하는 것이 원시 데이터 타입이다.



### Number

- javascript수는 부동소수점, "이중정밀도 64비트 형식 IEEE 754 값" 으로 정의된다.
- 비트연산은 결과값을 정수로 빈환하며 32비트 정수로 처리된다.

> 부동소수점 (floating point) 방식은 실수를 표현할 때 소수점의 위치를 고정하지 ㅇ낳고 그 위치를 나타내는 수를 따로 적는 것이다.  유효숫자를 나타내는 가수 / 소수점의 위치를 나타내는 지수로 나누어서 표현한다.

![](https://wikimedia.org/api/rest_v1/media/math/render/svg/af0d9b0b1f2b63a331be5f6693a6d92112f6995c)

```javascript
o.1 + 0.2 = 0.30000000000000004
```

- 자바스크립트는 크기가 큰수에 대해서는 정밀도를 포기한다.
- 이진법으로는 일부 특정한 소수를 제외하고는 정확한 소수를 만들수 없다.
- 따라서 `Number.EPSILON` 이라는 값으로 그 오차 허용치를 ES6에서는 명시해놓았다.



### 연산자

#### 원칙

- 한번에 하나만 실행된다.
- primitive value  만 처리한다.
- 연산자의 대상들은 자료형을 일치시킨다. ( 동일한 타입 )
- 가장 마지막에 쓰인 값을 리턴한다. ( true / false 상관없이, JS만이 그러함 )

```javascript
var a = undefined || 0;		// 0 이다.
var a = undefined && 0;		// undefined 이다.

console.log('3' + 4 + 5);	// 345
console.log(3 + 4 + '5'); // 75

1.3 = 1 + 0.3
0 = 1 / 2
0.5 = 1.0 / 2.0
// 자료형이 생길 경우...
// 연산자는 자료형이 동일해야 한다.
// 연산자는 연산자의 자료형이 다르면 2개의 대상중 하나를 바꿔야 한다.
// 0.3을 변환하면 0이 되므로 이거 말고 1을 1.0으로 바꾼다. 그래서 1.3
// 1과 2가 둘다 정수형이니 값은 0

// int b = 40억, itn c = 40억
// long a;
// a = b + c ; // 에러가 난다. 왜냐하면 b와 c가 int 이기때문에 값도 인트, 80억은 감당 못하니 에러난다.

// 자바스크립트에서 문자를 숫자로 바꾸면 손해가 날 수 있으니, 보통 숫자를 문자로 변환
// 연산자는 프리미티브 타입만 가능하며 객체는 기본적으로 연산이 불가능하다.
```

`,` 는 그 앞의 연산을 수행한다.

- `console.log( (1,2,3) );  // 3 (맨마지막인 3이 리턴한다.) ` 





### 객체

- 객체는 크기가 가변적이며 힙 메모리에 들어간다. 그외 나머지들은 스택 메모리에 들어간다.
- 객체의 경우 스택에는 해당 참고 객체의 주소값 ( 불변 ) 을 넣는다. 즉 참조 타입이다.
- 객체는 연산(+ 등) 을 할 때 가장 기본(default) 값을 정해놓으라고 명시한다.
- 보통 `toStirng()` 을 통해서 값을 반환해서 적용한다.
- 근본적인 구조가 다른 언어(자바, C 등)의 객체와는 완전히 다르다. 
  - 다른 언어들은 class 에서 해당 객체의 정보를 가지고 있다.
  - 멤버 정보들도 해당하는 주소값을 가지고 있어 접근이 빠르다.
- 자바스크립트는 객체의 정보를 객체 자체가 가지고 있다. (메모리 증가)
  - 내부 프로퍼티도 그 체인으로 타고 간다. (속도 느림)



### 리터럴

- 메모리에 올라가는 값, 즉 소스코드가 그대로 메모리에 올라간다는 의미이다.

```javascript
var t1 = [1,2,3];
var t2 = "abcd";
var t3 = {one:1, two:2};

// 이렇게 하면 그대로 배열, 문자열, 객체로 들어가진다.
// C에서는 리터럴은 상수와 유사한 개념이라고 볼 수 있었지만 {}, [] 와 같은 것도 다 포함되어야 하다보니 메모리에 그대로 올라간다는 의미가 더 적절하다고 한다.
```



### 함수























