# 좋은 프로그래머란?


## Good Programmer?
좋은 프로그래머는 구현력, 개발속도, 품질을 가지고 있다. 어떠한 상황에서도 이 세가지가 유지가 되는 사람

## 좋은 개발자가 되려면 어떻게 해야 할까?
프로그래머는 컴퓨터 과학자이다. 
- poor and hard 하므로

컴퓨터 공학자를 원하고, 그 사람을 채용해서 개발자로 훈련시킨다.

2000년대 후반까지 개발자들이 증가했다.
그 이유는 학습 난이도가 하락했기 때문이다.
컴공을 전공하지 않아도 충분히 할수 잇을 정도로..

기업은 따라서 컴공자가 아닌 개발자를 더 선호하게 되었다.
그리고 훈련비용을 낮추고자 했다.

컴퓨터 과학자들을 고용하면 그만큼 비용이 비쌌기 때문에 점점 개발자를 더 선호하게 되었다.

## 지금은 어떤 사람을 원할까?
- 단순히 만드는 것으로는 평가받지 못한다.
- 하나씩 정리해 보자

## 공부를 하는 방법 2가지
1. 컴퓨터 사이언스 computer science
2. 개발 development

### 컴퓨터 사이언스의 목적이란?
- 컴공에 대한 깊은 지식
- 컴퓨팅 사고 훈련


깊은 지식
- 아키텍쳐
- 공학 디자인
- 디지털 회로
- 시스템 디자인
- 컴퓨터 네트워크
- 프로그래밍 기초
- 이산 수학
- 영어
- 운영체제
- 자료구조
- OOP
- 디자인 패턴

각각 과목에 대해서 어떻게 돌아가는지를 연구하기 위함이다.
장점 : 각각의 과목들이 힌트가 된다.
프로그래밍은 상태를 다루는 기술이다.
이것의 원리를 파악한다는 것은 그와 비슷한 프로그램을 작성할때 힌트가 된다.
이러한 과목을 만든 사람들은 우라보다 잘해서 그만큼 높은 효율

컴퓨팅 사고 Computational Thinking
- Open-ended problem (답이 없는 문제) 에 대한 해답을 일반화하는 사고
- 해결해야 할 문제를 만났을 때 컴퓨터 과학자처럼 사고하기
    - 비 구조화된 문제 상황에서 컴퓨터의 원리를 활용하여 문제를 잘게 나누고, 관계 재정립, 재구성 해결하는 사고
- Default Thinking
    - Logical reductions, ambiguity Detection
    - brute-force
- 컴퓨팅 사고를 자연스레 깨우치게 되는데, 모든 논리 구조에서 왜를 가르치기 때문에 컴공을 공부하게 되면 그렇다.

수준 높은 개발을 하기 위한 기반을 만들기 이ㅜ함이다.

### 개발의 목적이란?
- 얕은 지식
- 지식 기반적 사고????

### 개발
- 웹 클라이언트
- 웹 서버
- 게임 클라이 언트


개발 학습 장점
적은 시간, 비용으로 특정 분야의 상품을 빠르게 생산하는데 있다.

사람은 기본적으로 문제를 만났을때 경형 기반 사고를 한다.
경험한데에서 있으면 그것으로 해결란다.

그러면서 얕은 지식을 습득 하고 -> Associative Thinking -> 경험 기반 사고
두뇌활용을 최대한 안 하는 공부법이다.

자신이 경험한 것인지, 아닌지를 사실 알수가 없다.
이러한 것으 ㄹ최대한 피하기 위해서 왜????????????????????????? 를 생각해야 한다.
이것이 사람이 지식을 습득하는 가장 좋은 방법이다.

하지만 대부분 왜?????? 를 생각하지 않는다.

자바스크립트같은 경우 기본적으로 연상작용으로 만들수 있도록 만들어놓았다.
하면 할수록 왜? 를 탐구하지 않는 습관을 가지게 된다.

사람들은 기본적으로 이러한 문제를 찾기 위해서 구글링을 하게 된다. 이렇게 외부적인 요인에 기댈 경우
더욱더 왜? 에 대한 사고를 하지 않게 된다.

기술의 쉬워짐, 외부적 정보를 쉽게 습득 할수 있게 되면 이러한 왜? 두뇌적 사고르 ㄹ하지 않는다.
룰베이스 적인 사고.. 안좋다.
남이 정해준 룰을 가지고 그것에만 따라 가는 것. 자기 스스로 생각하지 않게 된다.



프로그래머가 하는 가장 올바른 사고법이란?
- 딥노하우, 깊은 지식을 공부하는 것. 그럴수록 이것을 기반적으로 생각하게 된다.
- 그리고 이후 얕은 지식을 얻게 되면 왜? 를  컴퓨팅 사고를 하게 된다.
- 이러한 방식이 좋은 경험, 학습이다.
- 컴퓨팅 사고, 딥 노하우 기반으로 얕은 지식을 보는것은 현저히 다르다.

강력한 백그라운드 -> 컴퓨터 과학
컴퓨터 과학을 아는 사람은, 효율적, 확장적, 논리적, 추론등을 할수 있다.


좋은 프로그래머
- 컴퓨터 과학을 잘 아는 사람
- 개발에 능한 사람

회사가 바라는 사람들은 좋은 프로그래머를 찾기 시작했다.

### 프론트 엔드 개발자
- 자바스크립트 코어
- 많은 라이브러리
- MVC 비동익
- 소프트 웨어 월리티 : ooad, tdd, 애자일
- 백엔드에서 전향한 사람
- 다른 언어 프레임워크 경험자
==> 결론은 이런 것을 하는 사람들이 컴사에 큰접하지 않을까?


#### 채용 필수 요건
BA/BS inComputer Science or related technical field
equivalent practical experience or thinking

#### 있으면 좋은 거
experience with one or more general purpose programming languages
웹표준, 프로토콜을 깊게 아는 사람


## 얕은 지식, 경험 주의적 사고 하는 사람의 위험
- poor construction 좋지 않는 구조, 허접한 구조
- wrong thinking 바르지 않는 사고방식, 경험=>만능주의, 학습=> 경험이라고 착각. 문제해결의 주체 => 외부
- 경쟁력이 없어진다. ( 이러한 능력이 없는 사람은 없다. ) 최소한 초년차에서는 경쟁력이 없다.

## 앞으로의 지향점 (앞으로 어떻게 공부해야 할까?)
- 개발 = 경과물 생성의 지름길. 
    - 지름길을 찾기 시작하면 계속 지름길만 찾으려고 한다.
    - 룰베이스적인 사고만 하게 되고 그 이상은 추구하지 안하게된다.

## 좋은 프로그래머란?
- 컴퓨터 사이언스를 아는 사람
- 개발을 하는 사람

이러한 사람이 되려면 컴퓨터 공학을 공부해야 한다.

그나마 괜찮은 길은?
- 컴퓨터 사이언스 -> 컴퓨팅 사고 -> 개발
- 개발 -> 컴퓨팅 사고를 깨우치고 -> 컴공 공부 (최근 이러한 흐름이, 센스있는 사람들이 생기고 잇다.)
- 컴퓨팅 사고는 다른 방법으로도 가능하긴 하다. 
- 비전공자가 프로그래머가 되기 위해서 하는 것은 일단 먼저 컴퓨팅 사고를 깨우치는것이다.
- 컴공 지식은 요즘 플랫폼으로 다 처리해줭서 별 느낌이 없을 수도 있다.
- 문제해결의 본질인 프로그래밍은 본인의 컴퓨팅 사고이다.


스터디
- 목표 : 컴퓨팅 사고
내용
- 백그라운드
- 퀘스트
- 코드 디자인

중요한 것은 왜????????????????????? 를 공부하는 것이다.

어떻게 공부할까?
코드 트레이닝
- 주어진 문제 상황에 대한 자기 주도적 해답
- 어떤 개발이든 상태를 생각하고 개발을 해보라
- State Programming : UI, Platform 배제
- 가위바위보 => UI는 비논리적인 것이다. 따라서 UI부터 생각해서는 안된다.
    - 사용자 인터페이스 적인 것은 비논리 적인 것이다.
    - 나와 상대
    - 가위, 바위, 보 3개의 상태
    - 승리, 패배, 무승부 3개의 상태
    - 이러한 상태가 먼저 정의가 되어야 하고 그다음에 그 상태를 컨트롤하는 것
    - 그 이후에 UI 적인 것을 하는 것이다.
코드 리뷰 
- 왜 이렇게 코딩했을까?
좋은 프로그래머의 코드 리뷰
- 좋은 프로그래머의 코드는 상태를 관리하는 능력이 뛰어나고
- 상태를 숨겨서 처리한다.
    - 상태를 은닉한 코드를 .... 캡슐화 등등..
    -
다른 언어를 사용해 볼것!! 다른 플랫폼들
- 대부분 유사한 사용성을 가진다. 비슷한데 왜 이런 부분은 왜 다를까?
- 웹 브라우저, 안드로이드, 등이 있는데 거기서 화면을 그릴때 코드를 어떻게 짜는지..
- 하다보면 여기서ㅡㄴ 쉽게 되는데, 여기서는 왜 이렇게 안되는 것일까? ????? 플랫폼이라고 하 면 웹기반? 아니면 아예 다른 언어 기반?

좋은 교재
- captain javascript
- 좋은 교재는 왜 이렇게 되는지를 알려 준다.
- 딥노하우를 조금씩 알려준다.
- 정보처리 산업 기사

자바스크립트
- 언어 변화 추이를 이해해 볼것. 왜 이러한 문법, 방법, 기타 등등이 있을까?
- core : Deep Knowledges ?? c++ 까지를 말하는 것인가? 아닌듯
- 다만 이러한 코어를 공부하다 보면, 굳이 쉽지도 않는 방법을 쓰는 경우가 있다. 그런 현상은 그다지 않좋다
- 자바스크립트 원리, 흘러가는지 매커니즘을 이해하는 것이다. 항상 왜 ? 를 생각하라.

결론
- 경험은 문제 해결을 더욱 빠르게 해줄뿐 문제 해결 능력의 본질이 아니다.
- 좋은 프로그래머는 문제 해결에 대한 사고를 스스로 할줄 알고 습관화 해야 한다.
- 항상 공부할때 왜? 를 생각해봐야 한다.





# 직관적이고 심플한 코드 작성 기술

## 읽기 좋은 코드란?
- 현실 세계의 일상적인 개념이 들어간 코드
- 단순히 일상적 개념만 들어간다고 좋은 것으 ㄴ아니다.
- 결국 사람이 더 두뇌를 안쓰는.. 그런 코드가 그러하다
- 기억, 암기 하지 않고  추가적인 사고가 필요하지 않는 코드가 좋은 코드이다.

## 식
- 가장 버그가 발생하기 쉬운 부분이다.
- speed > = 10.5 , power > = 20
- hitPoint.x === (rock.width / 2)
- if( speed >=.......)
- 각각의 역할에 대해서 정의된 부분이 있을 것이다.
- 식에 대해 문제를 나누어서 의미있는 키워드로 바꿔준다. 그다음 if문을 작성해 준다.
```
var isDash = seppd > 10.5
var isMaxPower = power> 20

if( isDash %% isMaxPower ....)

if( isDash(..) %% ....) // 논리적인 축소
```

### 논리적인 축소
var isSale = function(id) {
    var result = false;
    var product = getProduct(id);

    if( product !== null ) {
        if () {
            if()......
            if( isInRange(product.saleStateDate, product.salseEndDate) )...  //자기 설명적인 코드
        }
    }
}


## 제어문
- 조건문, 반복문, 기타 등등
- 코드를 복잡하게 만드는 문제의 근원
- 최대한 중첩을 줄이는 방법

### 감축
- 코드의 복잡성은 조건 분기의 수
- if ( 10 < x) { x= 10;} ==> x = Math.min(x, 10)
- while( ) { if(10<=x){x=0} x++} ==> while(){ x %=10; x++;}
- if( 10 < x) { x = 10;} else if( 0 > x) { x = 0} ==> x = Math.min(Math.max(0, x) , 10); 0 ~ 10 사이의 코드
==> x = fixNumRange(x, 0, 10); 이렇게 자기 설명적 코드로 바꿔준다.
- if( is Dash(..) && .........................) if() if() if() ==> 이렇게 뎁스가 깊어지면 가독성 감소, 암기를 해야 한다.
- if 안에 if 안에 이런식으로 짜지 말고, if() return false,  ㅇ런식으로 계속 내리는게 좋다. assertion (기저사례 단정)
- 한 라인 정보량이 적을수록 가독성이 증가한다.
- 기저 사례를 사용해서 핵심로직과 코드의 종결점이 동일 ( 뎁스가 종일해진다. ) 그래서 가독성이 많이 좋아진다.
- 기저 사례를 사용하자. 이렇게 기저사례를 단정하는 패턴은 퍼포먼스가 좋은 코드를 짜는데 필요한 패턴이다.

### else
- else를 만나게 되면 사고의 흐름이 끊긴다. 따라서 else를 최대한 한써주는게 좋다.
- if else의 경우 한쪽만 비대에지는 경우가 많다. 비대에 지지 않는 곳을 기저사례로 잡고 짜주는게 좋다.
- else if 또한 그전의 아니었던 조건들을 암기해야 하기 때문에.. 별로다.
- else if가 있을경우 다른 식이 있을수 있다는 긴장감이 있을수 있다.
- 이렇게 4지 선다의 경우에는 switch를 써주는게 좋다. else if도 마찬가지 이다.

### 중복 통합
- 중복되는 코드를 합치고 if 문일 경우 기저사례 활용으로 종결점을 일치시킨다.
- for() { if ....} ==> if { for(){}} ==> if{} for{} 이렇게 기저사례로

### 국소화 (지역화)
if{position += derection * 10}
elseif{position += derection * 10}

이것은 삼항 연산자나 
var speed = 5;
if(isDash() speed...)  이런식


- 분기는 최대한 감축
- 기저사례에 댛나 단정
- 조건이 침범하는 영역의 국소화
- 핵심로직과 코드 종결점을 동일하게 유지한다.

## 반복문
### 문제 분할
```
var fireSwords = [];
for() {
    if( items[i].type !== ITEM_TYPE_SWORD)
        continue;
    if( items[i].type !== ELEMENT_TYPE_FIRE)
        continue;
    fireSwords.push(items[i]);
    if(isHappen1())
        breakItem(items[i])
    if(isHappen2())
        breakItem(items[i])
} // 리팩토리 대상


반복의 역할을 나누기
for(){
    // 아이템 타입, 문 타입
}
for() {
    // 칼이 깨지는 것
}

굳이 하나의 for문에 다 할필요가 없다.
for을 분할하면서 좀더 간결하고 가독성이 좋아진다.
```
### 반복문의 일반화
- 반복문 안의 많은 정보가 있어서 결국 코드를 봐야 한다.
- 문제점 : 종결점이 다르다. 결국 for문 아래에서 처리해야 하기 때문에 종결점이 다르다.
- 이 반복문에서 무엇을 참조해야 하는지 다 봐줘야 한다. 
- 값을 다루는데 있어 번거로운 절차이다.
- 이런 것을 filter나 기타 등등을 써준다.
- 하나만 뽀비아낸다. [].find
- 전체 것들을 할경우 map 사용
- 반복문의 일반화된 함수들을 쓰자.

### 기저사례 단정
- if들을 기저사례 단정


3D, 리얼타임 렌더링이 아니라면 for와 forEach간의 성능 차이로 이슈가 될 일은 거의 없다.
그리고 내부 로직으로서 컨트롤하는 게 좋다.


초반에 기저사례들을 다 처리해 놓고. (일종의 밸리데이션) 그후에
핵심로직들은 다같이 모여있는게 좋다. 그리고 그것들이 종결점과 뎁스를 맞춰놓는게 좋다.

# 퀘스트
## 문제해결 퀘스트
아이돌 그룹의 팬사인회를 개최,
남녀 혼성으로 된 그룹의 멤버들은 일렬로 앉아 있다.
사인회에 참여한 n명의 팬들이 한명씩 횐쪽으로 이동하여 사인을 받고 포옹을 한다.
남자끼리 엮었을때 
줄을 선 아이돌 그룹 멤버들과 팬들의 성별이 임의로 주어질때, 팬 사인회가 진행되는 과정에서 아이돌 그룹의 모든 멤버가
동시에 포옹을 하는 일이 몇번 일어나는지를 구하는 프로그램을 작성하세요.
