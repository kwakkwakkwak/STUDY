옛날에는 프로그래밍이 어려웠다. 왜냐하면 하드웨어 성능이 안좋았고 표준이 없었다.
알고리즘 등을 알아야 했다.

프로그래머에게 의존도가 심히 높은 상황에서 그것을 극복하기 위한 방법론
Data Driven Programming

Document Language : 쉬운 문서(여러 수치들이 기입)를 디자인하여 디자이너에게 제공 => 퍼블리싱
Script Language : 쉬운 언어(비논리적 접근)를 디자인하여 디자이너에게 제공한다. => 스크립팅

이후 프로그래머는 DDE를 만들고 각 디자이너 들은 그 엔진을 이용해서 어플리케이션을 만든다.  
이로서 전문화된 분업이 이루어지게 된다.  

하지만 그것조차 어려울수 있기 때문에 퍼블리셔, 스크립터를 두기 시작하였다.  

개발 협업, 개발 생산성이 증가할 것이라고 예상했었다.  
하지만 DDE의 경우 해당프로젝트에서만 사용되며 비표준이다. 따라서 작업자가 들어올때마다  
DDE 언어를 교육하고 프로젝트마다 DDE 언어를 만들어야 했다.  

따라서 제대로 못만들면 오히려 생산성이 줄어든다.  

특정 시스템에 귀속되지 않는 범용적인 스크립트 언어가 생기게 되었다.  
파이썬, 스킴, 루비, php, javascript 등등.. 표준성이 생기게 된다.  

=============================

스크립트 언어와 프로그래밍의 관계  
Data Driven Architecture는 오늘날 Web Client Architecture과 유사하다.  
  
스크립트 언어는 프로그래밍 언어인가?  
  
스크립트언어는 주체가 되는 프로그램( 웹에서는 브라우저 ) 이 제공햊는 것이외에는 일을 할수 없지만,  
주체가 되는 프로그램이 플랫폼이 모든 기능으 ㄹ컨트롤할수 잇게 발전..  
그모든 것을 스크립트 언어로 조작 가능하도록 제공  
  
이것을 All Round Mapping 이라고 한다.  
  
시간이 지날수록 스크립트 언어는 프로그래밍 언어로,   
프로그래밍 언어는 스크립트 언어의 사용성 편이로 접접 접근하고 있다.  
  

옛날의 프로그래머  
Native 언어 사용자, 컴퓨터 과학자  
    
지금의 프로그래머    
언어 무관, 프로그래밍 기술 구사 하는 사람  
컴공인이 아닐수도 있다.  
  
스크립트 언어 : 자료 주도적 개발 법의 산불, 런타임 해석 지향, 보조적 사용 언어  
  
자바스크립트
- 명확한 설계사상
- 유연함, 쉬움
- 다른 어플리케이션에 쉽게 붙는다.

왜 쉬운가?
- 스크립트 언어라서 쉽다.

- 사용성 자체가 일관적이다. 모든 객체를 익명객체로 기본 취급, 자료형으로 함수가 있다. 

- 유연하다.
    - 데이터 타입이 막 변해도 귄찮
    - generic object
    - 클로져, 스코프가 유연하다.

- 기본 사상 : 절대로 프로그래머를 믿지 않는다.
    - 엄격하지 않다.
    - 실행 컨텍스트 : 변수를 메모리에 점유하는게 아니라 함수 실행시에 실행 컨텍스트가 알아서 생성
    - GC
    - Promotion : 자료형이 다르게 하더라도 치명적인 오류가 발생하지는 않는다.

- 메모리를 무한하게 추상화한다. ( JS로 어떤 짓을 하더라도 왠만하면 다 감당할수 잇게 되어있다. 동적 메모리 )
- unlimited memory abstraction javascript

- 웹 플랫폼에 임베디드하게 되어 있다. 
    - 웹 개발 자체가 비상태적으로 개발 따라서 발전하기가 쉽다.

- 개발자를 안 믿어서 만들었기 때문에 그 부분에 대해서 너무 깊게 생각하지 않는게 좋다.

왜 어렵게 느끼는가?
- 그걸로 프로그래밍을 하려고 하기 때문이다.
- 따라서 언어 자체의 깊이보다는 어떻게 프로그래밍을 잘하는지에 대한 것을 아는게 더 중요하다.


언어는 아래에서가 아니라 위에서 거만하게(?) 내려다 보는거.

================================================================================

# 코드디자인

### 읽기 좋은 코드란?
현실 세계의 일상적인 개념이 들어간 코드

현실 세계의 일상을 연상 시킬수 있는 수단 : Keyword


## 키워드 네이밍 ( 각종 어휘와 이름 )
변수 이름은 읽기 좋은 것으로 붙여주세요

## 네이밍룰
- 직관적, 보편적 단어
- 무엇인지 유추가 가능하도록
- 야ㄱ칭사용 배제
- 값의 형태가 유추 가능하도록( 자료형 )  ???  자료형이 동적 변화가 이루어지는데, 오히려 혼란이 더 오지 않을까요?
- 사람의 연상작용이 이루어지도록 만들어주는게 좋다.
-

## 변수 네이밍
- Boolean : isSales, salesYN
- String : name, profile, filename (명사형)
- Number : no, count, price, score (숫자를 나타내는 명사), rate
- Structure object : user, product 등..

## 변수 이름은 읽기 좋은 것으로 붙여주기
- 사람마다 읽기좋은게 달라서 프로그램 의도와는 다른 키워드..'
    - 사고방식의 문제
    - 프로그램에 대한 이해 부족

### 프로그램에 대한 이해?
- 시스템 디자인 -> 기획
- 원본 구조체 명세
    - 네이밍 룰
    - 기획적 원본요소(기획을 할때 나오는 원시 데이터)       ??? 각 케릭터당 역할, 메소드 역할이나 기타 등등에 대한 인식
    - 기획적서비스 요소( 종족을 바꾸기, 쇼핑몰에서의 서비스 등등 )
    - 구조체 단위
    - 프로그래밍은 기획의 구조체, 구현체이다.

- 왜 명세를 해야하나?
    - 프로그램 이해도 증가, 의도 파악 증가
    - 프로젝트 구성원 간 의사소통
    - 프로그램 과정 및 결과 예측성 증가

- 원본 구조체를 왜 만들어 봐야 하는건가?
    - 연상 사고가 증가한다. 잘짠건 잘읽지만 아니면 못짠건 못읽게 되는 문제가 있다.
    - Computational thinking : 답이 없는 문제를 일반화 하는 사고... 이게 중요하다. 
    - 설계를 할때 연상 사고를 더욱더 빨리 하기 위해서 유도를 해줘야 한다. 그것을 올바르게 해주는 것이 CT 이다.

- 왜 구조체인가?
    - 사람은 구조체 단위로 기본적으로 접근을 한다.
    - 구조체 단위로 설계하고 개발하는게 프로그래밍 할때 도움이 된다.

함수
- 접두사 + 키워드 ( + 전치사 + 키워드 )
- gettr : 명령+ 대상(+무엇으로)

Porting Rule??????????
- NameingRule
    - 구조체명세에 의거, 조합하여 사용
    - 프로젝트에 맞춘 보편적인 표기적
- 팁
    - 기획적 원본 / 서비스 구조체 이외의 키워드 사용 최소화
    - 왜냐면 프로그램은 디자인의 구현체이기 때문에 그렇다.

상수
문자원시값으로 해놓으면 그 문자값들을 다 외워야 한다.
상수로 할 경우 기본적인 JS 툴의 도움을 받을수있다. 자동 완성등.. 또한 인수인계를 따로 해줄 필요가 없다. 
따로 상수 파일이 존재하니까

조금 길어지더라도 의미를 전달할수 있는 이름을 지어주는 게 좋다.
자료형의 유추가 가능하도록. 
이름을 제대로 지을려고 노력하면 문제에 대한 깊은 사고를 할수 있다. 컴퓨팅 삭에도 좋다.

키워드 정의는 시스템 디자인에서부터 들어가면 좋다.

네이밍에 시간을 많이쓰세요. 
네이미으이 완성은 로직의 완성으로 이어진다. 
네이밍을 진지하게 지음으로서 이유와 분석이 포함되어 있고 그것은 로직으로 이어지게 된다.

??? 네이밍... .역할 기타 등등.. 그 기준이 무엇인가?
?????????????? 객체 자체는.. 자바스크립트.. 객체지향적으로 가지는 않는다.일상생활의 개념에서는 동떨어져 있어서.. 사람이 접근하기 어렵다. 
JS 는 오브젝트 기반 개발..

좋은 프로그래밍에 필요한 것은 문제를 분석하고 답을 내리느냐.. 코드를 작성하는데 가장 중요한 능력이다.
책만 본다고 되는 건 아니고 훈련이 필요하다.
너무 믿지 말고 항상 왜? 라는 의문을 가지고 질문을 던져 주는게 좋다.
네이밍은 20자 내외가 좋다.


영역중심 모델
cocos2dx


```javascript

var ATTACK_TYPE_GAWI  = 1;
var ATTACK_TYPE_BAWI  = 2;
var ATTACK_TYPE_BO    = 3;

var RESULT_TYPE_DRAW = 0;
var RESULT_TYPE_WIN  = 1;
var RESULT_TYPE_LOSE = 2;
var RESULT_TYPE_FRAUD = 3;

var getAttackTypeName = function(attackType) {
    switch(attackType) {
        case ATTACK_TYPE_GAWI : return '가위';
        case ATTACK_TYPE_BAWI : return '바위';
        case ATTACK_TYPE_BO   : return '보';
    }
}



var gawibawibo = function( myAttackType, yourAttackTYpe ) {
    if( myAttackType = yourAttackType ) {
        return RESULT_TYPE_DRAW;
    }

    switch( myAttackType ) {
        case ATTACK_TYPE_GAWI : 
            return yourAttackType === ATTACK_TYPE_BO ? RESULT_TYPE_WIN:RESULT_TYPE_LOSE;
        case ATTACK_TYPE_BAWI : 
            return yourAttackType === ATTACK_TYPE_GAWI ? RESULT_TYPE_WIN:RESULT_TYPE_LOSE;
        case ATTACK_TYPE_BO : 
            return yourAttackType === ATTACK_TYPE_BAWI ? RESULT_TYPE_WIN:RESULT_TYPE_LOSE;
    }
    return RESULT_TYPE_FRAUD;
};

var myAttackType = prompt('가위바위보르르 입력해주세요 1 ~ 3');
    myAttackType = 1*myAttackType;

console.log(
    gawibawibo( myAttacktype, ~~(Math.random()*3) )
)
```