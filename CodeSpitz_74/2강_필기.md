루틴을 사용할 참조가 퍼져나가는 지를 바라보자. 사이드 이펙트를 조심해야 한다.



## SPREAD REFERENCE

![](./img/2_1.png)

복사본 B가 생긴다.

지역변수에서 참조를 생성해서 반환을 하더라도 참조변수는 결국 A만 남게 되므로 아무런 사이드 이펙트가 생기지 않는다. 

이런 경우 지역변수에서 만든 객체가 특별하게 물지 않는 경우라면 참조 객체를 반환하더라도 아무런 문제가 생기지 않을 것이다.

참조 D를 인자로 넘긴다. 이럴 때 참조는 다른 참조를 물수 있는 능력이 있다. 로컬 객체가 참조 인자를 물어버린다. 이렇게 되면 C와 D가 서로 암묵적으로 연결되는 일이 벌어진다. 

참조는 한번 보내면 끊임없이 오염된다. 리드 온리를 써도 오염된다. C를 조작하다보면 D까지 변경되는 일이 생기는데, 그걸 인식조차 할수 없다. 이 함수 안을 들여다 보지 못하니까. 이때의 함수는 라이브러리의 함수가 되거나 다른 사람이 짠 함수라고 한다면 그것을 보기 힘들다.

함수를 작성할 때마다 참조에 대한 개념을 잘 알고 , 함부로 물지 않도록 조심하지 않으면 순식간에 오염이 된다. C가 계속 참조하기 때문에 D가 계속 유지되는 일이 생길수 있다.



## SUB ROUTINE CHAIN

![](./img/2_2.png)

서브루틴에 인자, 결과값을 주고 받을 때, 인자에 참조를 보내면 무조건 위험해 진다. 인자로 참조를 안 보내는게 가장 상책이다. 하지만 인자를 값 타입으로 보냈을 때 그 복사 비용이 너무 크다면 인자에 참조로 보낼 수 있다. 하지만 컴퓨터는 엄청 빠르기 때문에 웬만하면 그렇게 성능에 걸리는 경우는 잘 없다. =성능을 따지게 되는 프로그램을 만들수 있게 되면 그거 자체만으로도 축하할만한 일이다. 그러니 대부분 복사본을 보내도 된다. 명백하게 성능상에 문제가 생기는 경우는, 애니메이션 루프, 셋인터벌에 걸려있는거, 이 루프가 다시 루프안에서 쓰일거 같애, 레버리지 효과로 커질 더 같은 것은 제외하고는 다 복사본을 보내는 것이 상책이다. 

참조로 인자를 보내면, 뭐가 위험한가? 남이 짠 함수를 믿기 싫은 것이다. 함수에게 항상 복사본만 주면 된다. 함수는 대부분 자신이 만든 함수는 별로 없다. 그래서 타인의 함수가 안정적인지 아닌지 알수가 없다. 그 안정성을 믿기 싫다면 그 함수 호출 할때 복사본을 보내면 그만이다. 리액트에서 이뮤터블js를 권고하는 것도 마찬가지이다. 참조값을 보내는 것은 굉장히 위험하다.

중첩된 서브루틴을 서브루틴 체인으로 다시 배울 것이다.

콜스택이 생성되어 함수안의 함수를 계속 호출하면 스택이 쌓인다고 배웠다. 이러한 것들을 서브루틴 체인이라고 부른다. 

스택의 정체

하나의 함수안에 인자와 지역변수가 각각 존재하고 있다. 각 루틴을 부를 때마다 다 함수마다 기억해야 하는 인자와 지역변수가 있다. 그래서 스택이라고 부르는 정체는 사실 인자와 지역변수를 기억하는 것이다. 더이상 인자와 지역변수를 기억할 필요가 없으면 어떨까? 

![](./img/2_3.png)

이렇게 바꾸먀면 return에서 호출한 이후가 없다. 호출한 시점에 더이상 기억할 필요가 없다. 호출을 꼬리에 붙이면 된다. 하지만 그렇더라도 지역변수와 인자를 제외한 함수를 호출한 리턴 포인트를 기억해야 한다.  그래서 여전히 스택이 쌓이게 딘다. 스택을 제거하려면 이것들 조차 제거해야 한다. 여기서 한단계더 나아가서, 루틴들의 리턴되는 지점들을 계속 거쳐서 지나가지 말고 맨 처음의 호출 지점으로 바로 보내주면 스택이 생기지 않을 것이다. 원래 함수는 호출할 때 호출할때 결과값을 받을 포인터를 같이 넘겨준다. 루틴을 호출할 때 포인터째로넘겨주니까 스택을 잡을 필요가 없다. 그러니 막판에는 그냥 원래 포인터로 가면 된다. 몇번을 호출해도 스택이 쌓이지 않는다. 이것을 **꼬리물기최적화** 라고 부른다. 

## TAIL RECURSION

![](./img/2_4.png)

꼬리물기 최적화 로직을 사용하면 스택을 제거할 수 있다. 몇단계호출을 해도 메모리 고갈을 방지할 수 있다. 여기에는 함수의 특수한 기능이 있다. 이러한 상황이 되면 리턴 포인트까지 암묵적으로 보내주는 것이다. 하지만 이것은 언어의 엔진이 지원한다. 자바스크립트에서는 스펙에서 지원을 하지만, 웹킷에만 구현이 되어 있다. 즉 사파리에서만 가능하다. 즉 맥에서의 사파리에서만 동작한다. 

```javascript
const sum = v => v + (v > 1? sum(v-1) : 0);

sum(3); // return 3 + sum(2)
                   // return 2 + sum(!)
                              // return 1 + 0
```

이 재귀함수가 스택을 해제 할수 없는 이유는 연산스택때문이다. 이 더하기가 좌항, 우항을 더하려면 좌항 우항이 다 해결되어야 연산을 할수 있다. 그러니 더하기가 이미 스택을 물고 있는데 이것을 연산스택이라 하며 그래서 메모리를 해제할 수가 없다. 함수를 호출하는 것이 해결되기 전까지는 연산의 결과를 마무리할 수 없기 때문이다. 마지막에 함수를 호출했는데도 불구하고 연산식이 있으면 그대로 스택 메모리가 쌓이는 것이다. 마지막에 인자간 연산이나 연산자가 등장하지 않고, 순수하게 값의 연산이나 호출만 등장애야 한다. 이것을 어떻게 꼬리재귀 최적화로 바꿀 수 잇을까?

연산스택 메모리를 쓰고 있다. 함수 호출시마다 좌항에 대한 메모리를 예약해서 쓰고 잇는 것이다. 어떻게 하면 좌항에서 쓰고있는, 여산식에 쓰고 잇는 메모리를 어떻게 옮겨야 꼬리재귀최적화를 할수 있을까? 함수의 인자ㅣ 영역을 쓰는 것이다. 

```javascript
const sum = (v, prev = 0) => {
  prev += v;
  return v > 1? sum(V - 1, prev) : prev;
};
sum(3);  // return sum(2,3)
         // return sum(1,5)
         // return 6 <= 6을 바로 반환하면 된다.
```

인자 쪽으로 올겨주자. 아까는 연산식이 물고 있었는데 이제는 prev라는 변수에 옮겨주었다. 단순한 값의 함수 호출 인자 또는 값으로 떨굴수가 잇?게 되었다. 이제서야 꼬리재귀 조건을 만족했다. 연산식에 있는 메모리를 인자쪽으로 보내버렸다. 그래서 연산결과의 메모리를 다음 함수의 인자가 유지해 준다.이래서 연산식이 더이상 유지할 필요가 없다. 자신의 상태를 다 이관하는 데에는 인자로 다 넘길수 밖에 없는 것이다. 

꼬리 재귀로 바꾸는 것은 메모리에 대한 요구사항을 정리해서 다 호출에 넘겨주는 것이다. 하지만 문제는 꼬리재귀를 지원하는 것은 사파리밖에 없다. 그래서 우리는 루프로 바꿔줘야 한다. 다른 브라우저에서는 꼬리재귀 최적화가 일어나지 않아 스택 메모리가 쌓이기 때문이다. 

지원하지 않는 브라우저에서는 루프로 바꾸는 거 밖에는 답이 없다.

## TAIL RECURSION TO LOOP

![](./img/2_5.png)

재귀함수를 루프로 바꾸는 순서

1) 먼저 재귀함수를 꼬리재귀최적화로 바꾼다. 그래야 바꾸기 쉽다.  
2) prev가 유지하려는 메모리, 기록이다. 이것을 재귀호출이 아닌 지역변수로 만든다.  
3) 재귀를 발동시키는 조건을 루프의 조건으로 하면된다.  
4) 재귀함수가 하는 일을 루프 안에 넣어준다.  
5) prev를 마지막으로 반환하면 된다.

꼬리물기 최적화를 하고, 다시 루프로 바꿔줘야 한다. 큰 루프 구문을 재귀로 처리할 수 없다. 지금까지는 루프로 바꿔주어야 문제가 해결되는 것이다. 

## CLOSURE

지금까지는 정적 함수 개념을 배운 것이다. 파싱 시점에 모든 함수가 정적으로 확정되어 있는 것을 말한다. 이것은 사용할 함수가 A~z함수라면 그 26개의 함수를 정의하고 그 함수들을 더이상 건드리지 않고 26개의 함수를 호출해서 사용하겠다는 것이다. c같은 언어들이 이러한 정적함수만 사용한다. 이것은 실행중에 함수를 만들어내지 않는 다는 것을 의미한다. 보통은 자바스크립트도 정적스타일로 많이 쓰인다. 그에비해서 현대 언어들은 함수, 클래스 같은 구조체를 정적인 사용뿐만 아니라 실행도중에 만들어내는 방법을 사용한다. 

그래서 이 과정중에 부산물이 클로져 이다.

28분 33초 부터



 





[프로그래밍의 정석 독서 토론회](https://www.facebook.com/events/1762920637060224/?acontext=%7B%22ref%22%3A%224%22%2C%22action_history%22%3A%22null%22%7D)

오후 8 화 · 한빛출판네트워크 강의실20

참석 14명 · 관심 있음 5명

4주간 진행되는 프로그래밍의 정석 독서토론회 3회차 입니다.
사전에 이번 독서모임에 신청한 사람들만 참여가 가능합니다.









